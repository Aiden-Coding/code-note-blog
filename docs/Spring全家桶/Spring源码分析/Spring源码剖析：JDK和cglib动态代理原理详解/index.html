<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Spring源码剖析：JDK和cglib动态代理原理详解 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Spring源码剖析：JDK和cglib动态代理原理详解 | Tommy"><meta data-rh="true" name="description" content="* 前言"><meta data-rh="true" property="og:description" content="* 前言"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">Spring</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：初探SpringIOC核心流程">Spring源码分析</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：初探SpringIOC核心流程">Spring源码剖析：初探SpringIOC核心流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：懒加载的单例Bean获取过程分析">Spring源码剖析：懒加载的单例Bean获取过程分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：AOP实现原理详解">Spring源码剖析：AOP实现原理详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解">Spring源码剖析：JDK和cglib动态代理原理详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：Spring事务概述">Spring源码剖析：Spring事务概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：Spring事务源码剖析">Spring源码剖析：Spring事务源码剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：SpringAOP概述">Spring源码剖析：SpringAOP概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：SpringIOC容器的加载过程">Spring源码剖析：SpringIOC容器的加载过程</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring启动流程/Spring启动流程（八）：完成BeanFactory的初始化">Spring启动流程</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring事务/Spring事务（二）：事务的执行流程">Spring事务</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring重要机制探秘/ConfigurationClassPostProcessor（二）：处理@Bean注解">Spring重要机制探秘</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring组件分析/Spring组件之ApplicationContext">Spring组件分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/SpringAOP/AnnotationAwareAspectJAutoProxyCreator分析（上）">SpringAOP</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringBoot/给你一份SpringBoot知识清单">SpringBoot</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringBoot源码解析/SpringBoot启动流程（四）：启动IOC容器">SpringBoot源码解析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloud/SpringCloudConsul">SpringCloud</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudConfig源码分析">SpringCloud源码分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloudAlibaba/SpringCloudAlibaba概览">SpringCloudAlibaba</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloudAlibaba源码分析/SpringCloudAlibabaNacos源码分析：服务发现">SpringCloudAlibaba源码分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringMVC/SpringMVC常见注解">SpringMVC</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringMVC源码分析/请求执行流程（二）之执行Handler方法">SpringMVC源码分析</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Spring源码分析</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Spring源码剖析：JDK和cglib动态代理原理详解</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Spring源码剖析：JDK和cglib动态代理原理详解</h1></header><p>#目录</p>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#java%E4%BB%A3%E7%90%86%E4%BB%8B%E7%BB%8D">Java代理介绍</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">静态代理</a></li>
<li><a href="#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">JDK动态代理</a>
<ul>
<li><a href="#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">JDK动态代理实现原理</a></li>
<li><a href="#proxy%E7%B1%BB%E4%B8%AD%E7%9A%84newproxyinstance">Proxy类中的newProxyInstance</a></li>
<li><a href="#%E5%AD%97%E8%8A%82%E7%A0%81%E7%94%9F%E6%88%90">字节码生成</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">代理类的方法调用</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6">深入理解CGLIB动态代理机制</a>
<ul>
<li><a href="#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B">CGLIB动态代理示例</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1">生成代理类对象</a></li>
<li><a href="#%E5%AF%B9%E5%A7%94%E6%89%98%E7%B1%BB%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86">对委托类进行代理</a></li>
</ul>
</li>
</ul>
<p>转自 <a href="https://www.jianshu.com/u/668d0795a95b" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/u/668d0795a95b</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章将同步到我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《Spring和SpringMVC源码分析》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何从spring基础入手，一步步地学习spring基础和springmvc的框架知识，并上手进行项目实战，spring框架是每一个Java工程师必须要学习和理解的知识点，进一步来说，你还需要掌握spring甚至是springmvc的源码以及实现原理，才能更完整地了解整个spring技术体系，形成自己的知识框架。</p>
<p>后续还会有springboot和springcloud的技术专题，陆续为大家带来，敬请期待。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="前言">前言<a href="#前言" class="hash-link" aria-label="Direct link to 前言" title="Direct link to 前言">​</a></h2>
<p>AOP的基础是Java动态代理，了解和使用两种动态代理能让我们更好地理解 AOP，在讲解AOP之前，让我们先来看看Java动态代理的使用方式以及底层实现原理。</p>
<p>本文是基于jdk1.8来对动态代理的底层机制进行探究的</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="java代理介绍">Java代理介绍<a href="#java代理介绍" class="hash-link" aria-label="Direct link to Java代理介绍" title="Direct link to Java代理介绍">​</a></h2>
<p>Java中代理的实现一般分为三种：JDK静态代理、JDK动态代理以及CGLIB动态代理。在Spring的AOP实现中，主要应用了JDK动态代理以及CGLIB动态代理。但是本文着重介绍JDK动态代理机制，CGLIB动态代理后面会接着探究。</p>
<p>代理一般实现的模式为JDK静态代理：创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>
<p>其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系(即上面提到的持有的被带离对象的引用)，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="静态代理">静态代理<a href="#静态代理" class="hash-link" aria-label="Direct link to 静态代理" title="Direct link to 静态代理">​</a></h2>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140729721-1002455386.png" alt="" class="img_kGBN"></p>
<p>接口</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140729978-492174823.png" alt="" class="img_kGBN"></p>
<p>被代理类</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140730312-501564524.png" alt="" class="img_kGBN"></p>
<p>代理类</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140730518-1275832673.png" alt="" class="img_kGBN"></p>
<p>测试类以及输出结果</p>
<p>我们可以看出，使用JDK静态代理很容易就完成了对一个类的代理操作。但是JDK静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p>
<p>下面我们使用JDK动态代理来做同样的事情</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="jdk动态代理">JDK动态代理<a href="#jdk动态代理" class="hash-link" aria-label="Direct link to JDK动态代理" title="Direct link to JDK动态代理">​</a></h2>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140729721-1002455386.png" alt="" class="img_kGBN"></p>
<p>接口</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140729978-492174823.png" alt="" class="img_kGBN"></p>
<p>被代理类</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140731035-1119549632.png" alt="" class="img_kGBN"></p>
<p>代理类</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140731317-1929161422.png" alt="" class="img_kGBN"></p>
<p>测试类以及输出结果</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="jdk动态代理实现原理">JDK动态代理实现原理<a href="#jdk动态代理实现原理" class="hash-link" aria-label="Direct link to JDK动态代理实现原理" title="Direct link to JDK动态代理实现原理">​</a></h3>
<p>JDK动态代理其实也是基本接口实现的。因为通过接口指向 实现类实例的多态方式，可以有效地将具体实现与调用解耦，便于后期的修改和维护。</p>
<p>通过上面的介绍，我们可以发现JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。但是不同之处也非常明显----在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。</p>
<p>让我们用一句话来总结一下JDK静态代理和JDK动态代理的区别，然后开始探究JDK动态代理的底层实现机制：<br>
<!-- -->JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时创建代理类的。<br>
<!-- -->其实在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的invoke方法。所以对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p>
<p>我们从JDK动态代理的测试类中可以发现代理类生成是通过Proxy类中的newProxyInstance来完成的，下面我们进入这个函数看一看：</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="proxy类中的newproxyinstance">Proxy类中的newProxyInstance<a href="#proxy类中的newproxyinstance" class="hash-link" aria-label="Direct link to Proxy类中的newProxyInstance" title="Direct link to Proxy类中的newProxyInstance">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> public static Object newProxyInstance(ClassLoader loader,                                          Class&lt;?&gt;[] interfaces,                                          InvocationHandler h)        throws IllegalArgumentException    {        //如果h为空将抛出异常  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Objects.requireNonNull(h);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Class&lt;?&gt;[] intfs = interfaces.clone();//拷贝被代理类实现的一些接口，用于后面权限方面的一些检查  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final SecurityManager sm = System.getSecurityManager();        if (sm != null) {            //在这里对某些安全权限进行检查，确保我们有权限对预期的被代理类进行代理  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*         * 下面这个方法将产生代理类  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*         * 使用指定的调用处理程序获取代理类的构造函数对象  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */        try {            if (sm != null) {                checkNewProxyPermission(Reflection.getCallerClass(), cl);            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);            final InvocationHandler ih = h;            //假如代理类的构造函数是private的，就使用反射来set accessible  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!Modifier.isPublic(cl.getModifiers())) {                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {                    public Void run() {                        cons.setAccessible(true);                        return null;                    }                });            }            //根据代理类的构造函数来生成代理类的对象并返回  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return cons.newInstance(new Object[]{h});        } catch (IllegalAccessException|InstantiationException e) {            throw new InternalError(e.toString(), e);        } catch (InvocationTargetException e) {            Throwable t = e.getCause();            if (t instanceof RuntimeException) {                throw (RuntimeException) t;            } else {                throw new InternalError(t.toString(), t);            }        } catch (NoSuchMethodException e) {            throw new InternalError(e.toString(), e);        }    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以代理类其实是通过getProxyClass方法来生成的：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> /**     * 生成一个代理类，但是在调用本方法之前必须进行权限检查  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */    private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                           Class&lt;?&gt;... interfaces) {        //如果接口数量大于65535，抛出非法参数错误  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (interfaces.length &gt; 65535) {            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果在缓存中有对应的代理类，那么直接返回  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 否则代理类将有 ProxyClassFactory 来创建  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return proxyClassCache.get(loader, interfaces);    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>那么ProxyClassFactory是什么呢？</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">   /**     *  里面有一个根据给定ClassLoader和Interface来创建代理类的工厂函数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */    private static final class ProxyClassFactory        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;    {        // 代理类的名字的前缀统一为“$Proxy”  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 每个代理类前缀后面都会跟着一个唯一的编号，如$Proxy0、$Proxy1、$Proxy2  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final AtomicLong nextUniqueNumber = new AtomicLong();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);            for (Class&lt;?&gt; intf : interfaces) {                /*                 * 验证类加载器加载接口得到对象是否与由apply函数参数传入的对象相同  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */                Class&lt;?&gt; interfaceClass = null;                try {                    interfaceClass = Class.forName(intf.getName(), false, loader);                } catch (ClassNotFoundException e) {                }                if (interfaceClass != intf) {                    throw new IllegalArgumentException(                        intf + &quot; is not visible from class loader&quot;);                }                /*                 * 验证这个Class对象是不是接口  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */                if (!interfaceClass.isInterface()) {                    throw new IllegalArgumentException(                        interfaceClass.getName() + &quot; is not an interface&quot;);                }                /*                 * 验证这个接口是否重复  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {                    throw new IllegalArgumentException(                        &quot;repeated interface: &quot; + interfaceClass.getName());                }            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String proxyPkg = null;     // 声明代理类所在的package  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*             * 记录一个非公共代理接口的包，以便在同一个包中定义代理类。同时验证所有非公共  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 代理接口都在同一个包中  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */            for (Class&lt;?&gt; intf : interfaces) {                int flags = intf.getModifiers();                if (!Modifier.isPublic(flags)) {                    accessFlags = Modifier.FINAL;                    String name = intf.getName();                    int n = name.lastIndexOf(&#x27;.&#x27;);                    String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                    if (proxyPkg == null) {                        proxyPkg = pkg;                    } else if (!pkg.equals(proxyPkg)) {                        throw new IllegalArgumentException(                            &quot;non-public interfaces from different packages&quot;);                    }                }            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (proxyPkg == null) {                // 如果全是公共代理接口，那么生成的代理类就在com.sun.proxy package下  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*             * 为代理类生成一个name  package name + 前缀+唯一编号  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 如 com.sun.proxy.$Proxy0.class             */            long num = nextUniqueNumber.getAndIncrement();            String proxyName = proxyPkg + proxyClassNamePrefix + num;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*             * 生成指定代理类的字节码文件  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(                proxyName, interfaces, accessFlags);            try {                return defineClass0(loader, proxyName,                                    proxyClassFile, 0, proxyClassFile.length);            } catch (ClassFormatError e) {                /*                 * A ClassFormatError here means that (barring bugs in the                 * proxy class generation code) there was some other                 * invalid aspect of the arguments supplied to the proxy                 * class creation (such as virtual machine limitations                 * exceeded).                 */                throw new IllegalArgumentException(e.toString());            }        }    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="字节码生成">字节码生成<a href="#字节码生成" class="hash-link" aria-label="Direct link to 字节码生成" title="Direct link to 字节码生成">​</a></h3>
<p>由上方代码byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);可以看到，其实生成代理类字节码文件的工作是通过 ProxyGenerate类中的generateProxyClass方法来完成的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) {        ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);       // 真正用来生成代理类字节码文件的方法在这里  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final byte[] var4 = var3.generateClassFile();       // 保存代理类的字节码文件  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(saveGeneratedFiles) {            AccessController.doPrivileged(new PrivilegedAction() {                public Void run() {                    try {                        int var1 = var0.lastIndexOf(46);                        Path var2;                        if(var1 &gt; 0) {                            Path var3 = Paths.get(var0.substring(0, var1).replace(&#x27;.&#x27;, File.separatorChar),                                                                                   new String[0]);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Files.createDirectories(var3, new FileAttribute[0]);                            var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);                        } else {                            var2 = Paths.get(var0 + &quot;.class&quot;, new String[0]);                        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Files.write(var2, var4, new OpenOption[0]);                        return null;                    } catch (IOException var4x) {                        throw new InternalError(&quot;I/O exception saving generated file: &quot; + var4x);                    }                }            });        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return var4;    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>下面来看看真正用于生成代理类字节码文件的generateClassFile方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private byte[] generateClassFile() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.addProxyMethod(hashCodeMethod, Object.class);        this.addProxyMethod(equalsMethod, Object.class);        this.addProxyMethod(toStringMethod, Object.class);        Class[] var1 = this.interfaces;        int var2 = var1.length;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int var3;        Class var4;       //获得接口中所有方法并添加到代理方法中  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(var3 = 0; var3 &lt; var2; ++var3) {            var4 = var1[var3];            Method[] var5 = var4.getMethods();            int var6 = var5.length;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int var7 = 0; var7 &lt; var6; ++var7) {                Method var8 = var5[var7];                this.addProxyMethod(var8, var4);            }        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator var11 = this.proxyMethods.values().iterator();        //验证具有相同方法签名的方法的返回类型是否一致  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List var12;        while(var11.hasNext()) {            var12 = (List)var11.next();            checkReturnTypes(var12);        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //后面一系列的步骤用于写代理类Class文件  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator var15;        try {             //生成代理类的构造函数  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.methods.add(this.generateConstructor());            var11 = this.proxyMethods.values().iterator();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(var11.hasNext()) {                var12 = (List)var11.next();                var15 = var12.iterator();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while(var15.hasNext()) {                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();                    //将代理类字段声明为Method，并且字段修饰符为 private static.                   //因为 10 是 ACC_PRIVATE和ACC_STATIC的与运算 故代理类的字段都是 private static Method ***                    this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName,                                   &quot;Ljava/lang/reflect/Method;&quot;, 10));  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   //生成代理类的方法  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    this.methods.add(var16.generateMethod());                }            }           //为代理类生成静态代码块对某些字段进行初始化  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.methods.add(this.generateStaticInitializer());        } catch (IOException var10) {            throw new InternalError(&quot;unexpected I/O Exception&quot;, var10);        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(this.methods.size() &gt; &#x27;\uffff&#x27;) { //代理类中的方法数量超过65535就抛异常  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;method limit exceeded&quot;);        } else if(this.fields.size() &gt; &#x27;\uffff&#x27;) {// 代理类中字段数量超过65535也抛异常  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;field limit exceeded&quot;);        } else {            // 后面是对文件进行处理的过程  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.cp.getClass(dotToSlash(this.className));            this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;);            var1 = this.interfaces;            var2 = var1.length;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(var3 = 0; var3 &lt; var2; ++var3) {                var4 = var1[var3];                this.cp.getClass(dotToSlash(var4.getName()));            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.cp.setReadOnly();            ByteArrayOutputStream var13 = new ByteArrayOutputStream();            DataOutputStream var14 = new DataOutputStream(var13);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {                var14.writeInt(-889275714);                var14.writeShort(0);                var14.writeShort(49);                this.cp.write(var14);                var14.writeShort(this.accessFlags);                var14.writeShort(this.cp.getClass(dotToSlash(this.className)));                var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;));                var14.writeShort(this.interfaces.length);                Class[] var17 = this.interfaces;                int var18 = var17.length;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for(int var19 = 0; var19 &lt; var18; ++var19) {                    Class var22 = var17[var19];                    var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));                }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                var14.writeShort(this.fields.size());                var15 = this.fields.iterator();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while(var15.hasNext()) {                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();                    var20.write(var14);                }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                var14.writeShort(this.methods.size());                var15 = this.methods.iterator();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while(var15.hasNext()) {                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();                    var21.write(var14);                }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                var14.writeShort(0);                return var13.toByteArray();            } catch (IOException var9) {                throw new InternalError(&quot;unexpected I/O Exception&quot;, var9);            }        }    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="代理类的方法调用">代理类的方法调用<a href="#代理类的方法调用" class="hash-link" aria-label="Direct link to 代理类的方法调用" title="Direct link to 代理类的方法调用">​</a></h2>
<p>下面是将接口与Object中一些方法添加到代理类中的addProxyMethod方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void addProxyMethod(Method var1, Class&lt;?&gt; var2) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String var3 = var1.getName();//获得方法名称  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class[] var4 = var1.getParameterTypes();//获得方法参数类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class var5 = var1.getReturnType();//获得方法返回类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class[] var6 = var1.getExceptionTypes();//异常类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String var7 = var3 + getParameterDescriptors(var4);//获得方法签名  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object var8 = (List)this.proxyMethods.get(var7);//根据方法前面获得proxyMethod的value  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(var8 != null) {//处理多个代理接口中方法重复的情况  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator var9 = ((List)var8).iterator();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(var9.hasNext()) {                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod)var9.next();                if(var5 == var10.returnType) {                    ArrayList var11 = new ArrayList();                    collectCompatibleTypes(var6, var10.exceptionTypes, var11);                    collectCompatibleTypes(var10.exceptionTypes, var6, var11);                    var10.exceptionTypes = new Class[var11.size()];                    var10.exceptionTypes = (Class[])var11.toArray(var10.exceptionTypes);                    return;                }            }        } else {            var8 = new ArrayList(3);            this.proxyMethods.put(var7, var8);        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ((List)var8).add(new ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2, null));    }```  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这就是最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口。我们通过  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">HelloInterface helloInterface = (HelloInterface ) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>1</li>
</ul>
<p>得到的最终代理类对象就是上面这个类的实例。那么我们执行如下语句：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">helloInterface.hello(&quot;Tom&quot;);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>1</li>
</ul>
<p>实际上就是执行上面类的相应方法，也就是：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void hello(String paramString)  {    try    {      this.h.invoke(this, m3, new Object[] { paramString });      //就是调用  我们自定义的InvocationHandlerImpl的 invoke方法：  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return;    }    catch (Error|RuntimeException localError)    {      throw localError;    }    catch (Throwable localThrowable)    {      throw new UndeclaredThrowableException(localThrowable);    }  }```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意这里的`this.h.invoke`中的h，它是类Proxy中的一个属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>protected InvocationHandler h;```</p>
<p>因为这个代理类继承了Proxy，所以也就继承了这个属性，而这个属性值就是我们定义的</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">InvocationHandler handler = new InvocationHandlerImpl(hello);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>1</li>
</ul>
<p>同时我们还发现，invoke方法的第一参数在底层调用的时候传入的是<code>this</code>，也就是最终生成的代理对象ProxySubject，这是JVM自己动态生成的，而不是我们自己定义的代理对象。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="深入理解cglib动态代理机制">深入理解CGLIB动态代理机制<a href="#深入理解cglib动态代理机制" class="hash-link" aria-label="Direct link to 深入理解CGLIB动态代理机制" title="Direct link to 深入理解CGLIB动态代理机制">​</a></h2>
<p>Cglib是什么</p>
<p>Cglib是一个强大的、高性能的代码生成包，它广泛被许多AOP框架使用，为他们提供方法的拦截。下图是我网上找到的一张Cglib与一些框架和语言的关系：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/801753-20170403122105941-1116862243.gif" alt="" class="img_kGBN"></p>
<p>对此图总结一下：</p>
<ul>
<li>最底层的是字节码Bytecode，字节码是Java为了保证“一次编译、到处运行”而产生的一种虚拟指令格式，例如iload_0、iconst_1、if_icmpne、dup等</li>
<li>位于字节码之上的是ASM，这是一种直接操作字节码的框架，应用ASM需要对Java字节码、Class结构比较熟悉</li>
<li>位于ASM之上的是CGLIB、Groovy、BeanShell，后两种并不是Java体系中的内容而是脚本语言，它们通过ASM框架生成字节码变相执行Java代码，这说明在JVM中执行程序并不一定非要写Java代码----只要你能生成Java字节码，JVM并不关心字节码的来源，当然通过Java代码生成的JVM字节码是通过编译器直接生成的，算是最“正统”的JVM字节码</li>
<li>位于CGLIB、Groovy、BeanShell之上的就是Hibernate、Spring AOP这些框架了，这一层大家都比较熟悉</li>
<li>最上层的是Applications，即具体应用，一般都是一个Web项目或者本地跑一个程序</li>
</ul>
<p>本文是基于CGLIB 3.1进行探究的</p>
<p>cglib is a powerful, high performance and quality Code Generation Library, It is used to extend JAVA classes and implements interfaces at runtime.</p>
<p>在Spring AOP中，通常会用它来生成AopProxy对象。不仅如此，在Hibernate中PO(Persistant Object 持久化对象)字节码的生成工作也要靠它来完成。</p>
<p>本文将深入探究CGLIB动态代理的实现机制，配合下面这篇文章一起食用口味更佳：<br>
<a href="https://www.jianshu.com/p/471c80a7e831" target="_blank" rel="noopener noreferrer">深入理解JDK动态代理机制</a></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="cglib动态代理示例">CGLIB动态代理示例<a href="#cglib动态代理示例" class="hash-link" aria-label="Direct link to CGLIB动态代理示例" title="Direct link to CGLIB动态代理示例">​</a></h3>
<p>下面由一个简单的示例开始我们对CGLIB动态代理的介绍：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140731697-1665999459.png" alt="" class="img_kGBN"></p>
<p>为了后续编码的顺利进行，我们需要使用Maven引入CGLIB的包</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140732067-1529903146.png" alt="" class="img_kGBN"></p>
<p>图1.1 被代理类</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140732309-293903217.png" alt="" class="img_kGBN"></p>
<p>图1.2 实现MethodInterceptor接口生成方法拦截器</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140732746-1527907182.png" alt="" class="img_kGBN"></p>
<p>图1.3 生成代理类对象并打印在代理类对象调用方法之后的执行结果</p>
<p>JDK代理要求被代理的类必须实现接口，有很强的局限性。而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="生成代理类对象">生成代理类对象<a href="#生成代理类对象" class="hash-link" aria-label="Direct link to 生成代理类对象" title="Direct link to 生成代理类对象">​</a></h3>
<p>从图1.3中我们看到，代理类对象是由Enhancer类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展，如图1.3中的为类设置Superclass。</p>
<p>创建代理对象的几个步骤:</p>
<ul>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成Class对象( 例如使用Class.forName()方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象</li>
</ul>
<p>我们来看看将代理类Class文件反编译之后的Java代码</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">package proxy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Method;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.core.ReflectUtils;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.core.Signature;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.Callback;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.Factory;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.MethodInterceptor;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import net.sf.cglib.proxy.MethodProxy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloServiceImpl$EnhancerByCGLIB$82ef2d06  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extends HelloServiceImpl  implements Factory{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean CGLIB$BOUND;  private static final ThreadLocal CGLIB$THREAD_CALLBACKS;  private static final Callback[] CGLIB$STATIC_CALLBACKS;  private MethodInterceptor CGLIB$CALLBACK_0;  private static final Method CGLIB$sayHello$0$Method;  private static final MethodProxy CGLIB$sayHello$0$Proxy;  private static final Object[] CGLIB$emptyArgs;  private static final Method CGLIB$finalize$1$Method;  private static final MethodProxy CGLIB$finalize$1$Proxy;  private static final Method CGLIB$equals$2$Method;  private static final MethodProxy CGLIB$equals$2$Proxy;  private static final Method CGLIB$toString$3$Method;  private static final MethodProxy CGLIB$toString$3$Proxy;  private static final Method CGLIB$hashCode$4$Method;  private static final MethodProxy CGLIB$hashCode$4$Proxy;  private static final Method CGLIB$clone$5$Method;  private static final MethodProxy CGLIB$clone$5$Proxy;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void CGLIB$STATICHOOK1()  {    CGLIB$THREAD_CALLBACKS = new ThreadLocal();    CGLIB$emptyArgs = new Object[0];    Class localClass1 = Class.forName(&quot;proxy.HelloServiceImpl$EnhancerByCGLIB$82ef2d06&quot;);    Class localClass2;    Method[] tmp95_92 = ReflectUtils.findMethods(new String[] { &quot;finalize&quot;, &quot;()V&quot;, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot; }, (localClass2 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());    CGLIB$finalize$1$Method = tmp95_92[0];    CGLIB$finalize$1$Proxy = MethodProxy.create(localClass2, localClass1, &quot;()V&quot;, &quot;finalize&quot;, &quot;CGLIB$finalize$1&quot;);    Method[] tmp115_95 = tmp95_92;    CGLIB$equals$2$Method = tmp115_95[1];    CGLIB$equals$2$Proxy = MethodProxy.create(localClass2, localClass1, &quot;(Ljava/lang/Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$2&quot;);    Method[] tmp135_115 = tmp115_95;    CGLIB$toString$3$Method = tmp135_115[2];    CGLIB$toString$3$Proxy = MethodProxy.create(localClass2, localClass1, &quot;()Ljava/lang/String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$3&quot;);    Method[] tmp155_135 = tmp135_115;    CGLIB$hashCode$4$Method = tmp155_135[3];    CGLIB$hashCode$4$Proxy = MethodProxy.create(localClass2, localClass1, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$4&quot;);    Method[] tmp175_155 = tmp155_135;    CGLIB$clone$5$Method = tmp175_155[4];    CGLIB$clone$5$Proxy = MethodProxy.create(localClass2, localClass1, &quot;()Ljava/lang/Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$5&quot;);    tmp175_155;    Method[] tmp223_220 = ReflectUtils.findMethods(new String[] { &quot;sayHello&quot;, &quot;()V&quot; }, (localClass2 = Class.forName(&quot;proxy.HelloServiceImpl&quot;)).getDeclaredMethods());    CGLIB$sayHello$0$Method = tmp223_220[0];    CGLIB$sayHello$0$Proxy = MethodProxy.create(localClass2, localClass1, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);    tmp223_220;    return;  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final void CGLIB$sayHello$0()  {    super.sayHello();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void sayHello()  {    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;    if (tmp4_1 == null)    {      tmp4_1;      CGLIB$BIND_CALLBACKS(this);    }    if (this.CGLIB$CALLBACK_0 != null) {      return;    }    super.sayHello();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final void CGLIB$finalize$1()    throws Throwable  {    super.finalize();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected final void finalize()    throws Throwable  {    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;    if (tmp4_1 == null)    {      tmp4_1;      CGLIB$BIND_CALLBACKS(this);    }    if (this.CGLIB$CALLBACK_0 != null) {      return;    }    super.finalize();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean CGLIB$equals$2(Object paramObject)  {    return super.equals(paramObject);  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean equals(Object paramObject)  {    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;    if (tmp4_1 == null)    {      tmp4_1;      CGLIB$BIND_CALLBACKS(this);    }    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0;    if (tmp17_14 != null)    {      Object tmp41_36 = tmp17_14.intercept(this, CGLIB$equals$2$Method, new Object[] { paramObject }, CGLIB$equals$2$Proxy);      tmp41_36;      return tmp41_36 == null ? false : ((Boolean)tmp41_36).booleanValue();    }    return super.equals(paramObject);  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final String CGLIB$toString$3()  {    return super.toString();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final String toString()  {    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;    if (tmp4_1 == null)    {      tmp4_1;      CGLIB$BIND_CALLBACKS(this);    }    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0;    if (tmp17_14 != null) {      return (String)tmp17_14.intercept(this, CGLIB$toString$3$Method, CGLIB$emptyArgs, CGLIB$toString$3$Proxy);    }    return super.toString();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int CGLIB$hashCode$4()  {    return super.hashCode();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final int hashCode()  {    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;    if (tmp4_1 == null)    {      tmp4_1;      CGLIB$BIND_CALLBACKS(this);    }    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0;    if (tmp17_14 != null)    {      Object tmp36_31 = tmp17_14.intercept(this, CGLIB$hashCode$4$Method, CGLIB$emptyArgs, CGLIB$hashCode$4$Proxy);      tmp36_31;      return tmp36_31 == null ? 0 : ((Number)tmp36_31).intValue();    }    return super.hashCode();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final Object CGLIB$clone$5()    throws CloneNotSupportedException  {    return super.clone();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected final Object clone()    throws CloneNotSupportedException  {    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;    if (tmp4_1 == null)    {      tmp4_1;      CGLIB$BIND_CALLBACKS(this);    }    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0;    if (tmp17_14 != null) {      return tmp17_14.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy);    }    return super.clone();  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static MethodProxy CGLIB$findMethodProxy(Signature paramSignature)  {    String tmp4_1 = paramSignature.toString();    switch (tmp4_1.hashCode())    {    case -1574182249:      if (tmp4_1.equals(&quot;finalize()V&quot;)) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return CGLIB$finalize$1$Proxy;      }      break;    }  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HelloServiceImpl$EnhancerByCGLIB$82ef2d06()  {    CGLIB$BIND_CALLBACKS(this);  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] paramArrayOfCallback)  {    CGLIB$THREAD_CALLBACKS.set(paramArrayOfCallback);  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] paramArrayOfCallback)  {    CGLIB$STATIC_CALLBACKS = paramArrayOfCallback;  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final void CGLIB$BIND_CALLBACKS(Object paramObject)  {    82ef2d06 local82ef2d06 = (82ef2d06)paramObject;    if (!local82ef2d06.CGLIB$BOUND)    {      local82ef2d06.CGLIB$BOUND = true;      Object tmp23_20 = CGLIB$THREAD_CALLBACKS.get();      if (tmp23_20 == null)      {        tmp23_20;        CGLIB$STATIC_CALLBACKS;      }      local82ef2d06.CGLIB$CALLBACK_0 = (// INTERNAL ERROR //</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="对委托类进行代理">对委托类进行代理<a href="#对委托类进行代理" class="hash-link" aria-label="Direct link to 对委托类进行代理" title="Direct link to 对委托类进行代理">​</a></h3>
<p>我们上面贴出了生成的代理类源码。以我们上面的例子为参考，下面我们总结一下CGLIB在进行代理的时候都进行了哪些工作呢</p>
<ul>
<li>生成的代理类HelloServiceImpl$EnhancerByCGLIB$82ef2d06继承被代理类HelloServiceImpl。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理；</li>
<li>代理类会为委托方法生成两个方法，一个是重写的sayHello方法，另一个是CGLIB$sayHello$0方法，我们可以看到它是直接调用父类的sayHello方法；</li>
<li>当执行代理对象的sayHello方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;，如果存在，则将调用MethodInterceptor中的intercept方法，如图2.1。</li>
</ul>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140733103-2101709172.png" alt="" class="img_kGBN"></p>
<p>图2.1 intercept方法</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140733381-1955520660.png" alt="" class="img_kGBN"></p>
<p>图2.2 代理类为每个委托方法都会生成两个方法</p>
<p>在intercept方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录。</p>
<p>我们从图2.1中看到，调用委托方法是通过代理方法的MethodProxy对象调用invokeSuper方法来执行的，下面我们看看invokeSuper方法中的玄机：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140733825-816756585.png" alt="" class="img_kGBN"></p>
<p>图2.3 invokeSuper方法</p>
<p>在这里好像不能直接看出代理方法的调用。没关系，我会慢慢介绍。<br>
<!-- -->我们知道，在JDK动态代理中方法的调用是通过反射来完成的。如果有对此不太了解的同学，可以看下我之前的博客----<a href="https://www.jianshu.com/p/471c80a7e831" target="_blank" rel="noopener noreferrer">深入理解JDK动态代理机制</a>。但是在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：FastClass对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用。比如下面的getIndex方法就是通过方法签名来获得方法在存储了Class信息的数组中的下标。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140734172-226519980.png" alt="" class="img_kGBN"></p>
<p>图2.4 getIndex方法</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1092007-20190825140734361-1715137603.png" alt="" class="img_kGBN"></p>
<p>图2.5 FastClassInfo类中持有两个FastClass对象的引用.png</p>
<p>以我们上面的sayHello方法为例，f1指向委托类对象，f2指向代理类对象，i1和i2分别代表着sayHello方法以及CGLIB$sayHello$0方法在对象信息数组中的下标。</p>
<p>到此为止CGLIB动态代理机制就介绍完了，下面给出三种代理方式之间对比。</p>
<table><thead><tr><th>代理方式</th><th>实现</th><th>优点</th><th>缺点</th><th>特点</th></tr></thead><tbody><tr><td>JDK静态代理</td><td>代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td><td>实现简单，容易理解</td><td>代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td><td>好像没啥特点</td></tr><tr><td>JDK动态  代理</td><td>代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td><td>不需要硬编码接口，代码复用率高</td><td>只能够代理实现了接口的委托类</td><td>底层使用反射机制进行方法的调用</td></tr><tr><td>CGLIB动态代理</td><td>代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理</td><td>可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td><td>不能对final类以及final方法进行代理</td><td>底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="微信公众号">微信公众号<a href="#微信公众号" class="hash-link" aria-label="Direct link to 微信公众号" title="Direct link to 微信公众号">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="个人公众号黄小斜">个人公众号：黄小斜<a href="#个人公众号黄小斜" class="hash-link" aria-label="Direct link to 个人公众号：黄小斜" title="Direct link to 个人公众号：黄小斜">​</a></h3>
<p>黄小斜是跨考软件工程的 985 硕士，自学 Java 两年，拿到了 BAT 等近十家大厂 offer，从技术小白成长为阿里工程师。</p>
<p>作者专注于 JAVA 后端技术栈，热衷于分享程序员干货、学习经验、求职心得和程序人生，目前黄小斜的CSDN博客有百万+访问量，知乎粉丝2W+，全网已有10W+读者。</p>
<p>黄小斜是一个斜杠青年，坚持学习和写作，相信终身学习的力量，希望和更多的程序员交朋友，一起进步和成长！</p>
<p><strong>原创电子书:</strong><br>
<!-- -->关注公众号【黄小斜】后回复【原创电子书】即可领取我原创的电子书《菜鸟程序员修炼手册：从技术小白到阿里巴巴Java工程师》</p>
<p><strong>程序员3T技术学习资源：</strong> 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 <strong>“资料”</strong> 即可免费无套路获取。</p>
<p><strong>考研复习资料：</strong><br>
<!-- -->计算机考研大礼包，都是我自己考研复习时用的一些复习资料,包括公共课和专业的复习视频，这里也推荐给大家，关注公众号后，后台回复关键字 <strong>“考研”</strong> 即可免费获取。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20190829222750556.jpg" alt="" class="img_kGBN"></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="技术公众号java技术江湖">技术公众号：Java技术江湖<a href="#技术公众号java技术江湖" class="hash-link" aria-label="Direct link to 技术公众号：Java技术江湖" title="Direct link to 技术公众号：Java技术江湖">​</a></h3>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 <strong>“Java”</strong> 即可免费无套路获取。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20190805090108984.jpg" alt="我的公众号" class="img_kGBN"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Spring全家桶/Spring源码分析/Spring源码剖析：JDK和cglib动态代理原理详解.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：AOP实现原理详解"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Spring源码剖析：AOP实现原理详解</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：Spring事务概述"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Spring源码剖析：Spring事务概述</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#java代理介绍" class="table-of-contents__link toc-highlight">Java代理介绍</a></li><li><a href="#静态代理" class="table-of-contents__link toc-highlight">静态代理</a></li><li><a href="#jdk动态代理" class="table-of-contents__link toc-highlight">JDK动态代理</a><ul><li><a href="#jdk动态代理实现原理" class="table-of-contents__link toc-highlight">JDK动态代理实  现原理</a></li><li><a href="#proxy类中的newproxyinstance" class="table-of-contents__link toc-highlight">Proxy类中的newProxyInstance</a></li><li><a href="#字节码生成" class="table-of-contents__link toc-highlight">字节码生成</a></li></ul></li><li><a href="#代理类的方法调用" class="table-of-contents__link toc-highlight">代理类的方法调用</a></li><li><a href="#深入理解cglib动态代理机制" class="table-of-contents__link toc-highlight">深入理解CGLIB动态代理机制</a><ul><li><a href="#cglib动态代理示例" class="table-of-contents__link toc-highlight">CGLIB动态代理示例</a></li><li><a href="#生成代理类对象" class="table-of-contents__link toc-highlight">生成代理类对象</a></li><li><a href="#对委托类进行代理" class="table-of-contents__link toc-highlight">对委托类进行代理</a></li></ul></li><li><a href="#微信公众号" class="table-of-contents__link toc-highlight">微信公众号</a><ul><li><a href="#个人公众号黄小斜" class="table-of-contents__link toc-highlight">个人公众号：黄小斜</a></li><li><a href="#技术公众号java技术江湖" class="table-of-contents__link toc-highlight">技术公众号：Java技术江湖</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
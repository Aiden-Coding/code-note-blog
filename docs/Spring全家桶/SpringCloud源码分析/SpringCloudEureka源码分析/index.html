<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">SpringCloudEureka源码分析 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="SpringCloudEureka源码分析 | Tommy"><meta data-rh="true" name="description" content="Eureka源码分析"><meta data-rh="true" property="og:description" content="Eureka源码分析"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">Spring</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：初探SpringIOC核心流程">Spring源码分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringBoot/给你一份SpringBoot知识清单">SpringBoot</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringBoot源码解析/SpringBoot启动流程（四）：启动IOC容器">SpringBoot源码解析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloud/SpringCloudConsul">SpringCloud</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudConfig源码分析">SpringCloud源码分析</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudConfig源码分析">SpringCloudConfig源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析">SpringCloudEureka源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudGateway源码分析">SpringCloudGateway源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析">SpringCloudHystrix源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudLoadBalancer源码分析">Spring Cloud LoadBalancer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudOpenFeign源码分析">SpringCloudOpenFeign源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudRibbon源码分析">SpringCloudRibbon源码分析</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloudAlibaba/SpringCloudAlibaba概览">SpringCloudAlibaba</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloudAlibaba源码分析/SpringCloudAlibabaNacos源码分析：服  务发现">SpringCloudAlibaba源码分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringMVC/SpringMVC常见注解">SpringMVC</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringMVC源码分析/请求执行流程（二）之执行Handler方法">SpringMVC源码分析</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">SpringCloud源码分析</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">SpringCloudEureka源码分析</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><p>Eureka源码分析</p>
<p><strong>第1章 核心流程</strong>
<strong>1.1 Eureka做了什么事</strong></p>
<p>首先我们都明白，Eureka是用在做服务注册的，而注册中心要实现什么功能呢？这个必须明确了。</p>
<ol>
<li>既然是注册中心，那首先要能保存服务的ip、port等信息吧，这是Eureka-server必须提供的基础功能。</li>
<li>当我注册上来之后，还要提供一些动态感知服务上下线的功能吧，如果一个服务上下线，Eureka-server都不知道，那这个玩意儿就一文不值了。</li>
<li>当Eureka-server端感知到服务的变化之后总得通知消费端吧，这里就牵扯到时server端主动通知client端呢还是client端自己去拉取信息呢？这个现在不知道，等会去看源码验证。</li>
<li>OK，上面的功能都实现了，Eureka基本合格了，那还有一步，既然服务的ip和端口都在Eureka-server上面，那我消费端调用服务端的时候，通信是用的OpenFeign，那OpenFeign是怎么知道调用哪个服务的？之前都是写死在application.properties里面的<code>&lt;servicename&gt;</code>.ribbon.listOfServers中，现在Eureka怎么自动写进去的呢？</li>
<li>上面4个功能基本上完成了注册中心该有的功能，那这个时候我们再来思考一下，注册中心用于微服务项目中，那注册中心也作为一个服务，它也需要做集群的，这个时候我们就要想一下，做集群怎么保证数据一致性，该基于什么理论？
上面是Eureka要实现的最核心的功能，那这些功能提供出来了，我项目怎么去调用呢？不能直接去调API吧，这多麻烦，还得去学一遍Eureka的api，完犊子了。</li>
</ol>
<p>这个时候我们就会联想到SpringBoot的自动装配和Starter组件。这两个玩意儿帮我们完成了核心bean的自动注入，底层可以直接拿到bean，然后在Starter组件中应该自动帮我们调用了API的；OK，那回过头来我发现，我的Eureka-client就是一个starter组件，嘿嘿，有点东西了。这个client端核心逻辑肯定是帮我们封装了各种bean，然后帮我们调用了核心api了。</p>
<p>这里针对Eureka的核心功能我们在做一个更简便的总结：</p>
<ol>
<li>实现注册，并存在内存中</li>
<li>动态感知服务的健康状态</li>
<li>服务的发现，及动态感知服务的变化
<strong>1.2 核心流程推导</strong>
明确了核心功能，以及如何调用的，接下来我们来大胆地推导一下核心流程图：</li>
</ol>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/f15564313c2406546821713bcaf3eb0e9ac73d.jpg" alt="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" title="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" class="img_kGBN">大体流程推导出来之后，我们再来通过源码做一个验证。</p>
<p><strong>第2章 源码分析</strong>
<strong>2.1 服务注册的入口</strong>
服务注册是在spring boot应用启动的时候发起的。具体的执行路径我们暂且不看，先回顾一下前面咱们讲过的知识。</p>
<p>我们说spring cloud是一个生态，它提供了一套标准，这套标准可以通过不同的组件来实现，其中就包含服务注册/发现、熔断、负载均衡等，在spring-cloud-common这个包中，
org.springframework.cloud.client.serviceregistry 路径下，可以看到一个服务注册的接口定 义 ServiceRegistry 。它就是定义了spring cloud中服务注册的一个接口。</p>
<p>我们看一下它的类关系图，这个接口有一个唯一的实现 EurekaServiceRegistry 。表示采用的是Eureka Server作为服务注册中心。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/49d085328febfffcbae4030dac151db2d0bfcb.jpg" alt="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" title="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源  基础软件社区" class="img_kGBN"><strong>2.1.1 注册的时机</strong>
服务注册的发起，我们可以猜测一下应该是什么时候完成？大家自要想想其实应该不难猜测到，服务的注册取决于服务是否已经启动好了。而在spring boot中，会等到spring 容器启动并且所有的配置都完成之后来进行注册。而这个动作在spring boot的启动方法中的refreshContext中完成。</p>
<p>我们观察一下finishRefresh这个方法，从名字上可以看到它是用来体现完成刷新的操作，也就是刷新完成之后要做的后置的操作。它主要做几个事情</p>
<ul>
<li>
<p>清空缓存</p>
</li>
<li>
<p>初始化一个LifecycleProcessor，在Spring启动的时候启动bean，在spring结束的时候销毁bean</p>
</li>
<li>
<p>调用LifecycleProcessor的onRefresh方法，启动实现了Lifecycle接口的bean</p>
</li>
<li>
<p>发布ContextRefreshedEvent</p>
</li>
<li>
<p>注册Bean，通过JMX进行监控和管理</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">protected void finishRefresh() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Clear context-level resource caches (such as ASM metadata from scanning).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clearResourceCaches();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Initialize lifecycle processor for this context.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initLifecycleProcessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Propagate refresh to lifecycle processor first.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getLifecycleProcessor().onRefresh();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Publish the final event.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    publishEvent(new ContextRefreshedEvent(this));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Participate in LiveBeansView MBean, if active.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LiveBeansView.registerApplicationContext(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<p>在这个方法中，我们重点关注 getLifecycleProcessor().onRefresh() ，它是调用生命周期处理器的onrefresh方法，找到SmartLifecycle接口的所有实现类并调用start方法。</p>
<p><strong>2.1.2 SmartLifeCycle</strong>
我拓展一下SmartLifeCycle这块的知识， SmartLifeCycle是一个接口，当Spring容器加载完所有的Bean并且初始化之后，会继续回调实现了SmartLifeCycle接口的类中对应的方法，比如（start）。</p>
<p>实际上我们自己也可以拓展，比如在springboot工程的main方法同级目录下，写一个测试类，实现SmartLifeCycle接口，并且通过 @Service 声明为一个bean，因为要被spring去加载，首先得是bean。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestSmartLifeCycle implements SmartLifecycle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 服务启动后执行.无需显示调用start方法.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 但是依赖isAutoStartup()返回值,只有isAutoStartup()返回true的时候,start()才会被执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;----------start-----------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 服务停止前执行方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 前提条件: isRunning()返回true才会被执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void stop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;----------stop-----------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 返回服务运行状态,影响到服务是否调用stop方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isRunning() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 是否调用start方法,需要注意</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 当前方法返回false是不会执行start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isAutoStartup() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void stop(Runnable runnable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        runnable.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 指定执行顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 当前容器如果有多个类实现了SmartLifecycle,则按此法方法返回值排序执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getPhase() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>接着，我们启动spring boot应用后，可以看到控制台输出了 start 字符串。</p>
<p>我们在DefaultLifecycleProcessor.startBeans方法上加一个debug，可以很明显的看到我们自己定义的TestSmartLifeCycle被扫描到了，并且最后会调用该bean的start方法。<img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/75b18e528ba1879148c106d9bd3fb61ab9b5bb.jpg" alt="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" title="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" class="img_kGBN">在startBeans方法中，我们可以看到它首先会获得所有实现了SmartLifeCycle的Bean，然后会循环调用实现了SmartLifeCycle的bean的start方法，代码如下。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void startBeans(boolean autoStartupOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, Lifecycle&gt; lifecycleBeans = this.getLifecycleBeans();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;Integer, DefaultLifecycleProcessor.LifecycleGroup&gt; phases = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lifecycleBeans.forEach((beanName, bean) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!autoStartupOnly || bean instanceof SmartLifecycle &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((SmartLifecycle)bean).isAutoStartup()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int phase = this.getPhase(bean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            DefaultLifecycleProcessor.LifecycleGroup group =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (DefaultLifecycleProcessor.LifecycleGroup)phases.get(phase);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (group == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                group = new DefaultLifecycleProcessor.LifecycleGroup(phase,this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                phases.put(phase, group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            group.add(beanName, bean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!phases.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Integer&gt; keys = new ArrayList(phases.keySet());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collections.sort(keys);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator var5 = keys.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(var5.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Integer key = (Integer)var5.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((DefaultLifecycleProcessor.LifecycleGroup)phases.get(key)).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.1.3 doStart</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void doStart(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, String beanName, boolean autoStartupOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Lifecycle bean = (Lifecycle)lifecycleBeans.remove(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bean != null &amp;&amp; bean != this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String[] dependenciesForBean = this.getBeanFactory().getDependenciesForBean(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String[] var6 = dependenciesForBean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int var7 = dependenciesForBean.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int var8 = 0; var8 &lt; var7; ++var8) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String dependency = var6[var8];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.doStart(lifecycleBeans, dependency, autoStartupOnly);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!bean.isRunning() &amp;&amp; (!autoStartupOnly || !(bean instanceof SmartLifecycle) || ((SmartLifecycle)bean).isAutoStartup())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.logger.isTraceEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.logger.trace(&quot;Starting bean &#x27;&quot; + beanName + &quot;&#x27; of type [&quot; + bean.getClass().getName() + &quot;]&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bean.start(); //此时 Bean的实例应该是EurekaAutoServiceRegistration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Throwable var10) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new ApplicationContextException(&quot;Failed to start bean &#x27;&quot; + beanName + &quot;&#x27;&quot;, var10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.logger.isDebugEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.logger.debug(&quot;Successfully started bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此时，bean.start()，调用的可能是
EurekaAutoServiceRegistration中的start方法，因为很显然，它实现了SmartLifeCycle接口。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class EurekaAutoServiceRegistration implements AutoServiceRegistration,SmartLifecycle, Ordered, SmartApplicationListener {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // only set the port if the nonSecurePort or securePort is 0 and this.port != 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.port.get() != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.registration.getNonSecurePort() == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.registration.setNonSecurePort(this.port.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.registration.getSecurePort() == 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.registration.isSecure()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.registration.setSecurePort(this.port.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // because of containerPortInitializer below</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!this.running.get() &amp;&amp; this.registration.getNonSecurePort() &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.serviceRegistry.register(this.registration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.context.publishEvent(new InstanceRegisteredEvent&lt;&gt;(this,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                    this.registration.getInstanceConfig()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.running.set(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在start方法中，我们可以看到
this.serviceRegistry.register 这个方法，它实际上就是发起服务注册的机制。</p>
<p>此时this.serviceRegistry的实例，应该是 EurekaServiceRegistry ， 原因是
EurekaAutoServiceRegistration的构造方法中，会有一个赋值操作，而这个构造方法是在EurekaClientAutoConfiguration 这个自动装配类中被装配和初始化的，代码如下。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnBean(AutoServiceRegistrationProperties.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnProperty(value = &quot;spring.cloud.service-registry.auto-registration.enabled&quot;, matchIfMissing = true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public EurekaAutoServiceRegistration eurekaAutoServiceRegistration(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ApplicationContext context, EurekaServiceRegistry registry,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EurekaRegistration registration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new EurekaAutoServiceRegistration(context, registry, registration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.2 服务的注册流程</strong>
接下来我们分析服务注册的流程</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class EurekaAutoServiceRegistration implements AutoServiceRegistration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SmartLifecycle, Ordered, SmartApplicationListener {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //省略...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.serviceRegistry.register(this.registration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.context.publishEvent(new InstanceRegisteredEvent&lt;&gt; this,this.registration.getInstanceConfig()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>this.serviceRegistry.register(this.registration); 方法最终会调用</p>
<p>EurekaServiceRegistry 类中的 register 方法来实现服务注册</p>
<p><strong>2.2.1 register</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void register(EurekaRegistration reg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maybeInitializeClient(reg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (log.isInfoEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;Registering application &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 + reg.getApplicationInfoManager().getInfo().getAppName()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 + &quot; with eureka with status &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 + reg.getInstanceConfig().getInitialStatus());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设置当前实例的状态，一旦这个实例的状态发生变化，只要状态不是DOWN，那么就会被监听器监听并且执行服务注册。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg.getApplicationInfoManager().setInstanceStatus(reg.getInstanceConfig().getInitialStatus());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设置健康检查的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg.getHealthCheckHandler().ifAvailable(healthCheckHandler -&gt; reg.getEurekaClient().registerHealthCheck(healthCheckHandler));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从上述代码来看，注册方法中并没有真正调用Eureka的方法去执行注册，而是仅仅设置了一个状态以及设置健康检查处理器。我们继续看一下
reg.getApplicationInfoManager().setInstanceStatus方法。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized void setInstanceStatus(InstanceStatus status) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    InstanceStatus next = instanceStatusMapper.map(status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (next == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    InstanceStatus prev = instanceInfo.setStatus(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (prev != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (StatusChangeListener listener : listeners.values()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                listener.notify(new StatusChangeEvent(prev, next));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.warn(&quot;failed to notify listener: {}&quot;, listener.getId(),e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这个方法中，它会通过监听器来发布一个状态变更事件。ok，此时listener的实例是StatusChangeListener ，也就是调用 StatusChangeListener 的notify方法。这个事件是触发一个服务状态变更，应该是有地方会监听这个事件，然后基于这个事件进行注册。</p>
<p>这个时候我们以为找到了方向，然后点击进去一看，发现它是一个接口。而且我们  发现它是静态的内部接口，还无法直接看到它的实现类。</p>
<p>依我多年源码阅读经验，于是又往回找，因为我基本上能猜测到一定是在某个地方做了初始化的工作，于是，我想找到
EurekaServiceRegistry.register方法中的 reg.getApplicationInfoManager 这个实例是什么，而且我们发现ApplicationInfoManager是来自于EurekaRegistration这个类中的属性。而EurekaRegistration又是在EurekaAutoServiceRegistration这个类中实例化的。那我在想，是不是在自动装配中做了什么东西。于是找到EurekaClientAutoConfiguration这个类，果然看到了Bean的一些自动装配，其中包含 EurekaClient 、 ApplicationInfoMangager 、 EurekaRegistration 等。</p>
<p><strong>2.2.2 EurekaClientConfiguration</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration(proxyBeanMethods = false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnMissingRefreshScope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected static class EurekaClientConfiguration {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ApplicationContext context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private AbstractDiscoveryClientOptionalArgs&lt;?&gt; optionalArgs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean(destroyMethod = &quot;shutdown&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnMissingBean(value = EurekaClient.class,search = SearchStrategy.CURRENT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EurekaClient eurekaClient(ApplicationInfoManager manager,EurekaClientConfig config) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new CloudEurekaClient(manager, config, this.optionalArgs,this.context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnMissingBean(value = ApplicationInfoManager.class,search = SearchStrategy.CURRENT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ApplicationInfoManager eurekaApplicationInfoManager(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EurekaInstanceConfig config) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InstanceInfo instanceInfo = new InstanceInfoFactory().create(config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ApplicationInfoManager(config, instanceInfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnBean(AutoServiceRegistrationProperties.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value = &quot;spring.cloud.service-registry.auto-registration.enabled&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        matchIfMissing = true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EurekaRegistration eurekaRegistration(EurekaClient eurekaClient,CloudEurekaInstanceConfig</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                 instanceConfig,ApplicationInfoManager applicationInfoManager, @Autowired(required = false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                 ObjectProvider&lt;HealthCheckHandler&gt; healthCheckHandler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return EurekaRegistration.builder(instanceConfig).with(applicationInfoManager).with(eurekaClient).with(healthCheckHandler).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>  不难发现，我们似乎看到了一个很重要的Bean在启动的时候做了自动装配，也就是CloudEurekaClient 。从名字上来看，我可以很容易的识别并猜测出它是Eureka客户端的一个工具类，用来实现和服务端的通信以及处理。这个是很多源码一贯的套路，要么在构造方法里面去做很多的初始化和一些后台执行的程序操作，要么就是通过异步事件的方式来处理。接着，我们看一下CloudEurekaClient的初始化过程，它的构造方法中会通过 super 调用父类的构造方法。也就是DiscoveryClient的构造。</p>
<p><strong>2.2.3 CloudEurekaClient</strong>
super(applicationInfoManager, config, args);调用父类的构造方法，而CloudEurekaClient的父类是DiscoveryClient.</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public CloudEurekaClient(ApplicationInfoManager applicationInfoManager,EurekaClientConfig config,AbstractDiscoveryClientOptionalArgs&lt;?&gt; args,ApplicationEventPublisher publisher) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super(applicationInfoManager, config, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.applicationInfoManager = applicationInfoManager;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.publisher = publisher;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.eurekaTransportField = ReflectionUtils.findField(DiscoveryClient.class,&quot;eurekaTransport&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ReflectionUtils.makeAccessible(this.eurekaTransportField);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.2.4 DiscoveryClient构造</strong>
我们可以看到在最终的DiscoveryClient构造方法中，有非常长的代码。其实很多代码可以不需要关心，大部分都是一些初始化工作，比如初始化了几个定时任务</p>
<ul>
<li>
<p>scheduler</p>
</li>
<li>
<p>heartbeatExecutor 心跳定时任务</p>
</li>
<li>
<p>cacheRefreshExecutor 定时去同步服务端的实例列表</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">DiscoveryClient(ApplicationInfoManager applicationInfoManager,EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,Provider&lt;BackupRegistry&gt; backupRegistryProvider,EndpointRandomizer endpointRandomizer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略部分代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  是否要从eureka server上获取服务地址信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (config.shouldFetchRegistry()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.registryStalenessMonitor = new ThresholdLevelsMetric(this,METRIC_REGISTRY_PREFIX + &quot;lastUpdateSec_&quot;, new long[]{15L, 30L, 60L, 120L, 240L,480L});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //是否要注册到eureka server上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (config.shouldRegisterWithEureka()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.heartbeatStalenessMonitor = new ThresholdLevelsMetric(this,METRIC_REGISTRATION_PREFIX + &quot;lastHeartbeatSec_&quot;, new long[]{15L, 30L, 60L,120L, 240L, 480L});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果不需要注册并且不需要更新服务地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;  // no need to setup up an network tasks and we are done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // default size of 2 - 1 each for heartbeat and cacheRefresh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler = Executors.newScheduledThreadPool(2,new ThreadFactoryBuilder()       .setNameFormat(&quot;DiscoveryClient-%d&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     .setDaemon(true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     .build());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heartbeatExecutor = new ThreadPoolExecutor(1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                   TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                   new SynchronousQueue&lt;Runnable&gt;(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                   new ThreadFactoryBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                   .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                   .setDaemon(true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                   .build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  );  // use direct handoff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cacheRefreshExecutor = new ThreadPoolExecutor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new SynchronousQueue&lt;Runnable&gt;(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new ThreadFactoryBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .setNameFormat(&quot;DiscoveryClient-CacheRefreshExecutor-%d&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .setDaemon(true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );  // use direct handoff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eurekaTransport = new EurekaTransport();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduleServerEndpointTask(eurekaTransport, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AzToRegionMapper azToRegionMapper;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (clientConfig.shouldUseDnsForFetchingServiceUrls()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            azToRegionMapper = new DNSBasedAzToRegionMapper(clientConfig);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            azToRegionMapper = new PropertyBasedAzToRegionMapper(clientConfig);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (null != remoteRegionsToFetch.get()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(&quot;,&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instanceRegionChecker = new InstanceRegionChecker(azToRegionMapper,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                          clientConfig.getRegion());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(&quot;Failed to initialize DiscoveryClient!&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果需要注册到Eureka server并且是开启了初始化的时候强制注册，则调用register()发起服务注册</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (clientConfig.shouldRegisterWithEureka() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clientConfig.shouldEnforceRegistrationAtInit()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!register() ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalStateException(&quot;Registration error at startup.Invalid server response.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable th) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.error(&quot;Registration error at startup: {}&quot;, th.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalStateException(th);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // finally, init the schedule tasks (e.g. cluster resolvers, heartbeat,instanceInfo replicator, fetch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initScheduledTasks();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<p><strong>2.2.5 initScheduledTasks</strong>
initScheduledTasks 去启动一个定时任务。</p>
<ul>
<li>如果配置了开启从注册中心刷新服务列表，则会开启cacheRefreshExecutor这个定时任务</li>
<li>如果开启了服务注册到Eureka，则通过需要做几个事情.</li>
</ul>
<ol>
<li>建立心跳检测机制</li>
</ol>
<p>通过内部类来实例化StatusChangeListener 实例状态监控接口，这个就是前面我们在分析启动过程中所看到的，调用notify的方法，实际上会在这里体现。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void initScheduledTasks() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果配置了开启从注册中心刷新服务列表，则会开启cacheRefreshExecutor这个定时任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (clientConfig.shouldFetchRegistry()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // registry cache refresh timer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int registryFetchIntervalSeconds =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.getRegistryFetchIntervalSeconds();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int expBackOffBound =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.schedule(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new TimedSupervisorTask(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;cacheRefresh&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                scheduler,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cacheRefreshExecutor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                registryFetchIntervalSeconds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                expBackOffBound,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new CacheRefreshThread()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果开启了服务注册到Eureka，则通过需要做几个事情</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (clientConfig.shouldRegisterWithEureka()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int renewalIntervalInSecs =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int expBackOffBound =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Starting heartbeat executor: &quot; + &quot;renew interval is: {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    renewalIntervalInSecs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Heartbeat timer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.schedule(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new TimedSupervisorTask(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;heartbeat&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                scheduler,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                heartbeatExecutor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                renewalIntervalInSecs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                expBackOffBound,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new HeartbeatThread()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            renewalIntervalInSecs, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // InstanceInfo replicator 初始化一个:instanceInfoReplicator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instanceInfoReplicator = new InstanceInfoReplicator(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instanceInfo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            2); // burstSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        statusChangeListener = new ApplicationInfoManager.StatusChangeListener()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public String getId() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &quot;statusChangeListener&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void notify(StatusChangeEvent statusChangeEvent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    InstanceStatus.DOWN ==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    statusChangeEvent.getPreviousStatus()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // log at warn level if DOWN was involved</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    logger.warn(&quot;Saw local status change event {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                statusChangeEvent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    logger.info(&quot;Saw local status change event {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                statusChangeEvent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                instanceInfoReplicator.onDemandUpdate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //注册实例状态变化的监听</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (clientConfig.shouldOnDemandUpdateStatusChange()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //启动一个实例信息复制器，主要就是为了开启一个定时线程，每40秒判断实例信息是否变更，如果变更了则重新注册</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationInte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                     rvalSeconds());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Not registering with Eureka server per configuration&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.2.6 onDemandUpdate</strong>
这个方法的主要作用是根据实例数据是否发生变化，来触发服务注册中心的数据。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean onDemandUpdate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //限流判断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!scheduler.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //提交一个任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            scheduler.submit(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    logger.debug(&quot;Executing on-demand update of local InstanceInfo&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //取出之前已经提交的任务，也就是在start方法中提交的更新任务，如果任务还没有执行完成，则取消之前的任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Future latestPeriodic = scheduledPeriodicRef.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (latestPeriodic != null &amp;&amp; !latestPeriodic.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        logger.debug(&quot;Canceling the latest scheduled update, it will be rescheduled at the end of on demand update&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        latestPeriodic.cancel(false);//如果此任务未完成，就立即取消</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //通过调用run方法，令任务在延时后执行，相当于周期性任务中的一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    InstanceInfoReplicator.this.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.warn(&quot;Ignoring onDemand update due to stopped scheduler&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.warn(&quot;Ignoring onDemand update due to rate limiter&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.2.7 run</strong>
run方法实际上和前面自动装配所执行的服务注册方法是一样的，也就是调用 register 方法进行服务注册，并且在finally中，每30s会定时执行一下当前的run 方法进行检查。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        discoveryClient.refreshInstanceInfo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dirtyTimestamp != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            discoveryClient.register();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Future next = scheduler.schedule(this, replicationIntervalSeconds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduledPeriodicRef.set(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.2.8 register</strong>
最终，我们终于找到服务注册的入口了，
eurekaTransport.registrationClient.register 最终调用的是 AbstractJerseyEurekaHttpClient#register(...)`， 当然大家如果自己去看代码，就会发现去调用之前有很多绕来绕去的代码，比如工厂模式、装饰器模式等。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">boolean register() throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logger.info(PREFIX + &quot;{}: registering service...&quot;, appPathIdentifier);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.warn(PREFIX + &quot;{} - registration failed {}&quot;, appPathIdentifier,e.getMessage(), e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (logger.isInfoEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(PREFIX + &quot;{} - registration status: {}&quot;, appPathIdentifier,httpResponse.getStatusCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>很显然，这里是发起了一次http请求，访问Eureka-Server的<code>apps/${APP_NAME}</code>接口，将当前服务实例的信息发送到Eureka Server进行保存。</p>
<p>至此，我们基本上已经知道Spring Cloud Eureka 是如何在启动的时候把服务信息注册到Eureka Server上的了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String urlPath = &quot;apps/&quot; + info.getAppName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ClientResponse response = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Builder resourceBuilder =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addExtraHeaders(resourceBuilder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        response = resourceBuilder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .type(MediaType.APPLICATION_JSON_TYPE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .accept(MediaType.APPLICATION_JSON)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .post(ClientResponse.class, info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (logger.isDebugEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.debug(&quot;Jersey HTTP POST {}/{} with instance {}; statusCode={}&quot;, serviceUrl, urlPath, info.getId(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         response == null ? &quot;N/A&quot; : response.getStatus());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (response != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>但是，似乎最开始的问题还没有解决，也就是Spring Boot应用在启动时，会调用start方法，最终调用
StatusChangeListener.notify 去更新服务的一个状态，并没有直接调用register方法注册。所以我们继续去看一下 statusChangeListener.notify 方法。</p>
<p><strong>2.2.9 服务总结</strong>
至此，我们知道Eureka Client发起服务注册时，有两个地方会执行服务注册的任务</p>
<ol>
<li>在Spring Boot启动时，由于自动装配机制将CloudEurekaClient注入到了容器，并且执行了构造方法，而在构造方法中有一个定时任务每40s会执行一次判断，判断实例信息是否发生了变化，如果是则会发起服务注册的流程</li>
<li>在Spring Boot启动时，通过refresh方法，最终调用StatusChangeListener.notify进行服务状态变更的监听，而这个监听的方法受到事件之后会去执行服务注册。
<strong>2.3 Server端逻辑</strong>
在没分析源码实现之前，我们一定知道它肯定对请求过来的服务实例数据进行了存储。那么我们去Eureka Server端看一下处理流程。</li>
</ol>
<p>请求入口在：
com.netflix.eureka.resources.ApplicationResource.addInstance() 。</p>
<p>大家可以发现，这里所提供的REST服务，采用的是jersey来实现的。Jersey是基于JAX-RS标准，提供REST的实现的支持，这里就不展开分析了。</p>
<p><strong>2.3.1 addInstance()</strong>
当EurekaClient调用register方法发起注册时，会调用
ApplicationResource.addInstance方法。</p>
<p>服务注册就是发送一个POST请求带上当前实例信息到类 ApplicationResource 的 addInstance方法进行服务注册。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@POST</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Consumes({&quot;application/json&quot;, &quot;application/xml&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Response addInstance(InstanceInfo info, @HeaderParam(&quot;x-netflix-discovery-replication&quot;) String isReplication) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logger.debug(&quot;Registering instance {} (replication={})&quot;, info.getId(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 isReplication);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dataCenterInfo instanceof UniqueIdentifier) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String dataCenterInfoId =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((UniqueIdentifier)dataCenterInfo).getId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.isBlank(dataCenterInfoId)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean experimental =            &quot;true&quot;.equalsIgnoreCase(this.serverConfig.getExperimental(&quot;registration.validation.dataCenterInfoId&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (experimental) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String entity = &quot;DataCenterInfo of type &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    dataCenterInfo.getClass() + &quot; must contain a valid id&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return Response.status(400).entity(entity).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataCenterInfo instanceof AmazonInfo) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                AmazonInfo amazonInfo = (AmazonInfo)dataCenterInfo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String effectiveId = amazonInfo.get(MetaDataKey.instanceId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (effectiveId == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    amazonInfo.getMetadata().put(MetaDataKey.instanceId.getName(), info.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.warn(&quot;Registering DataCenterInfo of type {} without an appropriate id&quot;, dataCenterInfo.getClass());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.registry.register(info, &quot;true&quot;.equals(isReplication));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Response.status(204).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.3.2 register</strong>
我们先来看
PeerAwareInstanceRegistryImpl的类关系图，从类关系图可以看出，PeerAwareInstanceRegistry的最顶层接口为LeaseManager与LookupService,</p>
<ul>
<li>其中LookupService定义了最基本的发现示例的行为</li>
<li>LeaseManager定义了处理客户端注册，续约，注销等操作</li>
</ul>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/897d97d444664479bda0430417ec683f1f079a.jpg" alt="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" title="SpringCloud系列—Spring Cloud 源码分析之Eureka-开源基础软件社区" class="img_kGBN">在 addInstance 方法中，最终调用的是
PeerAwareInstanceRegistryImpl.register 方法。</p>
<ul>
<li>
<p>leaseDuration 表示租约过期时间，默认是90s，也就是当服务端超过90s没有收到客户端的心跳，则主动剔除该节点</p>
</li>
<li>
<p>调用super.register发起节点注册</p>
</li>
<li>
<p>将信息复制到Eureka Server集群中的其他机器上，同步的实现也很简单，就是获得集群中的所有节点，然后逐个发起注册</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void register(final InstanceInfo info, final boolean isReplication) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt;0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        leaseDuration = info.getLeaseInfo().getDurationInSecs(); //如果客户端有自己定义心跳超时时间，则采用客户端的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super.register(info, leaseDuration, isReplication); //节点注册</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //复制到Eureka Server集群中的其他节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     null, isReplication);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<p><strong>2.3.3 AbstractInstanceRegistry.register</strong>
简单来说，Eureka-Server的服务注册，实际上是将客户端传递过来的实例数据保存到Eureka-Server中的ConcurrentHashMap中。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void register(InstanceInfo registrant, int leaseDuration, boolean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     isReplication) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        read.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //从registry中获得当前实例信息，根据appName</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            registry.get(registrant.getAppName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        REGISTER.increment(isReplication); //增加注册次数到监控信息中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (gMap == null) {//如果当前appName是第一次注册，则初始化一个ConcurrentHashMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = new</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (gMap == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                gMap = gNewMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //从gMap中查询已经存在的Lease信息，Lease中文翻译为租约，实际上它把服务提供者的实例信息包装成了一个lease，里面提供了对于改服务实例的租约管理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 当instance已经存在是，和客户端的instance的信息做比较，时间最新的那个，为有效instance信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (existingLease != null &amp;&amp; (existingLease.getHolder() != null)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Long existingLastDirtyTimestamp =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                existingLease.getHolder().getLastDirtyTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Long registrationLastDirtyTimestamp =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                registrant.getLastDirtyTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.debug(&quot;Existing lease found (existing={}, provided={}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // this is a &gt; instead of a &gt;= because if the timestamps are equal,we still take the remote transmitted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // InstanceInfo instead of the server local copy.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.warn(&quot;There is an existing lease and the existing lease&#x27;s dirty timestamp {} is greater&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            &quot; than the one that is being registered {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.warn(&quot;Using the existing instanceInfo instead of the new instanceInfo as the registrant&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                registrant = existingLease.getHolder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //当lease不存在时，进入到这段代码，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (this.expectedNumberOfClientsSendingRenews &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Since the client wants to register it, increase the number of clients sending renews</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    this.expectedNumberOfClientsSendingRenews =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        this.expectedNumberOfClientsSendingRenews + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    updateRenewsPerMinThreshold();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.debug(&quot;No previous lease information found; it is new registration&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //构建一个lease</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Lease&lt;InstanceInfo&gt; lease = new Lease&lt;InstanceInfo&gt;(registrant,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                            leaseDuration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (existingLease != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当原来存在Lease的信息时，设置serviceUpTimestamp, 保证服务启动的时间一直是第一次注册的那个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gMap.put(registrant.getId(), lease);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (recentRegisteredQueue) {//添加到最近注册的队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            recentRegisteredQueue.add(new Pair&lt;Long, String&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.currentTimeMillis(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                registrant.getAppName() + &quot;(&quot; + registrant.getId() + &quot;)&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 检查实例状态是否发生变化，如果是并且存在，则覆盖原来的状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.debug(&quot;Found overridden status {} for instance {}. Checking to see if needs to be add to the &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         + &quot;overrides&quot;, registrant.getOverriddenStatus(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         registrant.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.info(&quot;Not found overridden id {} and hence adding it&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            registrant.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                overriddenInstanceStatusMap.put(registrant.getId(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                registrant.getOverriddenStatus());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InstanceStatus overriddenStatusFromMap =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            overriddenInstanceStatusMap.get(registrant.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (overriddenStatusFromMap != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Storing overridden status {} from map&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        overriddenStatusFromMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            registrant.setOverriddenStatus(overriddenStatusFromMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set the status based on the overridden status rules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InstanceStatus overriddenInstanceStatus =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getOverriddenInstanceStatus(registrant, existingLease, isReplication);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        registrant.setStatusWithoutDirty(overriddenInstanceStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 得到instanceStatus，判断是否是UP状态，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (InstanceStatus.UP.equals(registrant.getStatus())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lease.serviceUp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置注册类型为添加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        registrant.setActionType(ActionType.ADDED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 租约变更记录队列，记录了实例的每次变化， 用于注册信息的增量获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        recentlyChangedQueue.add(new RecentlyChangedItem(lease));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        registrant.setLastUpdatedTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //让缓存失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        registrant.getSecureVipAddress());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Registered instance {}/{} with status {} (replication={})&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    registrant.getAppName(), registrant.getId(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    registrant.getStatus(), isReplication);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        read.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.3.4 小结</strong>
至此，我们就把服务注册在客户端和服务端的处理过程做了一个详细的分析，实际上在Eureka Server端，会把客户端的地址信息保存到ConcurrentHashMap中存储。并且服务提供者和注册中心之间，会建立一个心跳检测机制。用于监控服务提供者的健康状态。</p>
<p><strong>2.4 Eureka 的多级缓存设计</strong>
Eureka Server存在三个变量：(registry、readWriteCacheMap、readOnlyCacheMap)保存服务注册信息，默认情况下定时任务每30s将readWriteCacheMap同步至readOnlyCacheMap，每60s清理超过90s未续约的节点，Eureka Client每30s从readOnlyCacheMap更新服务注册信息，而客户端服务的注册则从registry更新服务注册信息。</p>
<p><strong>2.4.1 多级缓存的意义</strong>
这里为什么要设计多级缓存呢？原因很简单， 就是当存在大规模的服务注册和更新时，如果只是修改一个ConcurrentHashMap数据，那么势必因为锁的存在导致竞争，影响性能。</p>
<p>而Eureka又是AP模型，只需要满足最终可用就行。所以它在这里用到多级缓存来实现读写分离。注册方法写的时候直接写内存注册表，写完表之后主动失效读写缓存。</p>
<p>获取注册信息接口先从只读缓存取，只读缓存没有再去读写缓存取，读写缓存没有再去内存注册表里取（不只是取，此处较复杂）。并且，读写缓存会更新回写只读缓存</p>
<ul>
<li>responseCacheUpdateIntervalMs ： readOnlyCacheMap 缓存更新的定时器时间间隔，默认为30秒</li>
<li>responseCacheAutoExpirationInSeconds : readWriteCacheMap 缓存过期时间，默认为 180 秒。
<strong>2.4.2 服务注册的缓存失效</strong>
在AbstractInstanceRegistry.register方法的最后，会调用invalidateCache(registrant.getAppName(), registrant.getVIPAddress(),registrant.getSecureVipAddress()); 方法，使得读写缓存失效。</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void invalidate(Key... keys) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Key key : keys) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.debug(&quot;Invalidating the response cache key : {} {} {} {}, {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     key.getEntityType(), key.getName(), key.getVersion(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     key.getType(), key.getEurekaAccept());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readWriteCacheMap.invalidate(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collection&lt;Key&gt; keysWithRegions = regionSpecificKeys.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (null != keysWithRegions &amp;&amp; !keysWithRegions.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Key keysWithRegion : keysWithRegions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.debug(&quot;Invalidating the response cache key : {} {} {} {} {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             key.getEntityType(), key.getName(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             key.getVersion(), key.getType(), key.getEurekaAccept());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                readWriteCacheMap.invalidate(keysWithRegion);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.4.3 定时同步缓存</strong>
ResponseCacheImpl的构造方法中，会启动一个定时任务，这个任务会定时检查写缓存中的数据变化，进行更新和同步。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private TimerTask getCacheUpdateTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new TimerTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.debug(&quot;Updating the client cache from response cache&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Key key : readOnlyCacheMap.keySet()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (logger.isDebugEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    logger.debug(&quot;Updating the client cache from response cache for key : {} {} {} {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 key.getEntityType(), key.getName(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 key.getVersion(), key.getType());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    CurrentRequestVersion.set(key.getVersion());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Value cacheValue = readWriteCacheMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Value currentCacheValue = readOnlyCacheMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (cacheValue != currentCacheValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        readOnlyCacheMap.put(key, cacheValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Throwable th) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    logger.error(&quot;Error while updating the client cache from response cache for key {}&quot;, key.toStringCompact(), th);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    CurrentRequestVersion.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.5 服务续约</strong>
所谓的服务续约，其实就是一种心跳检查机制。客户端会定期发送心跳来续约。那么简单给大家看一下代码的实现</p>
<p><strong>2.5.1 initScheduledTasks</strong>
客户端会在
DiscoveryClient.initScheduledTasks 中，创建一个心跳检测的定时任务</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// Heartbeat timer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scheduler.schedule(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new TimedSupervisorTask(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;heartbeat&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heartbeatExecutor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        renewalIntervalInSecs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        expBackOffBound,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new HeartbeatThread()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    renewalIntervalInSecs, TimeUnit.SECONDS);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.5.2 HeartbeatThread</strong>
然后这个定时任务中，会执行一个 HearbeatThread 的线程，这个线程会定时调用renew()来做续约。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//每隔30s发送一个心跳请求到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private class HeartbeatThread implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (renew()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.5.3 服务端收到心跳请求的处理</strong>
在ApplicationResource.getInstanceInfo这个接口中，会返回一个InstanceResource的实例，在该实例下，定义了一个statusUpdate的接口来更新状态</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Path(&quot;{id}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public InstanceResource getInstanceInfo(@PathParam(&quot;id&quot;) String id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new InstanceResource(this, id, serverConfig, registry);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.5.4 InstanceResource.statusUpdate()</strong>
在该方法中，我们重点关注 registry.statusUpdate 这个方法，它会调用
AbstractInstanceRegistry.statusUpdate来更新指定服务提供者在服务端存储的信息中的变化。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@PUT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Path(&quot;status&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Response statusUpdate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @QueryParam(&quot;value&quot;) String newStatus,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @QueryParam(&quot;lastDirtyTimestamp&quot;) String lastDirtyTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (registry.getInstanceByAppAndId(app.getName(), id) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.warn(&quot;Instance not found: {}/{}&quot;, app.getName(), id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Response.status(Status.NOT_FOUND).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean isSuccess = registry.statusUpdate(app.getName(), id,                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  InstanceStatus.valueOf(newStatus), lastDirtyTimestamp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  &quot;true&quot;.equals(isReplication));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isSuccess) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Status updated: {} - {} - {}&quot;, app.getName(), id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        newStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Response.ok().build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.warn(&quot;Unable to update status: {} - {} - {}&quot;, app.getName(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        id, newStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Response.serverError().build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.error(&quot;Error updating instance {} for status {}&quot;, id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     newStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Response.serverError().build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.5.5 AbstractInstanceRegistry.statusUpdate</strong>
在这个方法中，会拿到应用对应的实例列表，然后调用Lease.renew()去进行心跳续约。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean statusUpdate(String appName, String id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            InstanceStatus newStatus, String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            lastDirtyTimestamp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            boolean isReplication) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        read.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新状态的次数 状态统计</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        STATUS_UPDATE.increment(isReplication);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从本地数据里面获取实  例信息，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Lease&lt;InstanceInfo&gt; lease = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (gMap != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lease = gMap.get(id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 实例不存在，则直接返回，表示失败</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (lease == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 执行一下lease的renew方法，里面主要是更新了这个instance的最后更新时间。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lease.renew();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取instance实例信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            InstanceInfo info = lease.getHolder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Lease is always created with its instance info object.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // This log statement is provided as a safeguard, in case this invariant is violated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (info == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                logger.error(&quot;Found Lease without a holder for instance id {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当instance信息不为空时，并且实例状态发生了变化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((info != null) &amp;&amp; !(info.getStatus().equals(newStatus))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果新状态是UP的状态，那么启动一下serviceUp() , 主要是更新服务的注册时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (InstanceStatus.UP.equals(newStatus)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lease.serviceUp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将instance Id 和这个状态的映射信息放入覆盖缓存MAP里面去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                overriddenInstanceStatusMap.put(id, newStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Set it for transfer of overridden status to replica on</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 设置覆盖状态到实例信息里面去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                info.setOverriddenStatus(newStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                long replicaDirtyTimestamp = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                info.setStatusWithoutDirty(newStatus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (lastDirtyTimestamp != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If the replication&#x27;s dirty timestamp is more than the existing one, just update</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // it to the replica&#x27;s.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果replicaDirtyTimestamp 的时间大于instance的getLastDirtyTimestamp() ,则更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    info.setLastDirtyTimestamp(replicaDirtyTimestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                info.setActionType(ActionType.MODIFIED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                recentlyChangedQueue.add(new RecentlyChangedItem(lease));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                info.setLastUpdatedTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //更新写缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                invalidateCache(appName, info.getVIPAddress(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                info.getSecureVipAddress());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        read.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>至此，心跳续约功能就分析完成了。</p>
<p><strong>2.6 服务发现</strong>
我们继续来研究服务的发现过程，就是客户端需要能够满足两个功能</p>
<p>在启动的时候获取指定服务提供者的地址列表
Eureka server端地址发生变化时，需要动态感知
<strong>2.6.1 DiscoveryClient构造时查询</strong>
构造方法中，如果当前的客户端默认开启了fetchRegistry，则会从eureka-server中拉取数据。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">DiscoveryClient(ApplicationInfoManager applicationInfoManager,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Provider&lt;BackupRegistry&gt; backupRegistryProvider,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EndpointRandomizer endpointRandomizer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fetchRegistryFromBackup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.2 fetchRegistry</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private boolean fetchRegistry(boolean forceFullRegistryFetch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If the delta is disabled or if it is the first time, get all</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // applications</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Applications applications = getApplications();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (clientConfig.shouldDisableDelta()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || forceFullRegistryFetch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || (applications == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || (applications.getRegisteredApplications().size() == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Disable delta property : {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        clientConfig.shouldDisableDelta());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Single vip registry refresh property : {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        clientConfig.getRegistryRefreshSingleVipAddress());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Force full registry fetch : {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        forceFullRegistryFetch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Application is null : {}&quot;, (applications == null));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Registered Applications size is zero : {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        (applications.getRegisteredApplications().size() == 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.info(&quot;Application version is -1: {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        (applications.getVersion() == -1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getAndStoreFullRegistry();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getAndUpdateDelta(applications);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        applications.setAppsHashCode(applications.getReconcileHashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logTotalInstances();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.error(PREFIX + &quot;{} - was unable to refresh its cache! status = {}&quot;, appPathIdentifier, e.getMessage(), e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tracer != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tracer.stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Notify about cache refresh before updating the instance remote status</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onCacheRefreshed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Update remote status based on refreshed data held in the cache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    updateInstanceRemoteStatus();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // registry was fetched successfully, so return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.3 定时刷新本地地址列表</strong>
任务每隔30s更新一次
在DiscoveryClient构造的时候，会初始化一些任务，这个在前面咱们分析过了。其中有一个任务动态更新本地服务地址列表，叫 cacheRefreshTask 。</p>
<p>这个任务最终执行的是CacheRefreshThread这个线程。它是一个周期性执行的任务，具体我们来看一下。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void initScheduledTasks() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (clientConfig.shouldFetchRegistry()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // registry cache refresh timer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int registryFetchIntervalSeconds =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.getRegistryFetchIntervalSeconds();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int expBackOffBound =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cacheRefreshTask = new TimedSupervisorTask(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;cacheRefresh&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            scheduler,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cacheRefreshExecutor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            registryFetchIntervalSeconds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            expBackOffBound,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new CacheRefreshThread()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.schedule(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cacheRefreshTask,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.4 TimedSupervisorTask</strong>
从整体上看，TimedSupervisorTask是固定间隔的周期性任务，一旦遇到超时就会将下一个周期的间隔时间调大， 如果连续超时，那么每次间隔时间都会增大一倍，一直到达外部参数设定的上限为止，一旦新任务不再超时，间隔时间又会自动恢复为初始值。这种设计还是值得学习的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Future future = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用Future，可以设定子线程的超时时间，这样当前线程就不用无限等待了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future = executor.submit(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threadPoolLevelGauge.set((long) executor.getActiveCount());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //指定等待子线程的最长时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future.get(timeoutMillis, TimeUnit.MILLISECONDS);  // block until done or timeout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //delay是个很有用的变量，后面会用到，这里记得每次执行任务成功都会将delay重置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay.set(timeoutMillis);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threadPoolLevelGauge.set((long) executor.getActiveCount());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } catch (TimeoutException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logger.error(&quot;task supervisor timed out&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutCounter.increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long currentDelay = delay.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //任务线程超时的时候，就把delay变量翻倍，但不会超过外部调用时设定的最大延时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long newDelay = Math.min(maxDelay, currentDelay * 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设置为最新的值，考虑到多线程，所以用了CAS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    delay.compareAndSet(currentDelay, newDelay);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } catch (RejectedExecutionException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一旦线程池的阻塞队列中放满了待处理任务，触发了拒绝策略，就会将调度器停掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (executor.isShutdown() || scheduler.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      logger.warn(&quot;task supervisor shutting down, reject the task&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      logger.error(&quot;task supervisor rejected the task&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rejectedCounter.increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一旦出现未知的异常，就停掉调度器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (executor.isShutdown() || scheduler.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      logger.warn(&quot;task supervisor shutting down, can&#x27;t accept the task&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      logger.error(&quot;task supervisor threw an exception&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throwableCounter.increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这里任务要么执行完毕，要么发生异常，都用cancel方法来清理任务；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (future != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      future.cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //只要调度器没有停止，就再指定等待时间之后在执行一次同样的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!scheduler.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //这里就是周期性任务的原因：只要没有停止调度器，就再创建一次性任务，执行时间时dealy的值，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //假设外部调用时传入的超时时间为30秒（构造方法的入参timeout），最大间隔时间为50秒(构造方法的入参expBackOffBound)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //如果最近一次任务没有超时，那么就在30秒后开始新任务，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //如果最近一次任务超时了，那么就在50秒后开始新任务（异常处理中有个乘以二的操作，乘以二后的60秒超过了最大间隔50秒）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      scheduler.schedule(this, delay.get(), TimeUnit.MILLISECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.5 refreshRegistry</strong>
这段代码主要两个逻辑</p>
<ul>
<li>
<p>判断remoteRegions是否发生了变化</p>
</li>
<li>
<p>调用fetchRegistry获取本地服务地址缓存</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@VisibleForTesting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void refreshRegistry() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean isFetchingRemoteRegionRegistries =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            isFetchingRemoteRegionRegistries();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean remoteRegionsModified = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果部署在aws环境上，会判断最后一次远程区域更新的信息和当前远程区域信息进行比较，如果不想等，则更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String latestRemoteRegions =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clientConfig.fetchRegistryForRemoteRegions();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (null != latestRemoteRegions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String currentRemoteRegions = remoteRegionsToFetch.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!latestRemoteRegions.equals(currentRemoteRegions)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //判断最后一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean success = fetchRegistry(remoteRegionsModified);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (success) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                registrySize = localRegionApps.get().size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastSuccessfulRegistryFetchTimestamp =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 省略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            logger.error(&quot;Cannot fetch registry from server&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<p><strong>2.6.6 fetchRegistry</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private boolean fetchRegistry(boolean forceFullRegistryFetch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If the delta is disabled or if it is the first time, get all</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // applications</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 取出本地缓存的服务列表信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Applications applications = getApplications();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //判断多个条件，确定是否触发全量更新，如下任一个满足都会全量更新：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //1\. 是否禁用增量更新；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //2\. 是否对某个region特别关注；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //3\. 外部调用时是否通过入参指定全量更新；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //4\. 本地还未缓存有效的服务列表信息；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (clientConfig.shouldDisableDelta()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || forceFullRegistryFetch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || (applications == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || (applications.getRegisteredApplications().size() == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            || (applications.getVersion() == -1)) //Client application does not</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            have latest library supporting delta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //调用全量更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getAndStoreFullRegistry();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //调用增量更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getAndUpdateDelta(applications);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //重新计算和设置一致性hash码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        applications.setAppsHashCode(applications.getReconcileHashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logTotalInstances(); //日志打印所有应用的所有实例数之和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.error(PREFIX + &quot;{} - was unable to refresh its cache! status = {}&quot;, appPathIdentifier, e.getMessage(), e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tracer != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tracer.stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将本地缓存更新的事件广播给所有已注册的监听器，注意该方法已被CloudEurekaClient类重写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onCacheRefreshed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Update remote status based on refreshed data held in the cache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //检查刚刚更新的缓存中，有来自Eureka server的服务列表，其中包含了当前应用的状态，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //当前实例的成员变量lastRemoteInstanceStatus，记录的是最后一次更新的当前应用状态，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //上述两种状态在updateInstanceRemoteStatus方法中作比较 ，如果不一致，就更新lastRemoteInstanceStatus，并且广播对应的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    updateInstanceRemoteStatus();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // registry was fetched successfully, so return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.7 getAndStoreFullRegistry</strong>
从eureka server端获取服务注册中心的地址信息，然后更新并设置到本地缓存 localRegionApps 。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void getAndStoreFullRegistry() throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long currentUpdateGeneration = fetchRegistryGeneration.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logger.info(&quot;Getting all instance registry info from the eureka server&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Applications apps = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EurekaHttpResponse&lt;Applications&gt; httpResponse =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clientConfig.getRegistryRefreshSingleVipAddress() == null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddre</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       ss(), remoteRegionsRef.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        apps = httpResponse.getEntity();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logger.info(&quot;The response status is {}&quot;, httpResponse.getStatusCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (apps == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.error(&quot;The application is null for some reason. Not storing this information&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                     currentUpdateGeneration + 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        localRegionApps.set(this.filterAndShuffle(apps));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.debug(&quot;Got full registry with apps hashcode {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     apps.getAppsHashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.warn(&quot;Not updating applications as another thread is updating it already&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.8 服务端查询服务地址流程</strong>
前面我们知道，客户端发起服务地址的查询有两种，一种是全量、另一种是增量。对于全量查询的请求，会调用Eureka-server的ApplicationsResource的getContainers方法。</p>
<p>而对于增量请求，会调用
ApplicationsResource.getContainerDifferential。</p>
<p><strong>2.6.9 ApplicationsResource.getContainers</strong>
接收客户端发送的获取全量注册信息请求。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@GET</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Response getContainers(@PathParam(&quot;version&quot;) String version,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              @HeaderParam(HEADER_ACCEPT) String acceptHeader,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              @HeaderParam(HEADER_ACCEPT_ENCODING) String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              acceptEncoding,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              String eurekaAccept,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              @Context UriInfo uriInfo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              @Nullable @QueryParam(&quot;regions&quot;) String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              regionsStr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isRemoteRegionRequested = null != regionsStr &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        !regionsStr.isEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String[] regions = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!isRemoteRegionRequested) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EurekaMonitors.GET_ALL.increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        regions = regionsStr.toLowerCase().split(&quot;,&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Arrays.sort(regions); // So we don&#x27;t have different caches for same regions queried in different order.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // EurekaServer无法提供服务，返回403</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!registry.shouldAllowAccess(isRemoteRegionRequested)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Response.status(Status.FORBIDDEN).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CurrentRequestVersion.set(Version.toEnum(version));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    KeyType keyType = Key.KeyType.JSON;// 设置返回数据格式，默认JSON</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String returnMediaType = MediaType.APPLICATION_JSON;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acceptHeader == null || !acceptHeader.contains(HEADER_JSON_VALUE)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果接收到的请求头部没有具体格式信息，则返回格式为XML</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        keyType = Key.KeyType.XML;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        returnMediaType = MediaType.APPLICATION_XML;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构建缓存键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Key cacheKey = new Key(Key.EntityType.Application,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           ResponseCacheImpl.ALL_APPS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           keyType, CurrentRequestVersion.get(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           EurekaAccept.fromString(eurekaAccept), regions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回不同的编码类型的数据，去缓存中取数据的方法基本一致</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Response response;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acceptEncoding != null &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        response = Response.ok(responseCache.getGZIP(cacheKey))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        response = Response.ok(responseCache.get(cacheKey))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CurrentRequestVersion.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return response;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.6.10 responseCache.getGZIP</strong>
从缓存中读取数据。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public byte[] getGZIP(Key key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Value payload = getValue(key, shouldUseReadOnlyResponseCache);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (payload == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return payload.getGzipped();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Value getValue(final Key key, boolean useReadOnlyCache) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Value payload = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (useReadOnlyCache) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Value currentPayload = readOnlyCacheMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (currentPayload != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                payload = currentPayload;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                payload = readWriteCacheMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                readOnlyCacheMap.put(key, payload);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            payload = readWriteCacheMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.error(&quot;Cannot get value for key : {}&quot;, key, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return payload;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h1>参考文章</h1>
<p><a href="https://lijunyi.xyz/docs/SpringCloud/SpringCloud.html#_2-2-x-%E5%88%86%E6%94%AF" target="_blank" rel="noopener noreferrer">https://lijunyi.xyz/docs/SpringCloud/SpringCloud.html#_2-2-x-%E5%88%86%E6%94%AF</a>
<a href="https://mp.weixin.qq.com/s/2jeovmj77O9Ux96v3A0NtA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/2jeovmj77O9Ux96v3A0NtA</a>
<a href="https://juejin.cn/post/6931922457741770760" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6931922457741770760</a>
<a href="https://github.com/D2C-Cai/herring" target="_blank" rel="noopener noreferrer">https://github.com/D2C-Cai/herring</a>
<a href="http://c.biancheng.net/springcloud" target="_blank" rel="noopener noreferrer">http://c.biancheng.net/springcloud</a>
<a href="https://github.com/macrozheng/springcloud-learning" target="_blank" rel="noopener noreferrer">https://github.com/macrozheng/springcloud-learning</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudConfig源码分析"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">SpringCloudConfig源码分析</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudGateway源码分析"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">SpringCloudGateway源码分析</div></a></nav></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">SpringCloudHystrix源码分析 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="SpringCloudHystrix源码分析 | Tommy"><meta data-rh="true" name="description" content="学习目标"><meta data-rh="true" property="og:description" content="学习目标"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">Spring</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/Spring源码分析/Spring源码剖析：初探SpringIOC核心流程">Spring源码分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringBoot/给你一份SpringBoot知识清单">SpringBoot</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringBoot源码解析/SpringBoot启动流程（四）：启动IOC容器">SpringBoot源码解析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloud/SpringCloudConsul">SpringCloud</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudConfig源码分析">SpringCloud源码分析</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudConfig源码分析">SpringCloudConfig源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudEureka源码分析">SpringCloudEureka源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudGateway源码分析">SpringCloudGateway源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析">SpringCloudHystrix源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudLoadBalancer源码分析">Spring Cloud LoadBalancer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudOpenFeign源码分析">SpringCloudOpenFeign源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudRibbon源码分析">SpringCloudRibbon源码分析</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloudAlibaba/SpringCloudAlibaba概览">SpringCloudAlibaba</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringCloudAlibaba源码分析/SpringCloudAlibabaNacos源码分析：服  务发现">SpringCloudAlibaba源码分析</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringMVC/SpringMVC常见注解">SpringMVC</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Spring全家桶/SpringMVC源码分析/请求执行流程（二）之执行Handler方法">SpringMVC源码分析</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">SpringCloud源码分析</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">SpringCloudHystrix源码分析</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><p>学习目标</p>
<ol>
<li>手写Mini版的Hystrix</li>
<li>RxJava知识梳理</li>
<li>Hystrix的核心流程分析</li>
<li>源码验证
第1章 手写Mini版
上文中已经给大家介绍过了Hystrix的核心功能和使用了，它无非就是提供了熔断、降级、隔离等功能，其中熔断和隔离是目的，降级是结果。在使用过程中其实最核心的有三个注解：@EnableHystrix、@HystrixCommand和@HystrixCollapser。可以通过注解 @HystrixCommand、或者继承 HystrixCommand 来实现降级，以及一些请求合并等操作。</li>
</ol>
<p>在正式讲解原理之前，我们首先要明确一个点，当采用 @HystrixCommand 注解来实现服务降级，在Hystrix 的内部是采用AOP的方式进行拦截处理请求的，这块内容，后面也会详细分析。我们这里就先来实现一下简易版的 Hystrix 来体会一下，主要分为以下步骤</p>
<ul>
<li>定义自己的@HystrixCommand 注解。</li>
<li>实现拦截请求的处理逻辑。</li>
<li>测试调用。
1.自定义注解</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Target({ElementType.METHOD})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public @interface MyHystrixCommand {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //默认超时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int timeout() default 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //回退方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String fallback() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>2.自定义切面类</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Aspect  //开启Aspect支持并且标记为一个切面类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class MyHystrixCommandAspect {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService= Executors.newFixedThreadPool(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //定义切点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Pointcut(value = &quot;@annotation(MyHystrixCommand)&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void pointCut(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //在切点方法外环绕执行  @Around相当于@Before和@AfterReturning功能的总和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Around(value = &quot;pointCut()&amp;&amp;@annotation(hystrixCommand)&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Object doPointCut(ProceedingJoinPoint joinPoint, MyHystrixCommand hystrixCommand) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int timeout=hystrixCommand.timeout();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Future future=executorService.submit(()-&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //执行proceed方法的作用是让目标方法执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return joinPoint.proceed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Throwable throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throwable.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object rs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //通过get的异步等待来实现超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rs=future.get(timeout, TimeUnit.MILLISECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException | ExecutionException | TimeoutException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                future.cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(StringUtils.isBlank(hystrixCommand.fallback())){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new Exception(&quot;fallback is null&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //调用fallback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rs=invokeFallback(joinPoint,hystrixCommand.fallback());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return rs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Object invokeFallback(ProceedingJoinPoint joinPoint,String fallback) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //获取被代理的方法参数和Method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MethodSignature signature=(MethodSignature)joinPoint.getSignature(); //获取代理类和被代理类的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Method method=signature.getMethod();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt;[] parameterTypes=method.getParameterTypes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //得到回调方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Method fallbackMethod=joinPoint.getTarget().getClass().getMethod(fallback,parameterTypes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                method.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //通过反射回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return fallbackMethod.invoke(joinPoint.getTarget(),joinPoint.getArgs());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>3.自定义测试</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @RestController</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class MyHystrixController {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        OrderServiceClient orderServiceClient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @MyHystrixCommand(fallback = &quot;fallback&quot;,timeout = 2000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @GetMapping(&quot;/myhystrix/get/{num}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String get(@PathVariable(&quot;num&quot;) int num){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return orderServiceClient.orderLists(num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String fallback(int num){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &quot;自定义注解方法被降级&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当请求<a href="http://localhost:8080/myhystrix/get/1%E6%97%B6%E4%BC%9A%E8%A7%A6%E5%8F%91%E9%99%8D%E7%BA%A7%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E5%BD%93num=1%E6%97%B6%E4%BC%9A%E4%BC%91%E7%9C%A03s%E3%80%82" target="_blank" rel="noopener noreferrer">http://localhost:8080/myhystrix/get/1时会触发降级，因为在服务端，当num=1时会休眠3s。</a></p>
<p>OK，这样我们就实现了一个简易版的HystrixCommand，但是我们只是实现了Hystrix的第一步，定义了一个注解和切面，但是它的底层逻辑远远没有这么简单，在讲源码之前，我们先来捋一捋RxJava是什么，因为Hystrix底层逻辑是基于响应式编程实现的。</p>
<p>第2章 RxJava体验
2.1 RxJava概述
RxJava 是一种响应式编程，来创建基于事件的异步操作库。基于事件流的链式调用、逻辑清晰简洁。</p>
<p>RxJava观察者模式的对比</p>
<ul>
<li>传统观察者是一个被观察者多过观察者，当被观察者发生改变时候及时通知所有观察者</li>
<li>RxJava是一个观察者多个被观察者，被观察者像链条一样串起来，数据在被观察者之间朝着一个方向传递，直到传递给观察者 。
其实说白了，就是在RxJava中存在2种概念，一种是被观察者，一种是观察者，当多个被观察者订阅了同一个观察者的时候，那么随着被观察者完成某个事件的时候就会去回调观察者。</li>
</ul>
<p>2.2 观察者</p>
<p>Observer</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Observer observer = new Observer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void onCompleted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;当被观察者生产Complete事件，调用该方法&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void onError(Throwable throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;对Error事件作出响应&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void onNext(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;对Next事件作出响应:&quot; + o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //Subscriber类 = RxJava 内置的一个实现了 Observer 的抽象类，对 Observer 接口进行了扩展</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Subscriber subscriber = new Subscriber() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void onCompleted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;当被观察者生产Complete事件，调用该方法&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void onError(Throwable throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;对Error事件作出响应&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void onNext(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;对Next事件作出响应:&quot; + o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Subscriber 抽象类与Observer 接口的区别</p>
<p>二者基本使用方式一致（在RxJava的subscribe过程中，Observer会先被转换成Subscriber再使用）
Subscriber抽象类对 Observer 接口进行了扩展，新增了两个方法：</p>
<ul>
<li>onStart()：在还未响应事件前调用，用于做一些初始化工作，他是在subscribe 所在的线程调用，不能切换线程，所以不能进行界面UI更新比如弹框这些。</li>
<li>unsubscribe()：用于取消订阅。在该方法被调用后，观察者将不再接收响应事件，比如在onStop方法中可以调用此方法结束订阅。调用该方法前，先使用 isUnsubscribed() 判断状态，确定被观察者Observable是否还持有观察者Subscriber的引用。
2.3 被观察者
RxJava 提供了多种方法用于 创建被观察者对象Observable，这里介绍两种</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    // 方法1：just(T...)：直接将传入的参数依次发送出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Observable observable = Observable.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将会依次调用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onNext(&quot;A&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onNext(&quot;B&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onNext(&quot;C&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onCompleted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 方法2：fromArray(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组 / Iterable 拆分成具体对象后，依次发送出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String[] words = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Observable observable = Observable.fromArray(words);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将会依次调用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onNext(&quot;A&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onNext(&quot;B&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onNext(&quot;C&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // onCompleted();</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>2.4 订阅</p>
<p>observable.subscribe(observer); //建立订阅关系</p>
<p>2.5 案例</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class RxJavaDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ReactiveX Java  响应式编程框架(android）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Java stream() java8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //观察者模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) throws ExecutionException, InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final String[] datas = new String[]{&quot;事件1&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 命令执行完的回调操作 终止命令清理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //会在Observable结束前触发回调该call方法，无论是正常还是异常终止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Action0 onComplated = new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;被观察者要结束了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //被观察者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Observable&lt;String&gt; observable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public Observable&lt;String&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Observable observable1 = Observable.from(datas);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return observable1.doOnCompleted(onComplated);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        Observable&lt;String&gt; observable = Observable.just(&quot;事件1&quot;,&quot;事件2&quot;,&quot;结束&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //观察者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Observer observer = new Observer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void onCompleted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;对Comlate事件做出响应&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void onError(Throwable throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;对Error事件作出响应&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void onNext(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;对Next事件作出响应:&quot; + o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            observable.subscribe(observer); //建立订阅关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        String s = observable.toBlocking().toFuture().get();//异步等待结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        System.out.println(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>OK，大体的指导如何使用RxJava编程了，记下来我们开始撸源码。</p>
<p>第3章 源码解析
先上官网提供的源码流程图，从图上可以看出来，其实就是先去扫描带有HystrixCommand注解的方法，然后进行切面拦截，执行切面的逻辑。这个切面定义了两个方法：execute和queue，二选一进行调用，然后进入真正的拦截逻辑。所以入口是HystrixCommand注解，而开启Hystrix是@EnableHystrix注解。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @SpringBootApplication</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableFeignClients(&quot;com.example.clients&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //@EnableDiscoveryClient //注销表示User服务不注册</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableHystrix //注解方式开启Hystrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class HystrixEclipseUserApplication {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SpringApplication.run(HystrixEclipseUserApplication.class, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>进入到@EnableHystrix注解中</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Target({ElementType.TYPE})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inherited</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableCircuitBreaker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public @interface EnableHystrix {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //最终@EnableHystrix继承了@EnableCircuitBreaker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Target(ElementType.TYPE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inherited</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Import(EnableCircuitBreakerImportSelector.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public @interface EnableCircuitBreaker {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>看到这步代码，我相信很多学过springboot的同学都很熟悉了，这里用到了Import注解，那肯定是引进来一些配置类了，然后我们再进
EnableCircuitBreakerImportSelector类中;</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Order(Ordered.LOWEST_PRECEDENCE - 100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class EnableCircuitBreakerImportSelector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    		extends SpringFactoryImportSelector&lt;EnableCircuitBreaker&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	protected boolean isEnabled() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    		return getEnvironment().getProperty(&quot;spring.cloud.circuit.breaker.enabled&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    				Boolean.class, Boolean.TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>EnableCircuitBreakerImportSelector继承了SpringFactoryImportSelector，进入SpringFactoryImportSelector类后发现是我们熟悉的代码，它实现了DeferredImportSelector接口，实现了selectImports方法，selectImports方法会从配置文件spring.factories里加载对应的类 org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker，我们来看看spring.facotries文件。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.cloud.netflix.hystrix.HystrixAutoConfiguration,\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerAutoConfiguration,\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.cloud.netflix.hystrix.ReactiveHystrixCircuitBreakerAutoConfiguration,\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.cloud.netflix.hystrix.security.HystrixSecurityAutoConfiguration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>对应EnableAutoConfiguration的这些实现类在spring启动的时候通过自动装配机制会去实例化并且注入到IoC容器中，这里我们核心关注
HystrixCircuitBreakerConfiguration类。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration(proxyBeanMethods = false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class HystrixCircuitBreakerConfiguration {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这里是核心的切面bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	@Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	public HystrixCommandAspect hystrixCommandAspect() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    		return new HystrixCommandAspect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>进入到这个切面类中会发现，这个切面主要针对了两个注解作为切入点@HystrixCommand和@HystrixCollapser，当执行这两个注解修饰的方法时，会被拦截执行
methodsAnnotatedWithHystrixCommand</p>
<p>3.1 HystrixCommandAspect</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Aspect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class HystrixCommandAspect {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final Map&lt;HystrixPointcutType, MetaHolderFactory&gt; META_HOLDER_FACTORY_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //通过静态方法将两个注解的两个工厂实例化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            META_HOLDER_FACTORY_MAP = ImmutableMap.&lt;HystrixPointcutType, MetaHolderFactory&gt;builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .put(HystrixPointcutType.COMMAND, new CommandMetaHolderFactory())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .put(HystrixPointcutType.COLLAPSER, new CollapserMetaHolderFactory())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //定义切入点注解HystrixCommand</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Pointcut(&quot;@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand)&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void hystrixCommandAnnotationPointcut() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //定义切入点注解HystrixCollapser（请求合并）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Pointcut(&quot;@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void hystrixCollapserAnnotationPointcut() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //环绕通知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Around(&quot;hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint joinPoint) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取目标方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Method method = getMethodFromTarget(joinPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Validate.notNull(method, &quot;failed to get method from joinPoint: %s&quot;, joinPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //只处理这两种注解标注的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (method.isAnnotationPresent(HystrixCommand.class) &amp;&amp; method.isAnnotationPresent(HystrixCollapser.class)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalStateException(&quot;method cannot be annotated with HystrixCommand and HystrixCollapser &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                &quot;annotations at the same time&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //根据不同的注解，选择对应的metaHolderFactory, 创建MetaHolder, MetaHolder 里面包含了所有信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //获取目标方法的的元数据，方法签名，参数等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MetaHolder metaHolder = metaHolderFactory.create(joinPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 创建处理器CommandCollapser 或 GenericCommand （同步） 或GenericObservableCommand（异步）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * GenericCommand里有很多super，最终通过HystrixCommandBuilderFactory.getInstance().create(metaHolder) 构建了一个HystrixCommandBuilder作为GenericCommad的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * new  GenericCommand 通过super到AbstractHystrixCommand，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * AbstractHystrixCommand 通过super到HystrixCommand，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * HystrixCommand最终到了AbstractCommand  一路传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 一会在AbstractCommand中分析下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //根据返回值推断执行类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //根据不同的命令类型，执行命令，返回结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //是否是响应式的（由于我们这些都是同步的会走这个逻辑）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!metaHolder.isObservable()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //execute执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    result = CommandExecutor.execute(invokable, executionType, metaHolder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    result = executeObservable(invokable, executionType, metaHolder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (HystrixBadRequestException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw e.getCause();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (HystrixRuntimeException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw hystrixRuntimeExceptionToThrowable(metaHolder, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //HystrixCommand的时候MetaHolder的创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static class CommandMetaHolderFactory extends MetaHolderFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public MetaHolder create(Object proxy, Method method, Object obj, Object[] args, final ProceedingJoinPoint joinPoint) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //获取注解HystrixCommand</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                HystrixCommand hystrixCommand = method.getAnnotation(HystrixCommand.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //根据返回结果推断任务类型，可以知道以哪种方式执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ExecutionType executionType = ExecutionType.getExecutionType(method.getReturnType());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MetaHolder.Builder builder = metaHolderBuilder(proxy, method, obj, args, joinPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (isCompileWeaving()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    builder.ajcMethod(getAjcMethodFromTarget(joinPoint));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //这里没有多少参数，最重要的一个hystrixCommand，你在注解里加了什么</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return builder.defaultCommandKey(method.getName())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .hystrixCommand(hystrixCommand)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .observableExecutionMode(hystrixCommand.observableExecutionMode())  //执行模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .executionType(executionType) //执行方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .observable(ExecutionType.OBSERVABLE == executionType)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在枚举ExecutionType类里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ExecutionType getExecutionType(Class&lt;?&gt; type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Future.class.isAssignableFrom(type)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ExecutionType.ASYNCHRONOUS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (Observable.class.isAssignableFrom(type)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ExecutionType.OBSERVABLE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ExecutionType.SYNCHRONOUS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们重点分析下同步处理，通过代码我们可以看到HystrixInvokable 是 GenericCommand，我们同步里的看下 CommandExecutor.execute(invokable, executionType, metaHolder)</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class CommandExecutor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static Object execute(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Validate.notNull(invokable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Validate.notNull(metaHolder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (executionType) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SYNCHRONOUS: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //重点看同步处理这个，先把GenericCommand 转成HystrixExecutable 再执行execute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return castToExecutable(invokable, executionType).execute();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                case ASYNCHRONOUS: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 强转成HystrixExecutable  异步执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HystrixExecutable executable = castToExecutable(invokable, executionType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果有 fallback方法，且是异步执行，则执行并返回包装结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (metaHolder.hasFallbackMethodCommand()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            &amp;&amp; ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return new FutureDecorator(executable.queue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return executable.queue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                case OBSERVABLE: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 强转成 HystrixObservable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HystrixObservable observable = castToObservable(invokable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 判断执行模式是不是急切/懒惰，来选择模式执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ? observable.observe() : observable.toObservable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new RuntimeException(&quot;unsupported execution type: &quot; + executionType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法主要用来执行命令，从代码中可以看出这里有三个执行类型，分别是同步、异步、以及响应式。其中，响应式又分为Cold Observable（observable.toObservable()） 和 HotObservable（observable.observe()）默认的executionType=SYNCHRONOUS ，同步请求。</p>
<ul>
<li>execute()：同步执行，返回一个单一的对象结果，发生错误时抛出异常。</li>
<li>queue()：异步执行，返回一个 Future 对象，包含着执行结束后返回的单一结果。</li>
<li>observe()：这个方法返回一个 Observable 对象，它代表操作的多个结果，但是已经被订阅者消费掉了。</li>
<li>toObservable()：这个方法返回一个 Observable 对象，它代表操作的多个结果，需要咱们自己手动订阅并消费掉。
类图关系如下：</li>
</ul>
<p>通过GenericCommand一层层的往上翻，最终定位到HystrixCommand有个execute()</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract class HystrixCommand&lt;R&gt; extends AbstractCommand&lt;R&gt; implements HystrixExecutable&lt;R&gt;, HystrixInvokableInfo&lt;R&gt;, HystrixObservable&lt;R&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //同步执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public R execute() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //通过queue().get()来同步执行（封装异步处理的结果）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return queue().get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw Exceptions.sneakyThrow(decomposeException(e));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       //异步执行，什么时候get()，由调用者决定，get()的时候会阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       public Future&lt;R&gt; queue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //核心处理，最终定位到了AbstractCommand里的toObservable()里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // toObservable转换为Observable,toBlocking转换为BlockingObservable, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // toFuture转换为Future,完成了Observable的创建和订阅</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();   	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Future&lt;R&gt; f = new Future&lt;R&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public R get() throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return delegate.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public R get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return delegate.get(timeout, unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }       	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //特殊处理了下，已经执行完了，get()也不会阻塞了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (f.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    f.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在上述代码中，重点来了，构建了一个
java.util.concurrent.Future ，然后调用 get的时候委派给 delegate，而 delegate来自于 toObservable().toBlocking().toFuture(); 这正是我们上面例子里面得代码。所以现在的重点应该放在 toObservable() 方法中：</p>
<p>3.2 toObservable
通过Observable定义一个被观察者，这个被观察者会被toObservable().toBlocking().toFuture() ，实际上这行代码的核心含义就是去根据一些熔断逻辑判断是执行真实的业务逻辑还是执行fallback的回调方法，然后将结果返回给Future。里面的 run() 方法就是执行正常的业务逻辑。这个方法主要做了以下几件事：</p>
<ul>
<li>创建一堆的动作，我也不知道这些动作是干啥的，不重要。</li>
<li>判断是否开启了缓存，如果开了，而且也命中了，就去缓存里面以Observable形式返回一个缓存结果</li>
<li>创建一个被观察者，这个被观察者后面会去回调真实业务逻辑或者fallback。</li>
</ul>
<p>核心逻辑是这个被观察者会去执行applyHystrixSemantics里面的动作</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Observable&lt;R&gt; toObservable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final AbstractCommand&lt;R&gt; _cmd = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 命令执行完的回调操作 终止命令清理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //会在Observable结束前触发回调该call方法，无论是正常还是异常终止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Action0 terminateCommandCleanup = new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    		...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将命令标记为已取消并存储延迟（除了标准清理）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //取消订阅时的监听会进行回调该 call方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Action0 unsubscribeCommandCleanup = new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    			...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行命令时的回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (commandState.get().equals(CommandState.UNSUBSCRIBED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 立即终止整个流程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return Observable.never();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //返回执行命令的Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return applyHystrixSemantics(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Func1&lt;R, R&gt; wrapWithAllOnNextHooks = new Func1&lt;R, R&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public R call(R r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    			...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Action0 fireOnCompletedHook = new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    			...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建Observable,设置各种处理操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 设置已启动标志, CAS保证命令只执行一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    IllegalStateException ex = new IllegalStateException(&quot;This instance can only be executed once. Please instantiate a new instance.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //TODO make a new error type for this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + &quot; command executed multiple times - this is not permitted.&quot;, ex, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 命令开始时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                commandStartTimestamp = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 打印日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (properties.requestLogEnabled().get()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // log this command execution regardless of what happened</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (currentRequestLog != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        currentRequestLog.addExecutedCommand(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 缓存开关，缓存KEY（这个是Hystrix中请求缓存功能，hystrix支持将一个请求结果缓存起来，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 下一个具有相同key的请求将直接从缓存中取出结果，减少请求开销）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final boolean requestCacheEnabled = isRequestCachingEnabled();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final String cacheKey = getCacheKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果配置允许缓存，先试图从缓存获取，默认 false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (requestCacheEnabled) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (fromCache != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        isResponseFromCache = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 声明执行命令的Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 创建Observable, applyHystrixSemantics() 来生成Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Observable&lt;R&gt; hystrixObservable =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Observable.defer(applyHystrixSemantics)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .map(wrapWithAllOnNextHooks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Observable&lt;R&gt; afterCache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // put in cache 保存请求结果到缓存中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (requestCacheEnabled &amp;&amp; cacheKey != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // wrap it for caching</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (fromCache != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // another thread beat us so we&#x27;ll use the cached value instead</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        toCache.unsubscribe();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        isResponseFromCache = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return handleRequestCacheHitAndEmitValues(fromCache, _cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // we just created an ObservableCommand so we cast and return it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        afterCache = toCache.toObservable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    afterCache = hystrixObservable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 生命周期回调设置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return afterCache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //会在Observable结束前触发回调，无论是正常还是异常终止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .doOnTerminate(terminateCommandCleanup)     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //取消订阅时的监听</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .doOnUnsubscribe(unsubscribeCommandCleanup) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //Observable正常终止时的监听</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .doOnCompleted(fireOnCompletedHook);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>接下来看看核心逻辑applyHystrixSemantics</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Observable&lt;R&gt; hystrixObservable =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Observable.defer(applyHystrixSemantics)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(wrapWithAllOnNextHooks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    final Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (commandState.get().equals(CommandState.UNSUBSCRIBED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return Observable.never();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return applyHystrixSemantics(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里传入的_cmd是一个GenericCommand，最终会执行到这个GenericCommand中的run方法。</p>
<p>circuitBreaker.allowRequest() 这个是判断是否处于熔断状态的，true表示没有处于熔断状态，正常执行，否则，调用 handleShortCircuitViaFallback 实现服务降级，最终会回调到我们自定义的fallback方法中。</p>
<p>如果当前hystrix处于未熔断状态，则</p>
<ul>
<li>getExecutionSemaphore 判断当前策略是否为信号量还是线程池，显然默认是线程池，然后再调用tryAcquire时写死了为true。</li>
</ul>
<p>调用executeCommandAndObserve。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Observable&lt;R&gt; applyHystrixSemantics(final AbstractCommand&lt;R&gt; _cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executionHook.onStart(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 是否允许请求，即断路器是否开启 ，这里也有好几种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (circuitBreaker.allowRequest()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 信号量获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final TryableSemaphore executionSemaphore = getExecutionSemaphore();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final AtomicBoolean semaphoreHasBeenReleased = new AtomicBoolean(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 信号释放回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Action0 singleSemaphoreRelease = new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (semaphoreHasBeenReleased.compareAndSet(false, true)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        executionSemaphore.release();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 异常回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Action1&lt;Throwable&gt; markExceptionThrown = new Action1&lt;Throwable&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void call(Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取信号，并返回对应的 Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 是否开启信号量资源隔离，未配置走 com.netflix.hystrix.AbstractCommand.TryableSemaphoreNoOp#tryAcquire 默认返回通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (executionSemaphore.tryAcquire()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return executeCommandAndObserve(_cmd)   // 执行命令，以下三个是回调，可以不看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .doOnError(markExceptionThrown)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .doOnTerminate(singleSemaphoreRelease)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .doOnUnsubscribe(singleSemaphoreRelease);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (RuntimeException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return Observable.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 获取信号失败则降级</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return handleSemaphoreRejectionViaFallback();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 断路器已打开，直接降级</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return handleShortCircuitViaFallback();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>先来看一下执行失败进入降级的逻辑，这里我们直接进入到 HystrixCommand#getFallbackObservable</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract class HystrixCommand&lt;R&gt; extends AbstractCommand&lt;R&gt; implements HystrixExecutable&lt;R&gt;, HystrixInvokableInfo&lt;R&gt;, HystrixObservable&lt;R&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final protected Observable&lt;R&gt; getFallbackObservable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.just(getFallback());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里的getFallback最终会回调我们自定的fallback方法。</p>
<p>回到executeCommandAndObserve，这个方法主要做了以下三件事情</p>
<ul>
<li>定 义不同的回调，doOnNext、doOnCompleted、onErrorResumeNext、doOnEach。</li>
<li>调用executeCommandWithSpecifiedIsolation。</li>
</ul>
<p>若执行命令超时特性开启，调用 Observable.lift方法实现执行命令超时功能。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    private Observable&lt;R&gt; executeCommandAndObserve(final AbstractCommand&lt;R&gt; _cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Action和Func都是定义的一个动作，Action是无返回值，Func是有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // doOnNext中的回调。即命令执行之前执行的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Action1&lt;R&gt; markEmits = new Action1&lt;R&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void call(R r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (shouldOutputOnNextEvents()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionResult = executionResult.addEvent(HystrixEventType.EMIT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (commandIsScalar()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (int) latency, executionResult.getOrderedList());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionResult = executionResult.addEvent((int) latency, HystrixEventType.SUCCESS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    circuitBreaker.markSuccess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // doOnCompleted中的回调。命令执行完毕后执行的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Action0 markOnCompleted = new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!commandIsScalar()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (int) latency, executionResult.getOrderedList());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionResult = executionResult.addEvent((int) latency, HystrixEventType.SUCCESS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    circuitBreaker.markSuccess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // onErrorResumeNext中的回调。命令执行失败后的回退逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = new Func1&lt;Throwable, Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Observable&lt;R&gt; call(Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Exception e = getExceptionFromThrowable(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                executionResult = executionResult.setExecutionException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e instanceof RejectedExecutionException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 线程调度失败回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return handleThreadPoolRejectionViaFallback(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (t instanceof HystrixTimeoutException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 超时回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return handleTimeoutViaFallback();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (t instanceof HystrixBadRequestException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // HystrixBadRequestException 异常回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return handleBadRequestByEmittingError(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (e instanceof HystrixBadRequestException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 降级处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return handleFailureViaFallback(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // doOnEach中的回调。`Observable`每发射一个数据都会执行这个回调，设置请求上下文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Action1&lt;Notification&lt;? super R&gt;&gt; setRequestContext = new Action1&lt;Notification&lt;? super R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void call(Notification&lt;? super R&gt; rNotification) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setRequestContextIfNeeded(currentRequestContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建对应的 Observable，实现 线程隔离、请求发送 等操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Observable&lt;R&gt; execution;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断 超时监控功能是否打开</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (properties.executionTimeoutEnabled().get()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // HystrixObservableTimeoutOperator  转换对应的 Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            execution = executeCommandWithSpecifiedIsolation(_cmd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .lift(new HystrixObservableTimeoutOperator&lt;R&gt;(_cmd));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            execution = executeCommandWithSpecifiedIsolation(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //设置回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return execution.doOnNext(markEmits)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .doOnCompleted(markOnCompleted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .onErrorResumeNext(handleFallback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .doOnEach(setRequestContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>3.3 executeCommandWithSpecifiedIsolation
这个方法首先是根据当前不同的资源隔离策略执行不同的逻辑，THREAD、SEMAPHORE。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Observable&lt;R&gt; executeCommandWithSpecifiedIsolation(final AbstractCommand&lt;R&gt; _cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 线程隔离, 是否开启 THREAD 资源隔离降级</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //创建一个Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionResult = executionResult.setExecutionOccurred();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(new IllegalStateException(&quot;execution attempted while in state : &quot; + commandState.get().name()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 该命令在包装线程中超时，将立即返回，并且不会增加任何计数器或其他此类逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // the command timed out in the wrapping thread so we will return immediately</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // and not increment any of the counters below or other such logic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(new RuntimeException(&quot;timed out before executing run()&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 设置线程启动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //we have not been unsubscribed, so should proceed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        HystrixCounters.incrementGlobalConcurrentThreads();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        threadPool.markThreadExecution();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // store the command that is being run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        executionResult = executionResult.setExecutedInThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            executionHook.onThreadStart(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            executionHook.onRunStart(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            executionHook.onExecutionStart(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            //返回 Observable,这个函数最终会返回一个封装了我们的run()逻辑的Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            return getUserExecutionObservable(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            return Observable.error(ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //command has already been unsubscribed, so return immediately</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(new RuntimeException(&quot;unsubscribed before executing run()&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).doOnTerminate(new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        handleThreadEnd(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).doOnUnsubscribe(new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        handleThreadEnd(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).subscribeOn(threadPool.getScheduler(new Func0&lt;Boolean&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public Boolean call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 信号量隔离</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionResult = executionResult.setExecutionOccurred();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(new IllegalStateException(&quot;execution attempted while in state : &quot; + commandState.get().name()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        executionHook.onRunStart(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        executionHook.onExecutionStart(_cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 真正的执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return getUserExecutionObservable(_cmd); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //If the above hooks throw, then use that as the result of the run method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>判断是否允许发送请求，这是基于断路器实现，如果断路器打开，则进行对应回调处理（失败或降级）。</li>
<li>如果 断路器 关闭，则进行请求，先获取信号，获取失败则处理对应回调。</li>
<li>获取成功，则由方法 executeCommandAndObserve 创建对应的 Observable 实现 线程隔离、请求发送 等操作，同时注册了对应的 生命周期回调。
3.4 getUserExecutionObservable
然后会执行 HystrixCommand#getExecutionObservable</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abstract class AbstractCommand&lt;R&gt; implements HystrixInvokableInfo&lt;R&gt;, HystrixObservable&lt;R&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Observable&lt;R&gt; getUserExecutionObservable(final AbstractCommand&lt;R&gt; _cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Observable&lt;R&gt; userObservable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                userObservable = getExecutionObservable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                userObservable = Observable.error(ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return userObservable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .lift(new ExecutionHookApplication(_cmd))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .lift(new DeprecatedOnRunHookApplication(_cmd));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract class HystrixCommand&lt;R&gt; extends AbstractCommand&lt;R&gt; implements HystrixExecutable&lt;R&gt;, HystrixInvokableInfo&lt;R&gt;, HystrixObservable&lt;R&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final protected Observable&lt;R&gt; getExecutionObservable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public Observable&lt;R&gt; call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.just(run());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return Observable.error(ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).doOnSubscribe(new Action0() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void call() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Save thread on which we get subscribed so that we can interrupt it later if needed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    executionThread.set(Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个 run() 方法在上面已经讲过了，就是真正的业务执行方法。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ThreadSafe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class GenericCommand extends AbstractHystrixCommand&lt;Object&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected Object run() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOGGER.debug(&quot;execute command: {}&quot;, getCommandKey().name());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return process(new Action() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Object execute() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return getCommandAction().execute(getExecutionType());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>最终调用到我们自己的业务逻辑。</p>
<h1>参考文章</h1>
<p><a href="https://lijunyi.xyz/docs/SpringCloud/SpringCloud.html#_2-2-x-%E5%88%86%E6%94%AF" target="_blank" rel="noopener noreferrer">https://lijunyi.xyz/docs/SpringCloud/SpringCloud.html#_2-2-x-%E5%88%86%E6%94%AF</a>
<a href="https://mp.weixin.qq.com/s/2jeovmj77O9Ux96v3A0NtA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/2jeovmj77O9Ux96v3A0NtA</a>
<a href="https://juejin.cn/post/6931922457741770760" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6931922457741770760</a>
<a href="https://github.com/D2C-Cai/herring" target="_blank" rel="noopener noreferrer">https://github.com/D2C-Cai/herring</a>
<a href="http://c.biancheng.net/springcloud" target="_blank" rel="noopener noreferrer">http://c.biancheng.net/springcloud</a>
<a href="https://github.com/macrozheng/springcloud-learning" target="_blank" rel="noopener noreferrer">https://github.com/macrozheng/springcloud-learning</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Spring全家桶/SpringCloud源码分析/SpringCloudHystrix源码分析.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudGateway源码分析"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">SpringCloudGateway源码分析</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Spring全家桶/SpringCloud源码分析/SpringCloudLoadBalancer源码分析"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Spring Cloud LoadBalancer</div></a></nav></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
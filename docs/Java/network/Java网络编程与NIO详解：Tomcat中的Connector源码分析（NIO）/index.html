<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO） | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO） | Tommy"><meta data-rh="true" name="description" content="本文转载 https://www.javadoop.com"><meta data-rh="true" property="og:description" content="本文转载 https://www.javadoop.com"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">Java网络编程与NIO详解：基于NIO的网络编程框架Netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：浅谈Linux中Selector的实现原理">Java网络编程与NIO详解：浅谈Linux中Selector的实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：浅析mmap和DirectBuffer">Java网络编程与NIO详解：浅析mmap和DirectBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：浅析NIO包中的Buffer、Channel和Selector">Java网络编程与NIO详解：浅析NIO包中的Buffer、Channel和Selector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：深度解读Tomcat中的NIO模型">Java网络编程与NIO详解：深度解读Tomcat中的NIO模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：IO模型与Java网络编程模型">Java网络编程与NIO详解：IO模型与Java网络编程模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Java非阻塞IO和异步IO">Java网络编程与NIO详解：Java非阻塞IO和异步IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：JAVA中原生的socket通信机制">Java网络编程与NIO详解：JAVA中原生的socket通信机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：JavaNIO一步步构建IO多路复用的请求模型">Java网络编程与NIO详解：JavaNIO一步步构建IO多  路复用的请求模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解">Java网络编程与NIO详解：LinuxEpoll实现原理详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）">Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络与NIO总结">Java网络与NIO总结</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">网络</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java网络编程与NIO详解：Tomcat中  的Connector源码分析（NIO）</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）</h1></header><p>本文转载 <a href="https://www.javadoop.com" target="_blank" rel="noopener noreferrer">https://www.javadoop.com</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章将同步到我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么  建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="前言">前言<a href="#前言" class="hash-link" aria-label="Direct link to 前言" title="Direct link to 前言">​</a></h2>
<p>之前写了两篇关于 NIO 的文章，第一篇介绍了 NIO 的 Channel、Buffer、Selector 使用，第二篇介绍了非阻塞 IO 和异步 IO，并展示了简单的用例。</p>
<p>本文将介绍 Tomcat 中的 NIO 使用，使大家对 Java NIO 的生产使用有更加直观的认识。</p>
<p>虽然本文的源码篇幅也不短，但是 Tomcat 的源码毕竟不像 Doug Lea 的并发源码那么“变态”，对于大部分读者来说，阅读难度比之前介绍的其他并发源码要简单一些，所以读者不要觉得有什么压力。</p>
<p>本文基于 Tomcat 当前（2018-03-20）<strong>最新版本 9.0.6</strong>。</p>
<p>先简单画一张图示意一下本文的主要内容：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230405105401.png" alt="" class="img_kGBN"></p>
<p><strong>目录</strong></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="源码环境准备">源码环境准备<a href="#源码环境准备" class="hash-link" aria-label="Direct link to 源码环境准备" title="Direct link to 源码环境准备">​</a></h2>
<p>Tomcat 9.0.6 下载地址：<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener noreferrer">https://tomcat.apache.org/download-90.cgi</a></p>
<p>由于上面下载的 tomcat 的源码并没有使用 maven 进行组织，不方便我们看源码，也不方便我们进行调试。这里我们将使用 maven 仓库中的 tomcat-embed-core，自己编写代码进行启动的方式来进行调试。</p>
<p>首先，创建一个空的 maven 工程，然后添加以下依赖。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tomcat-embed-core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;9.0.6&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>上面的依赖，只会将 tomcat-embed-core-9.0.6.jar 和 tomcat-annotations-api-9.0.6.jar 两个包引进来，对于本文来说，已经足够了，如果你需要其他功能，需要额外引用其他的依赖，如 Jasper。</p>
</blockquote>
<p>然后，使用以下启动方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) throws LifecycleException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Tomcat tomcat = new Tomcat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Connector connector = new Connector(&quot;HTTP/1.1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   connector.setPort(8080);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   tomcat.setConnector(connector);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   tomcat.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   tomcat.getServer().await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>经过以上的代码，我们的 Tomcat 就  启动起来了。</p>
<blockquote>
<p>Tomcat 中的其他接口感兴趣的读者请自行探索，如设置 webapp 目录，设置 resources 等</p>
</blockquote>
<p>这里，介绍第一个重要的概念：<strong>Connector</strong>。在 Tomcat 中，使用 Connector 来处理连接，一个 Tomcat 可以配置多个 Connector，分别用于监听不同端口，或处理不同协议。</p>
<p>在 Connector 的构造方法中，我们可以传<code>HTTP/1.1</code>或<code>AJP/1.3</code>用于指定协议，也可以传入相应的协议处理类，毕竟协议不是重点，将不同端口进来的连接对应不同处理类才是正道。典型地，我们可以指定以下几个协议处理类：</p>
<ul>
<li>org.apache.coyote.http11.Http11NioProtocol：对应非阻塞 IO</li>
<li>org.apache.coyote.http11.Http11Nio2Protocol：对应异步 IO</li>
<li>org.apache.coyote.http2.Http2Protocol：对应 http2 协议，对 http2 感兴趣的读者，赶紧看起来吧。</li>
</ul>
<p>本文的重点当然是非阻塞 IO 了，之前已经介绍过<code>异步 IO</code>的基础知识了，读者看完本文后，如果对异步 IO 的处理流程感兴趣，可以自行去分析一遍。</p>
<blockquote>
<p>如果你使用 9.0 以前的版本，Tomcat 在启动的时候是会自动配置一个 connector 的，我们可以不用显示配置。</p>
<p>9.0 版本的 Tomcat#start() 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void start() throws LifecycleException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getServer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    server.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>8.5 及之前版本的 Tomcat#start() 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void start() throws LifecycleException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getServer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自动配置一个使用非阻塞 IO 的 connector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getConnector();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    server.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="endpoint">endpoint<a href="#endpoint" class="hash-link" aria-label="Direct link to endpoint" title="Direct link to endpoint">​</a></h2>
<p>前面我们说过一个 Connector 对应一个协议，当然这描述也不太对，NIO 和 NIO2 就都是处理 HTTP/1.1 的，只不过一个使用非阻塞，一个使用异步。进到指定 protocol 代码，我们就会发现，它们的代码及其简单，只不过是指定了特定的<strong>endpoint</strong>。</p>
<p>打开<code>Http11NioProtocol</code>和<code>Http11Nio2Protocol</code>源码，我们可以看到，在构造方法中，它们分别指定了 NioEndpoint 和 Nio2Endpoint。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 非阻塞模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Http11NioProtocol extends AbstractHttp11JsseProtocol&lt;NioChannel&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Http11NioProtocol() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // NioEndpoint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(new NioEndpoint());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 异步模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol&lt;Nio2Channel&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Http11Nio2Protocol() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Nio2Endpoint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(new Nio2Endpoint());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里介绍第二个重要的概念：<strong>endpoint</strong>。Tomcat 使用不同的 endpoint   来处理不同的协议请求，今天我们的重点是<strong>NioEndpoint</strong>，其使用<strong>非阻塞 IO</strong>来进行处理 HTTP/1.1 协议的请求。</p>
<p><strong>NioEndpoint</strong>继承 =&gt;<strong>AbstractJsseEndpoint</strong>继承 =&gt;<strong>AbstractEndpoint</strong>。中间的 AbstractJsseEndpoint 主要是提供了一些关于<code>HTTPS</code>的方法，这块我们暂时忽略它，后面所有关于 HTTPS 的我们都直接忽略，感兴趣的读者请自行分析。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="init-过程分析">init 过程分析<a href="#init-过程分析" class="hash-link" aria-label="Direct link to init 过程分析" title="Direct link to init 过程分析">​</a></h2>
<p>下面，我们看看从 tomcat.start() 一直到 NioEndpoint 的过程。</p>
<p><strong>1. AbstractProtocol</strong>#<strong>init</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void init() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String endpointName = getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    endpoint.setName(endpointName.substring(1, endpointName.length()-1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    endpoint.setDomain(domain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // endpoint   的 name=http-nio-8089,domain=Tomcat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    endpoint.init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2. AbstractEndpoint</strong>#<strong>init</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void init() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bindOnInit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bind(); // 这里对应的当然是子类 NioEndpoint 的 bind() 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bindState = BindState.BOUND_ON_INIT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>3. NioEndpoint</strong>#<strong>bind</strong></p>
<p>这里就到我们的 NioEndpoint 了，要使用到我们之前学习的 NIO 的知识了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void bind() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // initServerSocket(); 原代码是这行，我们 “内联” 过来一起说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 开启 ServerSocketChannel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverSock = ServerSocketChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    socketProperties.setProperties(serverSock.socket());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // getPort() 会返回我们最开始设置的 8080，得到我们的 address 是 0.0.0.0:8080</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ServerSocketChannel 绑定地址、端口，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第二个参数 backlog 默认为 100，超过 100 的时候，新连接会被拒绝(不过源码注释也说了，这个值的真实语义取决于具体实现)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverSock.socket().bind(addr,getAcceptCount());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ※※※ 设置 ServerSocketChannel 为阻塞模式 ※※※</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverSock.configureBlocking(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置 acceptor 和 poller 的数量，至于它们是什么角色，待会说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // acceptorThreadCount 默认为 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acceptorThreadCount == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // FIXME: Doesn&#x27;t seem to work that well with multiple accept threads</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 作者想表达的意思应该是：使用多个 acceptor 线程并不见得性能会更好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acceptorThreadCount = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // poller 线程数，默认值定义如下，所以在多核模式下，默认为 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // pollerThreadCount = Math.min(2,Runtime.getRuntime().availableProcessors());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (pollerThreadCount &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pollerThreadCount = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setStopLatch(new CountDownLatch(pollerThreadCount));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 初始化 ssl，我们忽略 ssl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initialiseSsl();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打开 NioSelectorPool，先忽略它</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    selectorPool.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ol>
<li>ServerSocketChannel 已经打开，并且绑定要了之前指定的 8080 端口，设置成了<strong>阻塞模式</strong>。</li>
<li>设置了 acceptor 的线程数为 1</li>
<li>设置了 poller 的线程数，单核 CPU 为 1，多核为 2</li>
<li>打开了一个 SelectorPool，我们先忽略这个</li>
</ol>
<p>到这里，我们还不知道 Acceptor 和 Poller 是什么东西，我们只是设置了它们的数量，我们先来看看最后面提到的 SelectorPool。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="start-过程分析">start 过程分析<a href="#start-过程分析" class="hash-link" aria-label="Direct link to start 过程分析" title="Direct link to start 过程分析">​</a></h2>
<p>刚刚我们分析完了 init()  过程，下面是启动过程 start() 分析。</p>
<p>AbstractProtocol # start</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void start() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用 endpoint 的 start 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    endpoint.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Start async timeout thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncTimeout = new AsyncTimeout();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread timeoutThread = new Thread(asyncTimeout, getNameInternal() + &quot;-AsyncTimeout&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int priority = endpoint.getThreadPriority();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        priority = Thread.NORM_PRIORITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutThread.setPriority(priority);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutThread.setDaemon(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutThread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>AbstractEndpoint # start</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void start() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 按照我们的流程，刚刚 init 的时候，已经把 bindState 改为 BindState.BOUND_ON_INIT 了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 所以下面的 if 分支我们就不进去了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bindState == BindState.UNBOUND) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bind();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bindState = BindState.BOUND_ON_START;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 往里看 NioEndpoint 的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startInternal();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>下面这个方法还是比较重要的，这里会创建前面说过的 acceptor 和 poller。</p>
<p>NioEndpoint # startInternal</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void startInternal() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!running) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        running = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        paused = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 以下几个是缓存用的，之后我们也会看到很多这样的代码，为了减少 new 很多对象出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        processorCache = new SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socketProperties.getProcessorCache());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventCache = new SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        socketProperties.getEventCache());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nioChannels = new SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socketProperties.getBufferPool());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建【工作线程池】，Tomcat 自己包装了一下 ThreadPoolExecutor，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. 为了在创建线程池以后，先启动 corePoolSize 个线程(这个属于线程池的知识了，不熟悉的读者可以看看我之前的文章)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. 自己管理线程池的增长方式（默认 corePoolSize 10, maxPoolSize 200），不是本文重点，不分析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ( getExecutor() == null ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            createExecutor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置一个栅栏（tomcat 自定义了类 LimitLatch），控制最大的连接数，默认是 10000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initializeConnectionLatch();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开启 poller 线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 还记得之前 init 的时候，默认地设置了 poller 的数量为 2，所以这里启动 2 个 poller 线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pollers = new Poller[getPollerThreadCount()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i=0; i&lt;pollers.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pollers[i] = new Poller();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread pollerThread = new Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pollerThread.setPriority(threadPriority);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pollerThread.setDaemon(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pollerThread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开启 acceptor 线程，和开启 poller 线程组差不多。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // init 的时候，默认地，acceptor 的线程数是 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        startAcceptorThreads();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到这里，我们启动了<strong>工作线程池</strong>、<strong>poller 线程组</strong>、<strong>acceptor 线程组</strong>。同时，工作线程池初始就已经启动了 10 个线程。我们用<strong>jconsole</strong>来看看此时的线程，请看下图：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230405105500.png" alt="" class="img_kGBN"></p>
<p>从 jconsole 中，我们可以看到，此时启动了 BlockPoller、worker、poller、acceptor、AsyncTimeout，大家应该都已经清楚了每个线程是哪里启动的吧。</p>
<blockquote>
<p>Tomcat 中并没有 Worker 这个类，此名字是我瞎编。</p>
</blockquote>
<p>此时，我们还是不知道 acceptor、poller 甚至 worker 到底是干嘛的，下面，我们从 acceptor 线程开始看起。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="acceptor">Acceptor<a href="#acceptor" class="hash-link" aria-label="Direct link to Acceptor" title="Direct link to Acceptor">​</a></h2>
<p>它的结构非常简单，在构造函数中，已经把 endpoint 传进来了，此外就只有 threadName 和 state 两个简单的属性。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final AbstractEndpoint&lt;?,U&gt; endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private String threadName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected volatile AcceptorState state = AcceptorState.NEW;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Acceptor(AbstractEndpoint&lt;?,U&gt; endpoint) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.endpoint = endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>threadName</strong>就是一个线程名字而已，Acceptor 的状态<strong>state</strong>主要是随着 endpoint 来的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public enum AcceptorState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NEW, RUNNING, PAUSED, ENDED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们直接来看 acceptor 的 run 方法吧：</p>
<p>Acceptor # run</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int errorDelay = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只要 endpoint 处于 running，这里就一直循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (endpoint.isRunning()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果 endpoint 处于 pause 状态，这边 Acceptor 用一个 while 循环将自己也挂起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            state = AcceptorState.PAUSED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(50);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Ignore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // endpoint 结束了，Acceptor 自然也要结束嘛</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!endpoint.isRunning()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        state = AcceptorState.RUNNING;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果此时达到了最大连接数(之前我们说过，默认是10000)，就等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            endpoint.countUpOrAwaitConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Endpoint might have been paused while waiting for latch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // If that is the case, don&#x27;t accept new connections</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (endpoint.isPaused()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            U socket = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里就是接收下一个进来的 SocketChannel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 之前我们设置了 ServerSocketChannel 为阻塞模式，所以这边的 accept 是阻塞的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socket = endpoint.serverSocketAccept();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception ioe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // We didn&#x27;t get a socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                endpoint.countDownConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (endpoint.isRunning()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Introduce delay if necessary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    errorDelay = handleExceptionWithDelay(errorDelay);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // re-throw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw ioe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // accept 成功，将 errorDelay 设置为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            errorDelay = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // setSocketOptions() 是这里的关键方法，也就是说前面千辛万苦都是为了能到这里进行处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!endpoint.setSocketOptions(socket)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果上面的方法返回 false，关闭 SocketChannel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    endpoint.closeSocket(socket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 由于 endpoint 不 running 了，或者处于 pause 了，将此 SocketChannel 关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                endpoint.destroySocket(socket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ExceptionUtils.handleThrowable(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String msg = sm.getString(&quot;endpoint.accept.fail&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // APR specific.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Could push this down but not sure it is worth the trouble.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (t instanceof Error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Error e = (Error) t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.getError() == 233) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Not an error on HP-UX so log as a warning</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // so it can be filtered out on that platform</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // See bug 50273</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.warn(msg, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.error(msg, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.error(msg, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state = AcceptorState.ENDED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>大家应该发现了，Acceptor 绕来绕去，都是在调用 NioEndpoint 的方法，我们简单分析一下这个。</p>
<p>在 NioEndpoint init 的时候，我们开启了一个 ServerSocketChannel，后来 start 的时候，我们开启多个 acceptor（实际上，默认是 1 个），每个 acceptor 启动以后就开始循环调用 ServerSocketChannel 的 accept() 方法获取新的连接，然后调用 endpoint.setSocketOptions(socket) 处理新的连接，之后再进入循环 accept 下一个连接。</p>
<p>到这里，大家应该也就知道了，为什么这个叫 acceptor 了吧？接下来，我们来看看 setSocketOptions 方法到底做了什么。</p>
<p>NioEndpoint # setSocketOptions</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected boolean setSocketOptions(SocketChannel socket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置该 SocketChannel 为非阻塞模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Socket sock = socket.socket();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置 socket 的一些属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socketProperties.setProperties(sock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 还记得 startInternal 的时候，说过了 nioChannels 是缓存用的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 限于篇幅，这里的 NioChannel 就不展开了，它包括了 socket 和 buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        NioChannel channel = nioChannels.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (channel == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 主要是创建读和写的两个 buffer，默认地，读和写 buffer 都是 8192 字节，8k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SocketBufferHandler bufhandler = new SocketBufferHandler(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketProperties.getAppReadBufSize(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketProperties.getAppWriteBufSize(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketProperties.getDirectBuffer());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (isSSLEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel = new SecureNioChannel(socket, bufhandler, selectorPool, this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel = new NioChannel(socket, bufhandler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            channel.setIOChannel(socket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            channel.reset();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // getPoller0() 会选取所有 poller 中的一个 poller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        getPoller0().register(channel);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExceptionUtils.handleThrowable(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;&quot;,t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable tt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ExceptionUtils.handleThrowable(tt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Tell to close the socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们看到，这里又没有进行实际的处理，而是将这个 SocketChannel<strong>注册</strong>到了其中一个 poller 上。因为我们知道，acceptor 应该尽可能的简单，只做 accept 的工作，简单处理下就往后面扔。acceptor 还得回到之前的循环去 accept 新的连接呢。</p>
<p>我们只需要明白，此时，往 poller 中注册了一个 NioChannel 实例，此实例包含客户端过来的 SocketChannel 和一个 SocketBufferHandler 实例。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="poller">Poller<a href="#poller" class="hash-link" aria-label="Direct link to Poller" title="Direct link to Poller">​</a></h2>
<p>之前我们看到 acceptor 将一个 NioChannel 实例 register   到了一个 poller 中。在看 register 方法之前，我们需要先对 poller 要有个简单的认识。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Poller implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Poller() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 每个 poller 开启一个 Selector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.selector = Selector.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Selector selector;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // events 队列，此类的核心</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final SynchronizedQueue&lt;PollerEvent&gt; events =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new SynchronizedQueue&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean close = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long nextExpiration = 0;//optimize expiration handling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个值后面有用，记住它的初始值为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private AtomicLong wakeupCounter = new AtomicLong(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile int keyCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>敲重点：每个 poller 关联了一个 Selector。</p>
</blockquote>
<p>Poller 内部围着一个 events 队列转，来看看其 events() 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean events() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean result = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PollerEvent pe = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != null; i++ ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 逐个执行 event.run()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pe.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 该 PollerEvent 还得给以后用，这里 reset 一下(还是之前说过的缓存)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pe.reset();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (running &amp;&amp; !paused) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                eventCache.push(pe);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch ( Throwable x ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;&quot;,x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>events() 方法比较简单，就是取出当前队列中的 PollerEvent 对象，逐个执行 event.run() 方法。</p>
<p>然后，现在来看 Poller 的 run() 方法，该方法会一直循环，直到 poller.destroy() 被调用。</p>
<p>Poller # run</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean hasEvents = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!close) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行 events 队列中每个 event 的 run() 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                hasEvents = events();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // wakeupCounter 的初始值为 0，这里设置为 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (wakeupCounter.getAndSet(-1) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //if we are here, means we have other stuff to do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //do a non blocking select</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    keyCount = selector.selectNow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // timeout 默认值 1 秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    keyCount = selector.select(selectorTimeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wakeupCounter.set(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 篇幅所限，我们就不说 close 的情况了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (close) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                events();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                timeout(0, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    selector.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (IOException ioe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.error(sm.getString(&quot;endpoint.nio.selectorCloseFail&quot;), ioe);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ExceptionUtils.handleThrowable(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;&quot;,x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //either we timed out or we woke up, process events first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里没什么好说的，顶多就再执行一次 events() 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ( keyCount == 0 ) hasEvents = (hasEvents | events());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果刚刚 select 有返回 ready keys，进行处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator&lt;SelectionKey&gt; iterator =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Walk through the collection of ready keys and dispatch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // any active event.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (iterator != null &amp;&amp; iterator.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SelectionKey sk = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Attachment may be null if another thread has called</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // cancelledKey()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (attachment == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                iterator.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                iterator.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // ※※※※※ 处理 ready key ※※※※※</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                processKey(sk, attachment);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }//while</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //process timeouts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeout(keyCount,hasEvents);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }//while</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getStopLatch().countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>poller 的 run() 方法主要做了调用 events() 方法和处理注册到 Selector 上的 ready key，这里我们暂时不展开 processKey 方法，因为此方法必定是及其复杂的。</p>
<p>我们回过头来看之前从 acceptor 线程中调用的 register 方法。</p>
<p>Poller # register</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void register(final NioChannel socket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    socket.setPoller(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NioSocketWrapper ka = new NioSocketWrapper(socket, NioEndpoint.this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    socket.setSocketWrapper(ka);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ka.setPoller(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ka.setReadTimeout(getConnectionTimeout());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ka.setWriteTimeout(getConnectionTimeout());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ka.setSecure(isSSLEnabled());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PollerEvent r = eventCache.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ka.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注意第三个参数值 OP_REGISTER</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else r.reset(socket,ka,OP_REGISTER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加 event 到 poller 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addEvent(r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里将这个 socket（包含 socket 和 buffer 的 NioChannel 实例） 包装为一个 PollerEvent，然后添加到 events 中，此时调用此方法的 acceptor 结束返回，去处理新的 accepted 连接了。</p>
<p>接下来，我们已经知道了，poller 线程在循环过程中会不断调用 events() 方法，那么 PollerEvent 的 run() 方法很快就会被执行，我们就来看看刚刚这个新的连接被<strong>注册</strong>到这个 poller 后，会发生什么。</p>
<p>PollerEvent # run</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于新来的连接，前面我们说过，interestOps == OP_REGISTER</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (interestOps == OP_REGISTER) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这步很关键！！！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将这个新连接 SocketChannel 注册到该 poller 的 Selector 中，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 设置监听 OP_READ 事件，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将 socketWrapper 设置为 attachment 进行传递(这个对象可是什么鬼都有，往上看就知道了)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            socket.getIOChannel().register(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(sm.getString(&quot;endpoint.nio.registerFail&quot;), x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* else 这块不介绍，省得大家头大 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (key == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // The key was cancelled (e.g. due to socket closure)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // and removed from the selector while it was being</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // processed. Count down the connections at this point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // since it won&#x27;t have been counted down when the socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // closed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socket.socketWrapper.getEndpoint().countDownConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (socketWrapper != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //we are registering the key to start with, reset the fairness counter.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int ops = key.interestOps() | interestOps;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketWrapper.interestOps(ops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    key.interestOps(ops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socket.getPoller().cancelledKey(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (CancelledKeyException ckx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socket.getPoller().cancelledKey(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception ignore) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到这里，我们再回顾一下：刚刚在 PollerEvent 的 run() 方法中，我们看到，新的 SocketChannel 注册到了 Poller 内部的 Selector 中，监听 OP_READ 事件，然后我们再回到 Poller 的 run() 看下，一旦该 SocketChannel 是 readable 的状态，那么就会进入到 poller 的 processKey 方法。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="processkey">processKey<a href="#processkey" class="hash-link" aria-label="Direct link to processKey" title="Direct link to processKey">​</a></h2>
<p>Poller # processKey</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">protected void processKey(SelectionKey sk, NioSocketWrapper attachment) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ( close ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelledKey(sk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if ( sk.isValid() &amp;&amp; attachment != null ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sk.isReadable() || sk.isWritable() ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 忽略 sendfile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ( attachment.getSendfileData() != null ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    processSendfile(sk,attachment, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // unregister 相应的 interest set，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如接下来是处理 SocketChannel 进来的数据，那么就不再监听该 channel 的 OP_READ 事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    unreg(sk, attachment, sk.readyOps());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    boolean closeSocket = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Read goes before write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (sk.isReadable()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 处理读</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (!processSocket(attachment, SocketEvent.OPEN_READ, true)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            closeSocket = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (!closeSocket &amp;&amp; sk.isWritable()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 处理写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (!processSocket(attachment, SocketEvent.OPEN_WRITE, true)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            closeSocket = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (closeSocket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cancelledKey(sk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //invalid key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelledKey(sk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch ( CancelledKeyException ckx ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cancelledKey(sk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExceptionUtils.handleThrowable(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(&quot;&quot;,t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>接下来是 processSocket 方法，注意第三个参数，上面进来的时候是 true。</p>
<p>AbstractEndpoint # processSocket</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SocketEvent event, boolean dispatch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (socketWrapper == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (sc == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建一个 SocketProcessor 的实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sc = createSocketProcessor(socketWrapper, event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sc.reset(socketWrapper, event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Executor executor = getExecutor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dispatch &amp;&amp; executor != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将任务放到之前建立的 worker 线程池中执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(sc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sc.run(); // ps: 如果 dispatch 为 false，那么就当前线程自己执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (RejectedExecutionException ree) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        getLog().warn(sm.getString(&quot;endpoint.executor.fail&quot;, socketWrapper) , ree);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExceptionUtils.handleThrowable(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This means we got an OOM or similar creating a thread, or that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // the pool and its queue are full</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;), t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>NioEndpoint # createSocketProcessor</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected SocketProcessorBase&lt;NioChannel&gt; createSocketProcessor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new SocketProcessor(socketWrapper, event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们看到，提交到 worker 线程池中的是 NioEndpoint.SocketProcessor 的实例，至于它的 run() 方法之后的逻辑，我们就不再继续往里分析了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>最后，再祭出文章开始的那张图来总结一下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230405105530.png" alt="" class="img_kGBN"></p>
<p>这里简单梳理下前面我们说的流程，帮大家回忆一下：</p>
<ol>
<li>指定 Protocol，初始化相应的 Endpoint，我们  分析的是 NioEndpoint；</li>
<li>init 过程：在 NioEndpoint 中做 bind 操作；</li>
<li>start 过程：启动 worker 线程池，启动 1 个 Acceptor 和 2 个 Poller，当然它们都是默认值，可配；</li>
<li>Acceptor 获取到新的连接后，getPoller0() 获取其中一个 Poller，然后 register 到 Poller 中；</li>
<li>Poller 循环 selector.select(xxx)，如果有通道 readable，那么在 processKey 中将其放到 worker 线程池中。</li>
</ol>
<p>后续的流程，感兴趣的读者请自行分析，本文就说到这里了。</p>
<p>（全文完）</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java网络编程与NIO详解：LinuxEpoll实现原理详解</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/network/Java网络与NIO总结"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java网络与NIO总结</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#源码环境准备" class="table-of-contents__link toc-highlight">源码环境准备</a></li><li><a href="#endpoint" class="table-of-contents__link toc-highlight">endpoint</a></li><li><a href="#init-过程分析" class="table-of-contents__link toc-highlight">init 过程分析</a></li><li><a href="#start-过程分析" class="table-of-contents__link toc-highlight">start 过程分析</a></li><li><a href="#acceptor" class="table-of-contents__link toc-highlight">Acceptor</a></li><li><a href="#poller" class="table-of-contents__link toc-highlight">Poller</a></li><li><a href="#processkey" class="table-of-contents__link toc-highlight">processKey</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java网络编程与NIO详解：LinuxEpoll实现原理详解 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java网络编程与NIO详解：LinuxEpoll实现原理详解 | Tommy"><meta data-rh="true" name="description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><meta data-rh="true" property="og:description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">Java网络编程与NIO详解：基于NIO的网络编程框架Netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：浅谈Linux中Selector的实现原理">Java网络编程与NIO详解：浅谈Linux中Selector的实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：浅析mmap和DirectBuffer">Java网络编程与NIO详解：浅析mmap和DirectBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：浅析NIO包中的Buffer、Channel和Selector">Java网络编程与NIO详解：浅析NIO包中的Buffer、Channel和Selector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：深度解读Tomcat中的NIO模型">Java网络编程与NIO详解：深度解读Tomcat中的NIO模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：IO模型与Java网络编程模型">Java网络编程与NIO详解：IO模型与Java网络编程模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Java非阻塞IO和异步IO">Java网络编程与NIO详解：Java非阻塞IO和异步IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：JAVA中原生的socket通信机制">Java网络编程与NIO详解：JAVA中原生的socket通信机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：JavaNIO一步步构建IO多路复用的请求模型">Java网络编程与NIO详解：JavaNIO一步步构建IO多  路复用的请求模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解">Java网络编程与NIO详解：LinuxEpoll实现原理详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）">Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/network/Java网络与NIO总结">Java网络与NIO总结</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">网络</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java网络编程与NIO详解：LinuxEpoll 实现原理详解</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java网络编程与NIO详解：LinuxEpoll实现原理详解</h1></header><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章将同步到我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="为什么要-io-多路复用">为什么要 I/O 多路复用<a href="#为什么要-io-多路复用" class="hash-link" aria-label="Direct link to 为什么要 I/O 多路复用" title="Direct link to 为什么要 I/O 多路复用">​</a></h2>
<p>当需要从一个叫<code>r_fd</code>的描述符不停地读取数据，并把读到的数据写入一个叫<code>w_fd</code>的描述符时，我们可以用循环使用阻塞 I/O ：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    while((n = read(r_fd, buf, BUF_SIZE)) &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(write(w_fd, buf, n) != n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            err_sys(&quot;write error&quot;);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>但是，如果要从两个地方读取数据呢？这时，不能再使用会把程序阻塞住的<code>read</code>函数。因为可能在阻塞地等待<code>r_fd1</code>的数据时，来不及处理<code>r_fd2</code>，已经到达  的<code>r_fd2</code>的数据可能会丢失掉。</p>
<p>这个情况下需要使用<strong>非阻塞 I/O</strong>。</p>
<p>只要做个标记，把文件描述符标记为非阻塞的，以后再对它使用<code>read</code>函数：如果它还没有数据可读，函数会立即返回并把 errorno 这个变量的值设置为 35，于是我们知道它没有数据可读，然后可以立马去对其他描述符使用<code>read</code>；如果它有数据可读，我们就读取它数据。对所有要读的描述符都调用了一遍<code>read</code>之后，我们可以等一个较长的时间（比如几秒），然后再从第一个文件描述符开始调用<code>read</code>。这种循环就叫做<strong>轮询</strong>（polling）。</p>
<p>这样，不会像使用阻塞 I/O 时那样因为一个描述符<code>read</code>长时间处于等待数据而使程序阻塞。</p>
<p>轮询的缺点是浪费太多 CPU 时间。大多数时候我们没有数据可读，但是还是用了<code>read</code>这个<strong>系统调用</strong>，使用系统调用时会从用户态切换到内核态。而大多数情况下我们调用<code>read</code>，然后陷入内核态，内核发现这个描述符没有准备好，然后切换回用户态并且只得到 EAGAIN （errorno 被设置为 35），做的是无用功。描述符非常多的时候，每次的切换过程就是巨大的浪费。</p>
<p>所以，需要<strong>I/O 多路复用</strong>。I/O 多路复用通过使用一个系统函数，同时等待多个描述符的可读、可写状态。</p>
<p>为了达到这个目的，我们需要做的是：建立一个描述符列表，以及我们分别关心它们的什么事件（可读还是可写还是发生例外情况）；调用一个系统函数，直到这个描述符列表里有至少一个描述符关联的事件发生时，这个函数才会返回。</p>
<p>select, poll, epoll 就是这样的系统函数。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="select">select<a href="#select" class="hash-link" aria-label="Direct link to select" title="Direct link to select">​</a></h3>
<p>我们可以在所有 POSIX 兼容的系统里使用 select 函数来进行 I/O 多路复用。我们需要通过 select 函数的参数传递给内核的信息有：</p>
<ul>
<li>我们关心哪些描述符</li>
<li>我们关心它们的什么事件</li>
<li>我们希望等待多长时间</li>
</ul>
<p>select 的返回时，内核会告诉我们：</p>
<ul>
<li>可读的描述符的个数</li>
<li>哪些描述符发生了哪些事件</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    #include &lt;sys/select.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int select(int maxfdp1, fd_set* readfds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               fd_set* writefds, fd_set* exceptfds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               struct timeval* timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>maxfdp1</code>意思是 “max file descriptor plus 1” ，就是把你要监视的所有文件描述符里最大的那个加上 1 。（它实际上决定了内核要遍历文件描述符的次数，比如你监视了文件描述符 5 和 20 并把<code>maxfdp1</code>设置为 21 ，内核每次都会从描述符 0 依次检查到 20。）</p>
<p>中间的三个参数是你想监视的文件描述符的集合。可以把 fd_set 类型视为 1024 位的二进制数，这意味着 select 只能监视小于 1024 的文件描述符（1024 是由 Linux 的 sys/select.h 里<code>FD_SETSIZE</code>宏设置的值）。在 select 返回后我们通过<code>FD_ISSET</code>来判断代表该位的描述符是否是已准备好的状态。</p>
<p>最后一个参数是等待超时的时长：到达这个时长但是没有任一描述符可用时，函数会返回 0 。</p>
<p>用一个代码片段来展示 select 的用法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化两个 fd_set 以及 timeval</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fd_set read_set, write_set;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_ZERO(read_set);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_ZERO(write_set);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeval t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.tv_sec = 5;   // 超时为 5 秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.tv_usec = 0;  // 加 0 微秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置好两个 fd_set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int fd1 = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int fd2 = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int fd3 = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int maxfdp1 = 5 + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_SET(fd1, &amp;read_set);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_SET(fd2, &amp;read_set);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_SET(fd2, &amp;write_set);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_SET(fd3, &amp;write_set);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 准备备用的 fd_set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fd_set r_temp = read_set;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fd_set w_temp = write_set;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 每次都要重新设置放入 select 的 fd_set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            read_set = r_temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            write_set = w_temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用 select</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int n = select(maxfdp1, &amp;read_set, &amp;write_set, NULL, &amp;t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 上面的 select 函数会一直阻塞，直到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 3, 4 可读以及 4, 5 可写这四件事中至少一项发生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 或者等待时间到达 5 秒，返回 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i=0; i&lt;maxfdp1 &amp;&amp; n&gt;0; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(FD_ISSET(i, &amp;read_set)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    n--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(i==fd1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        prinf(&quot;描述符 3 可读&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(i==fd2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        prinf(&quot;描述符 4 可读&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(FD_ISSET(i, &amp;write_set)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    n--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(i==fd2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        prinf(&quot;描述符 3 可写&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(i==fd3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        prinf(&quot;描述符 4 可写&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 上面的 printf 语句换 成对应的 read 或者 write 函数就</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 可以立即读取或者写入相应的描述符而不用等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>可以看到，select 的缺点有：</p>
<ul>
<li>默认能监视的文件描述符不能大于 1024，也代表监视的总数不超过1024。即使你因为需要监视的描述符大于 1024 而改动内核的<code>FD_SETSIZE</code>值，但由于 select 是每次都会线性扫描整个fd_set，集合越大速度越慢，所以性能会比较差。</li>
<li>select 函数返回时只能看见已准备好的描述符数量，至于是哪个描述符准备好了需要循环用<code>FD_ISSET</code>来检查，当未准备好的描述符很多而准备好的很少时，效率比较低。</li>
<li>select 函数每次执行的时候，都把参数里传入的三个 fd_set 从用户空间复制到内核空间。而每次 fd_set 里要监视的描述符变化不大时，全部重新复制一遍并不划算。同样在每次都是未准备好的描述符很多而准备好的很少时，调用 select 会很频繁，用户/内核间的的数据复制就成了一个大的开销。</li>
</ul>
<p>还有一个问题是在代码的写法上给我一些困扰的，就是每次调用 select 前必须重新设置 三个 fd_set。 fd_set 类型只是 1024 位的二进制数（实际上结构体里是几个 long 变量的数组；比如 64 位机器上 long 是 64 bit，那么 fd_set 里就是 16 个 long 变量的数组），由一位的 1 和 0 代表一个文件描述符的状态，但是其实调用 select 前后位的 1/0 状态意义是不一样的。</p>
<p>先讲一下几个对 fd_set 操作的函数的作用：<code>FD_ZERO</code>把 fd_set 所有位设置为 0 ；<code>FD_SET</code>把一个位设置为 1 ；<code>FD_ISSET</code>判断一个位是否为 1 。</p>
<p>调用 select 前：我们用<code>FD_ZERO</code>把 fd_set 先全部初始化，然后用<code>FD_SET</code>把我们关心的代表描述符的位设置为 1 。我们这时可以用<code>FD_ISSET</code>判断这个位是否被我们设置，这时的含义是<strong>我们想要监视的描述符是否被设置为被监视的状态</strong>。</p>
<p>调用 select 时：内核判断 fd_set 里的位并把各个 fd_set 里所有值为 1 的位记录下来，然后把 fd_set 全部设置成 0 ；一个描述符上有对应的事件发生时，把对应 fd_set 里代表这个描述符的位设置为 1 。</p>
<p>在 select 返回之后：我们同样用<code>FD_ISSET</code>判断各个我们关心的位是 0 还是 1 ，这时的含义是，<strong>这个位是否是发生了我们关心的事件</strong>。</p>
<p>所以，在下一次调用 select 前，我们不得不把已经被内核改掉的 fd_set 全部重新设置一下。</p>
<p>select 在监视大量描述符尤其是更多的描述符未准备好的情况时性能很差。《Unix 高级编程》里写，用 select 的程序通常只使用 3 到 10 个描述符。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="poll">poll<a href="#poll" class="hash-link" aria-label="Direct link to poll" title="Direct link to poll">​</a></h3>
<p>poll 和 select 是相似的，只是给的接口不同。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    #include &lt;poll.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">`fdarray`是`pollfd`的数组。`pollfd`结构体是这样的：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct pollfd {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int fd;         // 文件描述符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        short events;   // 我期待的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        short revents;  // 实际发生的事件：我期待的事件中发生的；或者异常情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>nfds</code>是<code>fdarray</code>的长度，也就是 pollfd 的个数。</p>
<p><code>timeout</code>代表等待超时的毫秒数。</p>
<p>相比 select ，poll 有这些优点：由于 poll 在 pollfd 里用<code>int fd</code>来表示文件描述符而不像 select 里用的 fd_set 来分别表示描述符，所以没有必须小于 1024 的限制，也没有数量限制；由于 poll 用<code>events</code>表示期待的事件，通过修改<code>revents</code>来表示发生的事件，所以不需要像 select 在每次调用前重新设置描述符和期待的事件。</p>
<p>除此之外，poll 和 select 几乎相同。在 poll 返回后，需要遍历<code>fdarray</code>来检查各个<code>pollfd</code>里的<code>revents</code>是否发生了期待的事件；每次调用 poll 时，把<code>fdarray</code>复制到内核空间。在描述符太多而每次准备好的较少时，poll 有同样的性能问题。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="epoll">epoll<a href="#epoll" class="hash-link" aria-label="Direct link to epoll" title="Direct link to epoll">​</a></h3>
<p>epoll 是在 Linux 2.5.44 中首度登场的。不像 select 和 poll ，它提供了三个系统函数而不是一个。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="epoll_create-用来创建一个-epoll-描述符">epoll_create 用来创建一个 epoll 描述符：<a href="#epoll_create-用来创建一个-epoll-描述符" class="hash-link" aria-label="Direct link to epoll_create 用来创建一个 epoll 描述符：" title="Direct link to epoll_create 用来创建一个 epoll 描述符：">​</a></h4>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    #include &lt;sys/epoll.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int epoll_create(int size);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>// 返回值：epoll 描述符
<code>size</code>用来告诉内核你想监视的文件描述符的数目，但是它<strong>并不是限制了能监视的描述符的最大个数</strong>，而是给内核最初分配的空间一个建议。然后系统会在内核中分配一个空间来存放事件表，并返回一个<strong>epoll 描述符</strong>，用来操作这个事件表。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="epoll_ctl-用来增删改内核中的事件表">epoll_ctl 用来增/删/改内核中的事件表：<a href="#epoll_ctl-用来增删改内核中的事件表" class="hash-link" aria-label="Direct link to epoll_ctl 用来增/删/改内核中的事件表：" title="Direct link to epoll_ctl 用来增/删/改内核中的事件表：">​</a></h4>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>// 返回值：成功时返回 0 ，失败时返回 -1</p>
<p><code>epfd</code>是 epoll 描述符。</p>
<p><code>op</code>是操作类型（增加/删除/修改）。</p>
<p><code>fd</code>是希望监视的文件描述符。</p>
<p><code>event</code>是一个 epoll_event 结构体的指针。epoll_event 的定义是这样的：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    typedef union epoll_data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       void        *ptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int          fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       uint32_t     u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       uint64_t     u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } epoll_data_t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct epoll_event {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       uint32_t     events;      // 我期待的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       epoll_data_t data;        // 用户数据变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个结构体里，除了期待的事件外，还有一个<code>data</code>，是一个 union，它是用来让我们在得到下面第三个函数的返回值以后方便的定位文件描述符的。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="epoll_wait-用来等待事件">epoll_wait 用来等待事件<a href="#epoll_wait-用来等待事件" class="hash-link" aria-label="Direct link to epoll_wait 用来等待事件" title="Direct link to epoll_wait 用来等待事件">​</a></h4>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    int epoll_wait(int epfd, struct epoll_event *result_events,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  int maxevents, int timeout);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>// 返回值：已就绪的描述符个数。超时时为 0 ，错误时为 -1
<code>epfd</code>是 epoll 描述符。</p>
<p><code>result_events</code>是 epoll_event 结构体的指针，它将指向的是所有已经准备好的事件描述符相关联的 epoll_event（在上个步骤里调用 epoll_ctl 时关联起来的）。下面的例子可以让你知道这个参数的意义。</p>
<p><code>maxevents</code>是返回的最大事件个数，也就是你能通过 result_events 指针遍历到的最大的次数。</p>
<p><code>timeout</code>是等待超时的毫秒数。</p>
<p>用一个代码片段来展示 epoll 的用法：
// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    /* 通过 epoll_create 创建 epoll 描述符 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int epfd = epoll_create(4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fd1 = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fd2 = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fd3 = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* 通过 epoll_ctl 注册好四个事件 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct epoll_event ev1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev1.events = EPOLLIN;      // 期待它的可读事件发生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev1.data   = fd1;          // 我们通常就把 data 设置为 fd ，方便以后查看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &amp;ev1);  // 添加到事件表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct epoll_event ev2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev2.events = EPOLLIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev2.data   = fd2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct epoll_event ev3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev3.events = EPOLLOUT;     // 期待它的可写事件发生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev3.data   = fd2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct epoll_event ev4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev4.events = EPOLLOUT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ev4.data   = fd3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    epoll_ctl(epfd, EPOLL_CTL_ADD, fd3, &amp;ev4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* 通过 epoll_wait 等待事件 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # DEFINE MAXEVENTS 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct epoll_event result_events[MAXEVENTS];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(true){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int n = epoll_wait(epfd, &amp;result_events, MAXEVENTS, 5000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i=0; i&lt;n; n--){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // result_events[i] 一定是 ev1 到 ev4 中的一个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(result_events[i].events&amp;EPOLLIN)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;描述符 %d 可读&quot;, result_events[i].fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if(result_events[i].events&amp;EPOLLOUT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;描述符 %d 可写&quot;, result_events[i].fd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以 epoll 解决了 poll 和 select 的问题：</p>
<ul>
<li>
<p>只在 epoll_ctl 的时候把数据复制到内  核空间，这保证了每个描述符和事件一定只会被复制到内核空间一次；每次调用 epoll_wait 都不会复制新数据到内核空间。相比之下，select 每次调用都会把三个 fd_set 复制一遍；poll 每次调用都会把<code>fdarray</code>复制一遍。</p>
</li>
<li>
<p>epoll_wait 返回 n ，那么只需要做 n 次循环，可以保证遍历的每一次都是有意义的。相比之下，select 需要做至少 n 次至多<code>maxfdp1</code>次循环；poll 需要遍历完 fdarray 即做<code>nfds</code>次循环。</p>
</li>
<li>
<p>在内部实现上，epoll 使用了回调的方法。调用 epoll_ctl 时，就是注册了一个事件：在集合中放入文件描述符以及事件数据，并且加上一个回调函数。一旦文件描述符上的对应事件发生，就会调用回调函数，这个函数会把这个文件描述符加入到<strong>就绪队列</strong>上。当你调用 epoll_wait 时，它只是在查看就绪队列上是否有内容，有的话就返回给你的程序。<code>select()``poll()``epoll_wait()</code>三个函数在操作系统看来，都是睡眠一会儿然后判断一会儿的循环，但是 select 和 poll 在醒着的时候要遍历整个文件描述符集合，而 epoll_wait 只是看看就绪队列是否为空而已。这是 epoll 高性能的理由，使得其 I/O 的效率不会像使用轮询的 select/poll 随着描述符增加而大大降低。</p>
</li>
</ul>
<blockquote>
<p>注 1 ：select/poll/epoll_wait 三个函数的等待超时时间都有一样的特性：等待时间设置为 0 时函数不阻塞而是立即返回，不论是否有文件描述符已准备好；poll/epoll_wait 中的 timeout 为 -1，select 中的 timeout 为 NULL 时，则无限等待，直到有描述符已准备好才会返回。</p>
</blockquote>
<blockquote>
<p>注 2 ：有的新手会把文件描述符是否标记为阻塞 I/O 等同于 I/O 多路复用函数是否阻塞。其实文件描述符是否标记为阻塞，决定了你<code>read</code>或<code>write</code>它时如果它未准备好是阻塞等待，还是立即返回 EAGAIN ；而 I/O 多路复用函数除非你把 timeout 设置为 0 ，否则它总是会阻塞住你的程序。</p>
</blockquote>
<blockquote>
<p>注 3 ：上面的例子只是入门，可能是不准确或不全面的：一是数据要立即处理防止丢失；二是 EPOLLIN/EPOLLOUT 不完全等同于可读可写事件，具体要去搜索 poll/epoll 的事件具体有哪些；三是大多数实际例子里，比如一个 tcp server ，都会在运行中不断增加/删除的文件描述符而不是记住固定的 3 4 5 几个描述符（用这种例子更能看出 epoll 的优势）；四是 epoll 的优势更多的体现在处理大量闲连接的情况，如果场景是处理少量短连接，用 select 反而更好，而且用 select 的代码能运行在所有平台上。</p>
</blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/network/Java网络编程与NIO详解：LinuxEpoll实现原理详解.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：JavaNIO一步步构建IO多路复用的请求模型"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java网络编程与NIO详解：JavaNIO一步步构建IO多路复 用的请求模型</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java网络编程与NIO详解：Tomcat中的Connector源码分析（NIO）</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#为什么要-io-多路复用" class="table-of-contents__link toc-highlight">为什么要 I/O 多路复用</a><ul><li><a href="#select" class="table-of-contents__link toc-highlight">select</a></li><li><a href="#poll" class="table-of-contents__link toc-highlight">poll</a></li><li><a href="#epoll" class="table-of-contents__link toc-highlight">epoll</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
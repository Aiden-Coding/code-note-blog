<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">深入理解JVM虚拟机：GC调优思路与常用工具 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="深入理解JVM虚拟机：GC调优思路与常用工具 | Tommy"><meta data-rh="true" name="description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><meta data-rh="true" property="og:description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">深入理解JVM虚拟机：垃圾回收器详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：深入理解JVM类加载机制">深入理解JVM虚拟机：深入理解JVM类加载机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：虚拟机字节码执行引擎">深入理解JVM虚拟机：虚拟机字节码执行引擎</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：再谈四种引用及GC实践">深入理解JVM虚拟机：再谈四种引用及GC实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具">深入理解JVM虚拟机：GC调优思路与常用工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：Java的编译期优化与运行期优化">深入理解JVM虚拟机：Java的编译期优化与运行期优化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：Java内存异常原理与实践">深入理解JVM虚拟机：Java内存异常原理与实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：Java字节码介绍与解析实践">深入理解JVM虚拟机：Java字节码介绍与解析实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：JNDI，OSGI，Tomcat类加载器实现">深入理解JVM虚拟机：JNDI，OSGI，Tomcat类加载器实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：JVM常用参数以及调优实践">深入理解JVM虚拟机：JVM常用参数以及调优实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：JVM监控工具与诊断实践">深入理解JVM虚拟机：JVM监控工具与诊断实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：JVM垃圾回收基本原理和算法">深入理解JVM虚拟机：JVM垃圾回收基本原理和算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：JVM内存的结构与消失的永久代">深入理解JVM虚拟机：JVM内存的结构与消失的永久代</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：JVM性能管理神器VisualVM介绍与实战">深入理解JVM虚拟机：JVM性能管理神器VisualVM介绍与实战</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/JVM/JVM总结">JVM总结</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">jvm</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">深入理解JVM虚拟机：GC调优思路与常用工具</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>深入理解JVM虚拟机：GC调优思路与常用工具</h1></header><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章首发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《深入理解JVM虚拟机》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。
该系列博文会告诉你如何从入门到进阶，一步步地学习JVM基础知识，并上手进行JVM调优实战，JVM是每一个Java工程师必须要学习和理解的知识点  ，你必须要掌握其实现原理，才能更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<blockquote>
<p><strong>说明</strong>:</p>
<p><strong>Capacity</strong>: 性能,能力,系统容量; 文中翻译为”<strong>系统容量</strong>“; 意为硬件配置。</p>
</blockquote>
<p>您应该已经阅读了前面的章节:</p>
<ol>
<li>垃圾收集简介 - GC参考手册</li>
<li>Java中的垃圾收集 - GC参考手册</li>
<li>GC 算法(基础篇) - GC参考手册</li>
<li>GC 算法(实现篇) - GC参考手册</li>
</ol>
<p>GC调优(Tuning Garbage Collection)和其他性能调优是同样的原理。初学者可能会被 200 多个 GC参数弄得一头雾水, 然后随便调整几个来试试结果,又或者修改几行代码来测试。其实只要参照下面的步骤，就能保证你的调优方向正确:</p>
<ol>
<li>列出性能调优指标(State your performance goals)</li>
<li>执行测试(Run tests)</li>
<li>检查结果(Measure the results)</li>
<li>与目标进行对比(Compare the results with the goals)</li>
<li>如果达不到指标, 修改配置参数, 然后继续测试(go back to running tests)</li>
</ol>
<p>第一步, 我们需要做的事情就是: 制定明确的GC性能指标。对所有性能监控和管理来说, 有三个维度是通用的:</p>
<ul>
<li>Latency(延迟)</li>
<li>Throughput(吞吐量)</li>
<li>Capacity(系统容量)</li>
</ul>
<p>我们先讲解基本概念,然后再演示如何使用这些指标。如果您对 延迟、吞吐量和系统容量等概念很熟悉, 可以跳过这一小节。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="核心概念core-concepts">核心概念(Core Concepts)<a href="#核心概念core-concepts" class="hash-link" aria-label="Direct link to 核心概念(Core Concepts)" title="Direct link to 核心概念(Core Concepts)">​</a></h3>
<p>我们先来看一家工厂的装配流水线。工人在流水线将现成的组件按顺序拼接,组装成自行车。通过实地观测, 我们发现从组件进入生产线，到另一端组装成自行车需要4小时。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224347.png" alt="" class="img_kGBN">
继续观察,我们还发现,此后每分钟就有1辆自行车完成组装, 每天24小时,一直如此。将这个模型简化, 并忽略维护窗口期后得出结论：<strong>这条流水线每小时可以组装60辆自行车</strong>。</p>
<blockquote>
<p><strong>说明</strong>: 时间窗口/窗口期，请类比车站卖票的窗口，是一段规定/限定做某件事的时间段。</p>
</blockquote>
<p>通过这两种测量方法, 就知道了生产线的相关性能信息：<strong>延迟</strong>与<strong>吞吐量</strong>:</p>
<ul>
<li>生产线的延迟:<strong>4小时</strong></li>
<li>生产线的吞吐量:<strong>60辆/小时</strong></li>
</ul>
<p>请注意, 衡量延迟的时间单位根据具体需要而确定 —— 从纳秒(nanosecond)到几千年(millennia)都有可能。系统的吞吐量是每个单位时间内完成的操作。操作(Operations)一般是特定系统相关的东西。在本例中,选择的时间单位是小时, 操作就是对自行车的组装。</p>
<p>掌握了延迟和吞吐量两个概念之后, 让我们对这个工厂来进行实际的调优。自行车的需求在一段时间内都很稳定, 生产线组装自行车有四个小时延迟, 而吞吐量在几个月以来都很稳定: 60辆/小时。假设某个销售团队突然业绩暴涨, 对自行车的需求增加了1倍。客户每天需要的自行车不再是 60 * 24 = 1440辆, 而是 2*1440 = 2880辆/天。老板对工厂的产能不满意，想要做些调整以提升产能。</p>
<p>看起来总  经理很容易得出正确的判断, 系统的延迟没法子进行处理 —— 他关注的是每天的自行车生产总量。得出这个结论以后, 假若工厂资金充足, 那么应该立即采取措施, 改善吞吐量以增加产能。</p>
<p>我们很快会看到, 这家工厂有两条相同的生产线。每条生产线一分钟可以组装一辆成品自行车。 可以想象，每天生产的自行车数量会增加一倍。达到 2880辆/天。要注意的是, 不需要减少自行车的装配时间 —— 从开始到结束依然需要 4 小时。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224359.png" alt="" class="img_kGBN"></p>
<p>巧合的是，这样进行的性能优化,同时增加了吞吐量和产能。一般来说，我们会先测量当前的系统性能, 再设定新目标, 只优化系统的某个方面来满足性能指标。</p>
<p>在这里做了一个很重要的决定 —— 要增加吞吐量,而不是减小延迟。在增加吞吐量的同时, 也需要增加系统容量。比起原来的情况, 现在需要两条流水线来生产出所需的自行车。在这种情况下, 增加系统的吞吐量并不是免费的, 需要水平扩展, 以满足增加的吞吐量需求。</p>
<p>在处理性能问题时, 应该考虑到还有另一种看似不相关的解决办法。假如生产线的延迟从1分钟降低为30秒,那么吞吐量同样可以增长 1 倍。</p>
<p>或者是降低延迟, 或者是客户非常有钱。软件工程里有一种相似的说法 —— 每个性能问题背后,总有两种不同的解决办法。 可以用更多的机器, 或者是花精力来改善性能低下的代码。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="latency延迟">Latency(延迟)<a href="#latency延迟" class="hash-link" aria-label="Direct link to Latency(延迟)" title="Direct link to Latency(延迟)">​</a></h4>
<p>GC的延迟指标由一般的延迟需求决定。延迟指标通常如下所述:</p>
<ul>
<li>所有交易 必须在10秒内得到响应</li>
<li>90%的订单付款操作必须在3秒以内处理完成</li>
<li>推荐商品必须在 100 ms 内展示到用户面前</li>
</ul>
<p>面对这类性能指标时, 需要确保在交易过程中, GC暂停不能占用太多时间，否则就满足不了指标。“不能占用太多” 的意思需要视具体情况而定, 还要考虑到其他因素, 比如外部数据源的交互时间(round-trips), 锁竞争(lock contention), 以及其他的安全点等等。</p>
<p>假设性能需求为:<code>90%</code>的交易要在<code>1000ms</code>以内完成, 每次交易最长不能超过<code>10秒</code>。 根据经验, 假设GC暂停时间比例不能超过10%。 也就是说, 90%的GC暂停必须在<code>100ms</code>内结束, 也不能有超过<code>1000ms</code>的GC暂停。为简单起见, 我们忽略在同一次交易过程中发生多次GC停顿的可能性。</p>
<p>有了正式的需求,下一步就是检查暂停时间。有许多工具可以使用, 在接下来的6. GC 调优(工具篇)</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">2015-06-04T13:34:16.974-0200: 2.578: [Full GC (Ergonomics)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [PSYoungGen: 93677K-&gt;70109K(254976K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [ParOldGen: 499597K-&gt;511230K(761856K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        593275K-&gt;581339K(1016832K),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [Metaspace: 2936K-&gt;2936K(1056768K)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    , 0.0713174 secs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Times: user=0.21 sys=0.02, real=0.07 secs</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这表示一次GC暂停, 在<code>2015-06-04T13:34:16</code>这个时刻触发. 对应于JVM启动之后的<code>2,578 ms</code>。</p>
<p>此事件将应用线程暂停了<code>0.0713174</code>秒。虽然花费的总时间为 210 ms, 但因为是多核CPU机器, 所以最重要的数字是应用线程被暂停的总时间, 这里使用的是并行GC, 所以暂停时间大约为<code>70ms</code>。 这次GC的暂停时间小于<code>100ms</code>的阈值，满足需求。</p>
<p>继续分析, 从所有GC日志中提取出暂停相关的数据, 汇总之后就可以得知是否满足需求。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="throughput吞吐量">Throughput(吞吐量)<a href="#throughput吞吐量" class="hash-link" aria-label="Direct link to Throughput(吞吐量)" title="Direct link to Throughput(吞吐量)">​</a></h4>
<p>吞吐量和延迟指标有很大区别。当然两者都是根据一般吞吐量需求而得出的。一般吞吐量需求(Generic requirements for throughput) 类似这样:</p>
<ul>
<li>解决方案每天必须处理 100万个订单</li>
<li>解决方案必须支持1000个登录用户,同时在5-10秒内执行某  个操作: A、B或C</li>
<li>每周对所有客户进行统计, 时间不能超过6小时，时间窗口为每周日晚12点到次日6点之间。</li>
</ul>
<p>可以看出,吞吐量需求不是针对单个操作的, 而是在给定的时间内, 系统必须完成多少个操作。和延迟需求类似, GC调优也需要确定GC行为所消耗的总时间。每个系统能接受的时间不同, 一般来说, GC占用的总时间比不能超过<code>10%</code>。</p>
<p>现在假设需求为: 每分钟处理 1000 笔交易。同时, 每分钟GC暂停的总时间不能超过6秒(即10%)。</p>
<p>有了正式的需求, 下一步就是获取相关的信息。依然是从GC日志中提取数据, 可以看到类似这样的信息:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">2015-06-04T13:34:16.974-0200: 2.578: [Full GC (Ergonomics)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [PSYoungGen: 93677K-&gt;70109K(254976K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [ParOldGen: 499597K-&gt;511230K(761856K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        593275K-&gt;581339K(1016832K), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [Metaspace: 2936K-&gt;2936K(1056768K)], </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     0.0713174 secs] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     [Times: user=0.21 sys=0.02, real=0.07 secs</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此时我们对 用户耗时(user)和系统耗时(sys)感兴趣, 而不关心实际耗时(real)。在这里, 我们关心的时间为<code>0.23s</code>(user + sys = 0.21 + 0.02 s), 这段时间内, GC暂停占用了 cpu 资源。 重要的是, 系统运行在多核机器上, 转换为实际的停顿时间(stop-the-world)为<code>0.0713174秒</code>, 下面的计算会用到这个数字。</p>
<p>提取出有用的信息后, 剩下要做的就是统计每分钟内GC暂停的总时间。看看是否满足需求: 每分钟内总的暂停时间不得超过6000毫秒(6秒)。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="capacity系统容量">Capacity(系统容量)<a href="#capacity系统容量" class="hash-link" aria-label="Direct link to Capacity(系统容量)" title="Direct link to Capacity(系统容量)">​</a></h4>
<p>系统容量(Capacity)需求,是在达成吞吐量和延迟指标的情况下,对硬件环境的额外约束。这类需求大多是来源于计算资源或者预算方面的原因。例如:</p>
<ul>
<li>系统必须能部署到小于512 MB内存的Android设备上</li>
<li>系统必须部署在Amazon<strong>EC2</strong>实例上, 配置不得超过<strong>c3.xlarge(4核8GB)</strong>。</li>
<li>每月的 Amazon EC2 账单不得超过<code>$12,000</code></li>
</ul>
<p>因此, 在满足延迟和吞吐量需求的基础上必须考虑系统容量。可以说, 假若有无限的计算资源可供挥霍, 那么任何 延迟和吞吐量指标 都不成问题, 但现实情况是, 预算(budget)和其他约束限制了可用的资源。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="相关示例">相关示例<a href="#相关示例" class="hash-link" aria-label="Direct link to 相关示例" title="Direct link to 相关示例">​</a></h3>
<p>介绍完性能调优的三个维度后, 我们来进行实际的操作以达成GC性能指标。</p>
<p>请看下面的代码:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//imports skipped for brevity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Producer implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static ScheduledExecutorService executorService</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         = Executors.newScheduledThreadPool(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Deque&lt;byte[]&gt; deque;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int objectSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int queueSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Producer(int objectSize, int ttl) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.deque = new ArrayDeque&lt;byte[]&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.objectSize = objectSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.queueSize = ttl * 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; 100; i++) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deque.add(new byte[objectSize]); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (deque.size() &gt; queueSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            deque.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static void main(String[] args) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executorService.scheduleAtFixedRate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Producer(200 * 1024 * 1024 / 1000, 5), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0, 100, TimeUnit.MILLISECONDS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executorService.scheduleAtFixedRate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Producer(50 * 1024 * 1024 / 1000, 120), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0, 100, TimeUnit.MILLISECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TimeUnit.MINUTES.sleep(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executorService.shutdownNow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这段程序代码, 每 100毫秒 提交两个作业(job)来。每个作业都模拟特定的生命周期: 创建对象, 然后在预定的时间释放, 接着就不管了, 由GC来自动回收占用的内存。</p>
<p>在运行这个示例程序时，通过以下JVM参数打开GC日志记录:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>还应该加上JVM参数<code>-Xloggc</code>以指定GC日志的存储位置,类似这样:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">-Xloggc:C:\\Producer_gc.log</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>1</li>
<li>2</li>
</ul>
<p>在日志文件中可以看到GC的行为, 类似下面这样:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">2015-06-04T13:34:16.119-0200: 1.723: [GC (Allocation Failure) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [PSYoungGen: 114016K-&gt;73191K(234496K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    421540K-&gt;421269K(745984K), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.0858176 secs] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Times: user=0.04 sys=0.06, real=0.09 secs] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2015-06-04T13:34:16.738-0200: 2.342: [GC (Allocation Failure) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [PSYoungGen: 234462K-&gt;93677K(254976K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    582540K-&gt;593275K(766464K), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.2357086 secs] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Times: user=0.11 sys=0.14, real=0.24 secs] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2015-06-04T13:34:16.974-0200: 2.578: [Full GC (Ergonomics) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [PSYoungGen: 93677K-&gt;70109K(254976K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [ParOldGen: 499597K-&gt;511230K(761856K)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    593275K-&gt;581339K(1016832K), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [Metaspace: 2936K-&gt;2936K(1056768K)], </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.0713174 secs] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Times: user=0.21 sys=0.02, real=0.07 secs]</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>基于日志中的信息, 可以通过三个优化目标来提升性能:</p>
<ol>
<li>确保最坏情况下,GC暂停时间不超过预定阀值</li>
<li>确保线程暂停的总时间不超过预定阀值</li>
<li>在确保达到延迟和吞吐量指标的情况下, 降低硬件配置以及成本。</li>
</ol>
<p>为此, 用三种不同的配置, 将代码运行10分钟, 得到了三种不同的结果, 汇总如下:</p>
<table><thead><tr><th><strong>堆内存大小(Heap)</strong></th><th><strong>GC算法(GC Algorithm)</strong></th><th><strong>有效时间比(Useful work)</strong></th><th><strong>最长停顿时间(Longest pause)</strong></th></tr></thead><tbody><tr><td>-Xmx12g</td><td>-XX:+UseConcMarkSweepGC</td><td>89.8%</td><td><strong>560 ms</strong></td></tr><tr><td>-Xmx12g</td><td>-XX:+UseParallelGC</td><td>91.5%</td><td>1,104 ms</td></tr><tr><td>-Xmx8g</td><td>-XX:+UseConcMarkSweepGC</td><td>66.3%</td><td>1,610 ms</td></tr></tbody></table>
<p>使用不同的GC算法,和不同的内存配置,运行相同的代码, 以测量GC暂停时间与 延迟、吞吐量的关系。实验的细节和结果在后面章节详细介绍。</p>
<p>注意, 为了尽量简单, 示例中只改变了很少的输入参数, 此实验也没有在不同CPU数量或者不同的堆布局下进行测试。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="tuning-for-latency调优延迟指标">Tuning for Latency(调优延迟指标)<a href="#tuning-for-latency调优延迟指标" class="hash-link" aria-label="Direct link to Tuning for Latency(调优延迟指标)" title="Direct link to Tuning for Latency(调优延迟指标)">​</a></h4>
<p>假设有一个需求,<strong>每次作业必须在 1000ms 内处理完成</strong>。我们知道, 实际的作业处理只需要100 ms，简化后， 两者相减就可以算出对 GC暂停的延迟要求。现在需求变成:<strong>GC暂停不能超过900ms</strong>。这个问题很容易找到答案, 只需要解析GC日志文件, 并找出GC暂停中最大的那个暂停时间即可。</p>
<p>再来看测试所用的三个配置:</p>
<table><thead><tr><th><strong>堆内存大小(Heap)</strong></th><th><strong>GC算法(GC Algorithm)</strong></th><th><strong>有效时间比(Useful work)</strong></th><th><strong>最长停顿时间(Longest pause)</strong></th></tr></thead><tbody><tr><td>-Xmx12g</td><td>-XX:+UseConcMarkSweepGC</td><td>89.8%</td><td><strong>560 ms</strong></td></tr><tr><td>-Xmx12g</td><td>-XX:+UseParallelGC</td><td>91.5%</td><td>1,104 ms</td></tr><tr><td>-Xmx8g</td><td>-XX:+UseConcMarkSweepGC</td><td>66.3%</td><td>1,610 ms</td></tr></tbody></table>
<p>可以看到,其中有一个配置达到了要求。运行的参数为:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -Xmx12g -XX:+UseConcMarkSweepGC Producer</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>对应的GC日志中,暂停时间最大为<code>560 ms</code>, 这达到了延迟指标<code>900 ms</code>的要求。如果还满足吞吐量和系统容量需求的话,就可以说成功达成了GC调优目标, 调优结束。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="tuning-for-throughput吞吐量调优">Tuning for Throughput(吞吐量调优)<a href="#tuning-for-throughput吞吐量调优" class="hash-link" aria-label="Direct link to Tuning for Throughput(吞吐量调优)" title="Direct link to Tuning for Throughput(吞吐量调优)">​</a></h4>
<p>假定吞吐量指标为:<strong>每小时完成 1300万次操作处理</strong>。同样是上面的配置, 其中有一种配置满足了需求:</p>
<table><thead><tr><th><strong>堆内存大小(Heap)</strong></th><th><strong>GC算法(GC Algorithm)</strong></th><th><strong>有效时间比(Useful work)</strong></th><th><strong>最长停顿时间(Longest pause)</strong></th></tr></thead><tbody><tr><td>-Xmx12g</td><td>-XX:+UseConcMarkSweepGC</td><td>89.8%</td><td>560 ms</td></tr><tr><td>-Xmx12g</td><td>-XX:+UseParallelGC</td><td><strong>91.5%</strong></td><td>1,104 ms</td></tr><tr><td>-Xmx8g</td><td>-XX:+UseConcMarkSweepGC</td><td>66.3%</td><td>1,610 ms</td></tr></tbody></table>
<p>此配置对应的命令行参数为:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -Xmx12g -XX:+UseParallelGC Producer</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>可以看到,GC占用了 8.5%的CPU时间,剩下的<code>91.5%</code>是有效的计算时间。为简单起见, 忽略示例中的其他安全点。现在需要考虑:</li>
</ul>
<ol>
<li>每个CPU核心处理一次作业需要耗时<code>100ms</code></li>
<li>因此, 一分钟内每个核心可以执行 60,000 次操作(<strong>每个job完成100次操作</strong>)</li>
<li>一小时内, 一个核心可以执行 360万次操作</li>
<li>有四个CPU内核, 则每小时可以执行: 4 x 3.6M = 1440万次操作</li>
</ol>
<p>理论上，通过简单的计算就可以得出结论, 每小时可以执行的操作数为:<code>14.4 M * 91.5% = 13,176,000</code>次, 满足需求。</p>
<p>值得一提的是, 假若还要满足延迟指标, 那就有问题了, 最坏情况下, GC暂停时间为<code>1,104 ms</code>, 最大延迟时间是前一种配置的两倍。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="tuning-for-capacity调优系统容量">Tuning for Capacity(调优系统容量)<a href="#tuning-for-capacity调优系统容量" class="hash-link" aria-label="Direct link to Tuning for Capacity(调优系统容量)" title="Direct link to Tuning for Capacity(调优系统容量)">​</a></h4>
<p>假设需要将软件部署到服务器上(commodity-class hardware), 配置为<code>4核10G</code>。这样的话, 系统容量的要求就变成: 最大的堆内存空间不能超过<code>8GB</code>。有了这个需求, 我们需要调整为第三套配置进行测试:</p>
<table><thead><tr><th><strong>堆内存大小(Heap)</strong></th><th><strong>GC算法(GC Algorithm)</strong></th><th><strong>有效时间比(Useful work)</strong></th><th><strong>最长停顿时间(Longest pause)</strong></th></tr></thead><tbody><tr><td>-Xmx12g</td><td>-XX:+UseConcMarkSweepGC</td><td>89.8%</td><td>560 ms</td></tr><tr><td>-Xmx12g</td><td>-XX:+UseParallelGC</td><td>91.5%</td><td>1,104 ms</td></tr><tr><td><strong>-Xmx8g</strong></td><td>-XX:+UseConcMarkSweepGC</td><td>66.3%</td><td>1,610 ms</td></tr></tbody></table>
<p>程序可以通过如下参数执行:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -Xmx8g -XX:+UseConcMarkSweepGC Producer</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>测试结果是延迟大幅增长, 吞吐量同样大幅降低:</li>
<li>现在,GC占用了更多的CPU资源, 这个配置只有<code>66.3%</code>的有效CPU时间。因此,这个配置让吞吐量从最好的情况<strong>13,176,000 操作/小时</strong>下降到<strong>不足 9,547,200次操作/小时</strong>.</li>
<li>最坏情况下的延迟变成了<strong>1,610 ms</strong>, 而不再是<strong>560ms</strong>。</li>
</ul>
<p>通过对这三个维度的介绍, 你应该了解, 不是简单的进行“性能(performance)”优化, 而是需要从三种不同的维度来进行考虑, 测量, 并调优延迟和吞吐量, 此外还需要考虑系统容量的约束。</p>
<p>请继续阅读下一章:6. GC 调优(工具篇) - GC参考手册</p>
<p>原文链接:<a href="https://plumbr.eu/handbook/gc-tuning" target="_blank" rel="noopener noreferrer">GC Tuning: Basics</a></p>
<p>翻译时间: 2016年02月06日</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="6-gc-调优工具篇---gc参考手册">6. GC 调优(工具篇) - GC参考手册<a href="#6-gc-调优工具篇---gc 参考手册" class="hash-link" aria-label="Direct link to 6. GC 调优(工具篇) - GC参考手册" title="Direct link to 6. GC 调优(工具篇) - GC参考手册">​</a></h2>
<p>2017年02月23日 18:56:02</p>
<p>阅读数：6469</p>
<p>进行GC性能调优时, 需要明确了解, 当前的GC行为对系统和用户有多大的影响。有多种监控GC的工具和方法, 本章将逐一介绍常用的工具。</p>
<p>您应该已经阅读了前面的章节:</p>
<ol>
<li>垃圾收集简介 - GC参考手册</li>
<li>Java中的垃圾收集 - GC参考手册</li>
<li>GC 算法(基础篇) - GC参考手册</li>
<li>GC 算法(实现篇) - GC参考手册</li>
<li>GC 调优(基础篇) - GC参考手册</li>
</ol>
<p>JVM 在程序执行的过程中, 提供了GC行为的原生数据。那么, 我们就可以利用这些原生数据来生成各种报告。原生数据(<em>raw data</em>) 包括:</p>
<ul>
<li>各个内存池的当前使用情况,</li>
<li>各个内存池的总容量,</li>
<li>每次GC暂停的持续时间,</li>
<li>GC暂停在各个阶段的持续时间。</li>
</ul>
<p>可以通过这些数据算出各种指标, 例如: 程序的内存分配率, 提升率等等。本章主要介绍如何获取原生数据。 后续的章节将对重要的派生指标(derived metrics)展开讨论, 并引入GC性能相关的话题。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="jmx-api">JMX API<a href="#jmx-api" class="hash-link" aria-label="Direct link to JMX API" title="Direct link to JMX API">​</a></h2>
<p>从 JVM 运行时获取GC行为数据, 最简单的办法是使用标准<a href="https://docs.oracle.com/javase/tutorial/jmx/index.html" target="_blank" rel="noopener noreferrer">JMX API 接口</a>. JMX是获取 JVM内部运行时状态信息 的标准API. 可以编写程序代码, 通过 JMX API 来访问本程序所在的JVM，也可以通过JMX客户端执行(远程)访问。</p>
<p>最常见的 JMX客户端是<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener noreferrer">JConsole</a>和<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jvisualvm.html" target="_blank" rel="noopener noreferrer">JVisualVM</a>(可以安装各种插件,十分强大)。两个工具都是标准JDK的一部分, 而且很容易使用. 如果使用的是 JDK 7u40 及更高版本, 还可以使用另一个工具:<a href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html" target="_blank" rel="noopener noreferrer">Java Mission Control</a>( 大致翻译为 Java控制中心,<code>jmc.exe</code>)。</p>
<blockquote>
<p>JVisualVM安装MBeans插件的步骤: 通过 工具(T) – 插件(G) – 可用插件 – 勾选VisualVM-MBeans – 安装 – 下一步 – 等待安装完成…… 其他插件的安装过程基本一致。</p>
</blockquote>
<p>所有 JMX客户端都是独立的程序,可以连接到目标JVM上。目标JVM可以在本机, 也可能是远端JVM. 如果要连接远端JVM, 则目标JVM启动时必须指定特定的环境变量,以开启远程JMX连接/以及端口号。 示例如下:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -Dcom.sun.management.jmxremote.port=5432 com.yourcompany.YourApp</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在此处, JVM 打开端口<code>5432</code>以支持JMX连接。</p>
<p>通过 JVisualVM 连接到某个JVM以后, 切换到 MBeans 标签, 展开 “java.lang/GarbageCollector” . 就可以看到GC行为信息, 下图是 JVisualVM 中的截图:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224430.png" alt="" class="img_kGBN"></p>
<p>下图是Java Mission Control 中的截图:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224439.png" alt="" class="img_kGBN"></p>
<p>从以上截图中可以看到两款垃圾收集器。其中一款负责清理年轻代(<strong>PS Scavenge</strong>)，另一款负责清理老年代(<strong>PS MarkSweep</strong>); 列表中显示的就是垃圾收集器的名称。可以看到 , jmc 的功能和展示数据的方式更强大。</p>
<p>对所有的垃圾收集器, 通过 JMX API 获取的信息包括:</p>
<ul>
<li><strong>CollectionCount</strong>: 垃圾收集器执行的GC总次数,</li>
<li><strong>CollectionTime</strong>: 收集器运行时间的累计。这个值等于所有GC事件持续时间的总和,</li>
<li><strong>LastGcInfo</strong>: 最近一次GC事件的详细信息。包括 GC事件的持续时间(duration), 开始时间(startTime) 和 结束时间(endTime), 以及各个内存池在最近一次GC之前和之后的使用情况,</li>
<li><strong>MemoryPoolNames</strong>: 各个内存池的名称,</li>
<li><strong>Name</strong>: 垃圾收集器的名称</li>
<li><strong>ObjectName</strong>: 由JMX规范定义的 MBean的名字,,</li>
<li><strong>Valid</strong>: 此收集器是否有效。本人只见过 “<code>true</code>“的情况 (^_^)</li>
</ul>
<p>根据经验, 这些信息对GC的性能来说,不能得出什么结论. 只有编写程序, 获取GC相关的 JMX 信息来进行统计和分析。 在下文可以看到, 一般也不怎么关注 MBean , 但 MBean 对于理解GC的原理倒是挺有用的。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="jvisualvm">JVisualVM<a href="#jvisualvm" class="hash-link" aria-label="Direct link to JVisualVM" title="Direct link to JVisualVM">​</a></h2>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224451.png" alt="" class="img_kGBN"></p>
<p>Visual GC 插件常用来监控本机运行的Java程序, 比如开发者和性能调优专家经常会使用此插件, 以快速获取程序运行时的GC信息。</p>
<p><img loading="lazy" src="https://s4.51cto.com/images/blog/202106/25/eabd68ba262d004c4919475f00d8ec9c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="06_03_jvmsualvm-garbage-collection-monitoring.png" title="06_03_jvmsualvm-garbage-collection-monitoring.png" class="img_kGBN"></p>
<p>左侧的图表展示了各个内存池的使用情况: Metaspace/永久代, 老年代, Eden区以及两个存活区。</p>
<p>在右边, 顶部的两个图表与 GC无关, 显示的是 JIT编译时间 和 类加载时间。下面的6个图显示的是内存池的历史记录, 每个内存池的GC次数,GC总时间, 以及最大值，峰值, 当前使用情况。</p>
<p>再下面是 HistoGram, 显示了年轻代对象的年龄分布。至于对象的年龄监控(objects tenuring monitoring), 本章不进行讲解。</p>
<p>与纯粹的JMX工具相比, VisualGC 插件提供了更友好的界面, 如果没有其他趁手的工具, 请选择VisualGC. 本章接下来会介绍其他工具, 这些工具可以提供更多的信息, 以及更好的视角. 当然, 在“Profilers(分析器)”一节中，也会介绍 JVisualVM 的适用场景 —— 如: 分配分析(allocation profiling), 所以我们绝不会贬低哪一款工具, 关键还得看实际情况。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="jstat">jstat<a href="#jstat" class="hash-link" aria-label="Direct link to jstat" title="Direct link to jstat">​</a></h2>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener noreferrer">jstat</a>也是标准JDK提供的一款监控工具(Java Virtual Machine statistics monitoring tool),可以统计各种指标。既可以连接到本地JVM,也可以连到远程JVM. 查看支持的指标和对应选项可以执行 “<code>jstat -options</code>” 。例如:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------+---------------------------------------------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|     Option      |                          Displays...                          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------+---------------------------------------------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|class            | Statistics on the behavior of the class loader                |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|compiler         | Statistics  on  the behavior of the HotSpot Just-In-Time com- |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                 | piler                                                         |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gc               | Statistics on the behavior of the garbage collected heap      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gccapacity       | Statistics of the capacities of  the  generations  and  their |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                 | corresponding spaces.                                         |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gccause          | Summary  of  garbage collection statistics (same as -gcutil), |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                 | with the cause  of  the  last  and  current  (if  applicable) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                 | garbage collection events.                                    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gcnew            | Statistics of the behavior of the new generation.             |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gcnewcapacity    | Statistics of the sizes of the new generations and its corre- |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                 | sponding spaces.                                              |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gcold            | Statistics of the behavior of the old and  permanent  genera- |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                 | tions.                                                        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gcoldcapacity    | Statistics of the sizes of the old generation.                |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gcpermcapacity   | Statistics of the sizes of the permanent generation.          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|gcutil           | Summary of garbage collection statistics.                     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|printcompilation | Summary of garbage collection statistics.                     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------+---------------------------------------------------------------+</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>jstat 对于快速确定GC行为是否健康非常有用。启动方式为: “<code>jstat -gc -t PID 1s</code>” , 其中,PID 就是要监视的Java进程ID。可以通过<code>jps</code>命令查看正在运行的Java进程列表。</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">jps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jstat -gc -t 2428 1s</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>以上命令的结果, 是 jstat 每秒向标准输出输出一行新内容, 比如:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">Timestamp  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200.0    8448.0 8448.0 8448.0  0.0   67712.0  67712.0   169344.0   169344.0  21248.0 20534.3 3072.0 2807.7     34    0.720  658   133.684  134.404</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">201.0    8448.0 8448.0 8448.0  0.0   67712.0  67712.0   169344.0   169343.2  21248.0 20534.3 3072.0 2807.7     34    0.720  662   134.712  135.432</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">202.0    8448.0 8448.0 8102.5  0.0   67712.0  67598.5   169344.0   169343.6  21248.0 20534.3 3072.0 2807.7     34    0.720  667   135.840  136.559</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">203.0    8448.0 8448.0 8126.3  0.0   67712.0  67702.2   169344.0   169343.6  21248.0 20547.2 3072.0 2807.7     34    0.720  669   136.178  136.898</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">204.0    8448.0 8448.0 8126.3  0.0   67712.0  67702.2   169344.0   169343.6  21248.0 20547.2 3072.0 2807.7     34    0.720  669   136.178  136.898</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">205.0    8448.0 8448.0 8134.6  0.0   67712.0  67712.0   169344.0   169343.5  21248.0 20547.2 3072.0 2807.7     34    0.720  671   136.234  136.954</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">206.0    8448.0 8448.0 8134.6  0.0   67712.0  67712.0   169344.0   169343.5  21248.0 20547.2 3072.0 2807.7     34    0.720  671   136.234  136.954</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">207.0    8448.0 8448.0 8154.8  0.0   67712.0  67712.0   169344.0   169343.5  21248.0 20547.2 3072.0 2807.7     34    0.720  673   136.289  137.009</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">208.0    8448.0 8448.0 8154.8  0.0   67712.0  67712.0   169344.0   169343.5  21248.0 20547.2 3072.0 2807.7     34    0.720  673   136.289  137.009</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>稍微解释一下上面的内容。参考<a href="http://www.manpagez.com/man/1/jstat/" target="_blank" rel="noopener noreferrer">jstat manpage</a>, 我们可以知道:</p>
<ul>
<li>jstat 连接到 JVM 的时间, 是JVM启动后的 200秒。此信息从第一行的 “<strong>Timestamp</strong>” 列得知。继续看下一行, jstat 每秒钟从JVM 接收一次信息, 也就是命令行参数中 “<code>1s</code>” 的含义。</li>
<li>从第一行的 “<strong>YGC</strong>” 列得知年轻代共执行了34次GC, 由 “<strong>FGC</strong>” 列得知整个堆内存已经执行了 658次 full GC。</li>
<li>年轻代的GC耗时总共为<code>0.720 秒</code>, 显示在“<strong>YGCT</strong>” 这一列。</li>
<li>Full GC 的总计耗时为<code>133.684 秒</code>, 由“<strong>FGCT</strong>”列得知。 这立马就吸引了我们的目光, 总的JVM 运行时间只有 200 秒,<strong>但其中有 66% 的部分被 Full GC 消耗了</strong>。</li>
</ul>
<p>再看下一行, 问题就更明显了。</p>
<ul>
<li>在接下来的一秒内共执行了 4 次 Full GC。参见 “<strong>FGC</strong>” 列.</li>
<li>这4次 Full GC 暂停占用了差不多 1秒的时间(根据<strong>FGCT</strong>列的差得知)。与第一行相比, Full GC 耗费了<code>928 毫秒</code>, 即<code>92.8%</code>的时间。</li>
<li>根据 “<strong>OC</strong>和 “<strong>OU</strong>” 列得知,<strong>整个老年代的空间</strong>为<code>169,344.0 KB</code>(“OC“), 在 4 次 Full GC 后依然占用了<code>169,344.2 KB</code>(“OU“)。用了<code>928ms</code>的时间却只释放了 800 字节的内存, 怎么看都觉得很不正常。</li>
</ul>
<p>只看这两行的内容, 就知道程序出了很严重的问题。继续分析下一行, 可以确定问题依然存在,而且变得更糟。</p>
<p>JVM几乎完全卡住了(stalled), 因为GC占用了90%以上的计算资源。GC之后, 所有的老代空间仍然还在占用。事实上, 程序在一分钟以后就挂了, 抛出了 “<a href="https://plumbr.eu/outofmemoryerror/gc-overhead-limit-exceeded" target="_blank" rel="noopener noreferrer">java.lang.OutOfMemoryError: GC overhead limit exceeded</a>” 错误。</p>
<p>可以看到, 通过 jstat 能很快发现对JVM健康极为不利的GC行为。一般来说, 只看 jstat 的输出就能快速发现以下问题:</p>
<ul>
<li>最后一列 “<strong>GCT</strong>”, 与JVM的总运行时间 “<strong>Timestamp</strong>” 的比值, 就是GC 的开销。如果每一秒内, “<strong>GCT</strong>” 的值都会明显增大, 与总运行时间相比, 就暴露出GC开销过大的问题. 不同系统对GC开销有不同的容忍度, 由性能需求决定, 一般来讲, 超过<code>10%</code>的GC开销都是有问题的。</li>
<li>“<strong>YGC</strong>” 和 “<strong>FGC</strong>” 列的快速变化往往也是有问题的征兆。频繁的GC暂停会累积,并导致更多的线程停顿(stop-the-world pauses), 进而影响吞吐量。</li>
<li>如果看到 “<strong>OU</strong>” 列中,老年代的使用量约等于老年代的最大容量(<strong>OC</strong>), 并且不降低的话, 就表示虽然执行了老年代GC, 但基本上属于无效GC。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="gc日志gc-logs">GC日志(GC logs)<a href="#gc日志gc-logs" class="hash-link" aria-label="Direct link to GC日志(GC logs)" title="Direct link to GC日志(GC logs)">​</a></h2>
<p>通过日志内容也可以得到GC相关的信息。因为GC日志模块内置于JVM中, 所以日志中包含了对GC活动最全面的描述。 这就是事实上的标准, 可作为GC性能评估和优化的最真实数据来源。</p>
<p>GC日志一般输出到文件之中, 是纯 text 格式的, 当然也可以打印到控制台。有多个可以控制GC日志的JVM参数。例如,可以打印每次GC的持续时间, 以及程序暂停时间(<code>-XX:+PrintGCApplicationStoppedTime</code>), 还有GC清理了多少引用类型(<code>-XX:+PrintReferenceGC</code>)。</p>
<p>要打印GC日志, 需要在启动脚本中指定以下参数:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:&lt;filename&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>以上参数指示JVM: 将所有GC事件打印到日志文件中, 输出每次GC的日期和时间戳。不同GC算法输出的内容略有不同. ParallelGC 输出的日志类似这样:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">199.879: [Full GC (Ergonomics) [PSYoungGen: 64000K-&gt;63998K(74240K)] [ParOldGen: 169318K-&gt;169318K(169472K)] 233318K-&gt;233317K(243712K), [Metaspace: 20427K-&gt;20427K(1067008K)], 0.1473386 secs] [Times: user=0.43 sys=0.01, real=0.15 secs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200.027: [Full GC (Ergonomics) [PSYoungGen: 64000K-&gt;63998K(74240K)] [ParOldGen: 169318K-&gt;169318K(169472K)] 233318K-&gt;233317K(243712K), [Metaspace: 20427K-&gt;20427K(1067008K)], 0.1567794 secs] [Times: user=0.41 sys=0.00, real=0.16 secs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200.184: [Full GC (Ergonomics) [PSYoungGen: 64000K-&gt;63998K(74240K)] [ParOldGen: 169318K-&gt;169318K(169472K)] 233318K-&gt;233317K(243712K), [Metaspace: 20427K-&gt;20427K(1067008K)], 0.1621946 secs] [Times: user=0.43 sys=0.00, real=0.16 secs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200.346: [Full GC (Ergonomics) [PSYoungGen: 64000K-&gt;63998K(74240K)] [ParOldGen: 169318K-&gt;169318K(169472K)] 233318K-&gt;233317K(243712K), [Metaspace: 20427K-&gt;20427K(1067008K)], 0.1547695 secs] [Times: user=0.41 sys=0.00, real=0.15 secs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200.502: [Full GC (Ergonomics) [PSYoungGen: 64000K-&gt;63999K(74240K)] [ParOldGen: 169318K-&gt;169318K(169472K)] 233318K-&gt;233317K(243712K), [Metaspace: 20427K-&gt;20427K(1067008K)], 0.1563071 secs] [Times: user=0.42 sys=0.01, real=0.16 secs]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200.659: [Full GC (Ergonomics) [PSYoungGen: 64000K-&gt;63999K(74240K)] [ParOldGen: 169318K-&gt;169318K(169472K)] 233318K-&gt;233317K(243712K), [Metaspace: 20427K-&gt;20427K(1067008K)], 0.1538778 secs] [Times: user=0.42 sys=0.00, real=0.16 secs]</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 “04. GC算法:实现篇” 中详细介绍了这些格式, 如果对此不了解, 可以先阅读该章节。</p>
<p>分析以上日志内容, 可以得知:</p>
<ul>
<li>这部分日志截取自JVM启动后200秒左右。</li>
<li>日志片段中显示, 在<code>780毫秒</code>以内, 因为垃圾回收 导致了5次 Full GC 暂停(去掉第六次暂停,这样更精确一些)。</li>
<li>这些暂停事件的总持续时间是<code>777毫秒</code>, 占总运行时间的<strong>99.6%</strong>。</li>
<li>在GC完成之后, 几乎所有的老年代空间(<code>169,472 KB</code>)依然被占用(<code>169,318 KB</code>)。</li>
</ul>
<p>通过日志信息可以确定, 该应用的GC情况非常糟糕。JVM几乎完全停滞, 因为GC占用了超过<code>99%</code>的CPU时间。 而GC的结果是, 老年代空间仍然被占满, 这进一步肯定了我们的结论。 示例程序和jstat 小节中的是同一个, 几分钟之后系统就挂了, 抛出 “<a href="https://plumbr.eu/outofmemoryerror/gc-overhead-limit-exceeded" target="_blank" rel="noopener noreferrer">java.lang.OutOfMemoryError: GC overhead limit exceeded</a>” 错误, 不用说, 问题是很严重的.</p>
<p>从此示例可以看出, GC日志对监控GC行为和JVM是否处于健康状态非常有用。一般情况下, 查看 GC 日志就可以快速确定以下症状:</p>
<ul>
<li>GC开销太大。如果GC暂停的总时间很长, 就会损害系统的吞吐量。不同的系统允许不同比例的GC开销, 但一般认为, 正常范围在<code>10%</code>以内。</li>
<li>极个别的GC事件暂停时间过长。当某次GC暂停时间太长, 就会影响系统的延迟指标. 如果延迟指标规定交易必须在<code>1,000 ms</code>内完成, 那就不能容忍任何超过<code>1000毫秒</code>的GC暂停。</li>
<li>老年代的使用量超过限制。如果老年代空间在 Full GC 之后仍然接近全满, 那么GC就成为了性能瓶颈, 可能是内存太小, 也可能是存在内存泄漏。这种症状会让GC的开销暴增。</li>
</ul>
<p>可以看到,GC日志中的信息非常详细。但除了这些简单的小程序, 生产系统一般都会生成大量的GC日志, 纯靠人工是很难阅读和进行解析的。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="gcviewer">GCViewer<a href="#gcviewer" class="hash-link" aria-label="Direct link to GCViewer" title="Direct link to GCViewer">​</a></h2>
<p>我们可以自己编写解析器, 来将庞大的GC日志解析为直观易读的图形信息。 但很多时候自己写程序也不是个好办法, 因为各种GC算法的复杂性, 导致日志信息格式互相之间不太兼容。那么神器来了:<a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener noreferrer">GCViewer</a>。</p>
<p><a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener noreferrer">GCViewer</a>是一款开源的GC日志分析工具。项目的 GitHub 主页对各项指标进行了完整的描述. 下面我们介绍最常用的一些指标。</p>
<p>第一步是获取GC日志文件。这些日志文件要能够反映系统在性能调优时的具体场景. 假若运营部门(operational department)反馈: 每周五下午,系统就运行缓慢, 不管GC是不是主要原因, 分析周一早晨的日志是没有多少意义的。</p>
<p>获取到日志文件之后, 就可以用 GCViewer 进行分析, 大致会看到类似下面的图形界面:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224526.png" alt="" class="img_kGBN"></p>
<p>使用的命令行大致如下:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -jar gcviewer_1.3.4.jar gc.log</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当然, 如果不想打开程序界面,也可以在后面加上其他参数,直接将分析结果输出到文件。</p>
<p>命令大致如下:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -jar gcviewer_1.3.4.jar gc.log summary.csv chart.png</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>以上命令将信息汇总到当前目录下的 Excel 文件<code>summary.csv</code>之中, 将图形信息保存为<code>chart.png</code>文件。</p>
<p>点击下载<!-- -->:gcviewer<!-- -->的jar包及使用示例</p>
<p>上图中, Chart 区域是对GC事件的图形化展示。包括各个内存池的大小和GC事件。上图中, 只有两个可视化指标: 蓝色线条表示堆内存的使用情况, 黑色的Bar则表示每次GC暂停时间的长短。</p>
<p>从图中可以看到, 内存使用量增长很快。一分钟左右就达到了堆内存的最大值. 堆内存几乎全部被消耗, 不能顺利分配新对象, 并引发频繁的 Full GC 事件. 这说明程序可能存在内存泄露, 或者启动时指定的内存空间不足。</p>
<p>从图中还可以看到 GC暂停的频率和持续时间。<code>30秒</code>之后, GC几乎不间断地运行,最长的暂停时间超过<code>1.4秒</code>。</p>
<p>在右边有三个选项卡。“<code>**Summary**</code>(摘要)” 中比较有用的是 “<code>Throughput</code>”(吞吐量百分比) 和 “<code>Number of GC pauses</code>”(GC暂停的次数), 以及“<code>Number of full GC pauses</code>”(Full GC 暂停的次数). 吞吐量显示了有效工作的时间比例, 剩下的部分就是GC的消耗。</p>
<p>以上示例中的吞吐量为<code>**6.28%**</code>。这意味着有<code>**93.72%**</code></p>
<p>下一个有意思的地方是“<strong>Pause</strong>”(暂停)选项卡:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224540.png" alt="" class="img_kGBN"></p>
<p>“<code>Pause</code>” 展示了GC暂停的总时间,平均值,最小值和最大值, 并且将 total 与minor/major 暂停分开统计。如果要优化程序的延迟指标, 这些统计可以很快判断出暂停时间是否过长。另外, 我们可以得出明确的信息: 累计暂停时间为<code>634.59 秒</code>, GC暂停的总次数为<code>3,938 次</code>, 这在<code>11分钟/660秒</code>的总运行时间里那不是一般的高。</p>
<p>更详细的GC暂停汇总信息, 请查看主界面中的 “<strong>Event details</strong>” 标签:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224553.png" alt="" class="img_kGBN"></p>
<p>从“<strong>Event details</strong>” 标签中, 可以看到日志中所有重要的GC事件汇总:<code>普通GC停顿</code>和<code>Full GC 停顿次数</code>, 以及<code>并发执行数</code>,<code>非 stop-the-world 事件</code>等。此示例中, 可以看到一个明显的地方, Full GC 暂停严重影响了吞吐量和延迟, 依据是:<code>3,928 次 Full GC</code>, 暂停了<code>634秒</code>。</p>
<p>可以看到, GCViewer 能用图形界面快速展现异常的GC行为。一般来说, 图像化信息能迅速揭示以下症状:</p>
<ul>
<li>低吞吐量。当应用的吞吐量下降到不能容忍的地步时, 有用工作的总时间就大量减少. 具体有多大的 “容忍度”(tolerable) 取决于具体场景。按照经验, 低于 90% 的有效时间就值得警惕了, 可能需要好好优化下GC。</li>
<li>单次GC的暂停时间过长。只要有一次GC停顿时间过长,就会影响程序的延迟指标. 例如, 延迟需求规定必须在 1000 ms以内完成交易, 那就不能容忍任何一次GC暂停超过1000毫秒。</li>
<li>堆内存使用率过高。如果老年代空间在 Full GC 之后仍然接近全满, 程序性能就会大幅降低, 可能是资源不足或者内存泄漏。这种症状会对吞吐量产生严重影响。</li>
</ul>
<p>业界良心 —— 图形化展示的GC日志信息绝对是我们重磅推荐的。不用去阅读冗长而又复杂的GC日志,通过容易理解的图形, 也可以得到同样的信息。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="分析器profilers">分析器(Profilers)<a href="#分析器profilers" class="hash-link" aria-label="Direct link to 分析器(Profilers)" title="Direct link to 分析器(Profilers)">​</a></h2>
<p>下面介绍分析器(<a href="http://zeroturnaround.com/rebellabs/developer-productivity-report-2015-java-performance-survey-results/3/" target="_blank" rel="noopener noreferrer">profilers</a>, Oracle官方翻译是:<code>抽样器</code>)。相对于前面的工具, 分析器只关心GC中的一部分领域. 本节我们也只关注分析器相关的GC功能。</p>
<p>首先警告 —— 不要认为分析器适用于所有的场景。分析器有时确实作用很大, 比如检测代码中的CPU热点时。但某些情况使用分析器不一定是个好方案。</p>
<p>对GC调优来说也是一样的。要检测是否因为GC而引起延迟或吞吐量问题时, 不需要使用分析器. 前面提到的工具(<code>jstat</code>或 原生/可视化GC日志)就能更好更快地检测出是否存在GC问题. 特别是从生产环境中收集性能数据时, 最好不要使用分析器, 因为性能开销非常大。</p>
<p>如果确实需要对GC进行优化, 那么分析器就可以派上用场了, 可以对 Object 的创建信息一目了然. 换个角度看, 如果GC暂停的原因不在某个内存池中, 那就只会是因为创建对象太多了。 所有分析器都能够跟踪对象分配(via allocation profiling), 根据内存分配的轨迹, 让你知道<strong>实际驻留在内存中的是哪些对象</strong>。</p>
<p>分配分析能定位到在哪个地方创建了大量的对象. 使用分析器辅助进行GC调优的好处是, 能确定哪种类型的对象最占用内存, 以及哪些线程创建了最多的对象。</p>
<p>下面我们通过实例介绍3种分配分析器:<code>**hprof**</code>,<code>**JVisualV**</code><strong>M</strong>和<code>**AProf**</code>。实际上还有很多分析器可供选择, 有商业产品,也有免费工具, 但其功能和应用基本上都是类似的。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="hprof">hprof<a href="#hprof" class="hash-link" aria-label="Direct link to hprof" title="Direct link to hprof">​</a></h3>
<p><a href="http://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html" target="_blank" rel="noopener noreferrer">hprof 分析器</a>内置于JDK之中。 在各种环境下都可以使用, 一般优先使用这款工具。</p>
<p>要让<code>hprof</code>和程序一起运行, 需要修改启动脚本, 类似这样:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -agentlib:hprof=heap=sites com.yourcompany.YourApplication</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在程序退出时,会将分配信息dump(转储)到工作目录下的<code>java.hprof.txt</code>文件中。使用文本编辑器打开, 并搜索 “<strong>SITES BEGIN</strong>” 关键字, 可以看到:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">SITES BEGIN (ordered by live bytes) Tue Dec  8 11:16:15 2015</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          percent          live          alloc&#x27;ed  stack class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> rank   self  accum     bytes objs     bytes  objs trace name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1  64.43% 4.43%   8370336 20121  27513408 66138 302116 int[]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2  3.26% 88.49%    482976 20124   1587696 66154 302104 java.util.ArrayList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    3  1.76% 88.74%    241704 20121   1587312 66138 302115 eu.plumbr.demo.largeheap.ClonableClass0006</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ... 部分省略 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SITES END</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从以上片段可以看到, allocations 是根据每次创建的对象数量来排序的。第一行显示所有对象中有<code>**64.43%**</code>的对象是整型数组(<code>int[]</code>), 在标识为<code>302116</code>的位置创建。搜索 “<strong>TRACE 302116</strong>” 可以看到:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">TRACE 302116:   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    eu.plumbr.demo.largeheap.ClonableClass0006.&lt;init&gt;(GeneratorClass.java:11)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sun.reflect.GeneratedConstructorAccessor7.newInstance(&lt;Unknown Source&gt;:Unknown line)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    java.lang.reflect.Constructor.newInstance(Constructor.java:422)</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>现在, 知道有<code>64.43%</code>的对象是整数数组, 在<code>ClonableClass0006</code>类的构造函数中, 第11行的位置, 接下来就可以优化代码, 以减少GC的压力。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="java-visualvm">Java VisualVM<a href="#java-visualvm" class="hash-link" aria-label="Direct link to Java VisualVM" title="Direct link to Java VisualVM">​</a></h3>
<p>本章前面的第一部分, 在监控 JVM 的GC行为工具时介绍了 JVisualVM , 本节介  绍其在分配分析上的应用。</p>
<p>JVisualVM 通过GUI的方式连接到正在运行的JVM。 连接上目标JVM之后 :</p>
<ol>
<li>打开 “工具” –&gt; “选项” 菜单, 点击**性能分析(Profiler)**标签, 新增配置, 选择 Profiler 内存, 确保勾选了 “Record allocations stack traces”(记录分配栈跟踪)。</li>
<li>勾选 “Settings”(设置) 复选框, 在内存设置标签下,修改预设配置。</li>
<li>点击 “Memory”(内存) 按钮开始进行内存分析。</li>
<li>让程序运行一段时间,以收集关于对象分配的足够信息。</li>
<li>单击下方的 “Snapshot”(快照) 按钮。可以获取收集到的快照信息。</li>
</ol>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224729.png" alt="" class="img_kGBN"></p>
<p>完成上面的步骤后, 可以得到类似这样的信息:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224743.png" alt="" class="img_kGBN"></p>
<p>上图按照每个类被创建的对象数量多少来排序。看第一行可以知道, 创建的最多的对象是<code>int[]</code>数组. 鼠标右键单击这行, 就可以看到这些对象都在哪些地方创建的:</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404224753.png" alt="" class="img_kGBN"></p>
<p>与<code>hprof</code>相比, JVisualVM 更加容易使用 —— 比如上面的截图中, 在一个地方就可以看到所有<code>int[]</code>的分配信息, 所以多次在同一处代码进行分配的情况就很容易发现。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="aprof">AProf<a href="#aprof" class="hash-link" aria-label="Direct link to AProf" title="Direct link to AProf">​</a></h3>
<p>最重要的一款分析器,是由 Devexperts 开发的<a href="https://code.devexperts.com/display/AProf/About+Aprof" target="_blank" rel="noopener noreferrer"><strong>AProf</strong></a>。 内存分配分析器 AProf 也被打包为 Java agent 的形式。</p>
<p>用 AProf 分析应用程序, 需要修改 JVM 启动脚本,类似这样:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">java -javaagent:/path-to/aprof.jar com.yourcompany.YourApplication</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>重启应用之后, 工作目录下会生成一个<code>aprof.txt</code>文件。此文件每分钟更新一次, 包含这样的信息:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">========================================================================================================================</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TOTAL allocation dump for 91,289 ms (0h01m31s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Allocated 1,769,670,584 bytes in 24,868,088 objects of 425 classes in 2,127 locations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">========================================================================================================================</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Top allocation-inducing locations with the data types allocated from them</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">eu.plumbr.demo.largeheap.ManyTargetsGarbageProducer.newRandomClassObject: 1,423,675,776 (80.44%) bytes in 17,113,721 (68.81%) objects (avg size 83 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[]: 711,322,976 (40.19%) bytes in 1,709,911 (6.87%) objects (avg size 416 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char[]: 369,550,816 (20.88%) bytes in 5,132,759 (20.63%) objects (avg size 72 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    java.lang.reflect.Constructor: 136,800,000 (7.73%) bytes in 1,710,000 (6.87%) objects (avg size 80 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    java.lang.Object[]: 41,079,872 (2.32%) bytes in 1,710,712 (6.87%) objects (avg size 24 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    java.lang.String: 41,063,496 (2.32%) bytes in 1,710,979 (6.88%) objects (avg size 24 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    java.util.ArrayList: 41,050,680 (2.31%) bytes in 1,710,445 (6.87%) objects (avg size 24 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ... cut for brevity ...</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上面的输出是按照<code>size</code>进行排序的。可以看出,<code>80.44%</code>的 bytes 和<code>68.81%</code>的 objects 是在<code>ManyTargetsGarbageProducer.newRandomClassObject()</code>方法中分配的。 其中,**int[]**数组占用了<code>40.19%</code>的内存, 是最大的一个。</p>
<p>继续往下看, 会发现<code>allocation traces</code>(分配痕迹)相关的内容, 也是以 allocation size 排序的:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">Top allocated data types with reverse location traces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int[]: 725,306,304 (40.98%) bytes in 1,954,234 (7.85%) objects (avg size 371 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    eu.plumbr.demo.largeheap.ClonableClass0006.: 38,357,696 (2.16%) bytes in 92,206 (0.37%) objects (avg size 416 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        java.lang.reflect.Constructor.newInstance: 38,357,696 (2.16%) bytes in 92,206 (0.37%) objects (avg size 416 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            eu.plumbr.demo.largeheap.ManyTargetsGarbageProducer.newRandomClassObject: 38,357,280 (2.16%) bytes in 92,205 (0.37%) objects (avg size 416 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            java.lang.reflect.Constructor.newInstance: 416 (0.00%) bytes in 1 (0.00%) objects (avg size 416 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">... cut for brevity ...</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>可以看到,<code>int[]</code>数组的分配, 在<code>ClonableClass0006</code>构造函数中继续增大。</p>
<p>和其他工具一样,<code>AProf</code>揭露了 分配的大小以及位置信息(<code>allocation size and locations</code>), 从而能够快速找到最耗内存的部分。在我们看来,<strong>AProf</strong>是最有用的分配分析器, 因为它只专注于内存分配, 所以做得最好。 当然, 这款工具是开源免费的, 资源开销也最小。</p>
<p>请继续阅读下一章:7. GC 调优(实战篇) - GC参考手册</p>
<p>原文链接:<a href="https://plumbr.eu/handbook/gc-tuning-measuring" target="_blank" rel="noopener noreferrer">GC Tuning: Tooling</a></p>
<p>翻译时间: 2016年02月06日</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="Direct link to 参考文章" title="Direct link to 参考文章">​</a></h2>
<p><code>https://segmentfault.com/a/1190000009707894</code></p>
<p><code>https://www.cnblogs.com/hysum/p/7100874.html</code></p>
<p><code>http://c.biancheng.net/view/939.html</code></p>
<p><code>https://www.runoob.com/</code></p>
<p><code>https://blog.csdn.net/android_hl/article/details/53228348</code></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/JVM/深入理解JVM虚拟机：GC调优思路与常用工具.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：再谈四种引用及GC实践"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">深入理解JVM虚拟机：再谈四种引用及GC实践</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：Java的编译期优化与运行期优化"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">深入理解JVM虚拟机：Java的编译期优化与运行期优化</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#核心概念core-concepts" class="table-of-contents__link toc-highlight">核心概念(Core Concepts)</a></li><li><a href="#相关示例" class="table-of-contents__link toc-highlight">相关示例</a></li><li><a href="#6-gc-调优工具篇---gc参考手册" class="table-of-contents__link toc-highlight">6. GC 调优(工具篇) - GC参考手册</a></li><li><a href="#jmx-api" class="table-of-contents__link toc-highlight">JMX API</a></li><li><a href="#jvisualvm" class="table-of-contents__link toc-highlight">JVisualVM</a></li><li><a href="#jstat" class="table-of-contents__link toc-highlight">jstat</a></li><li><a href="#gc日志gc-logs" class="table-of-contents__link toc-highlight">GC日志(GC logs)</a></li><li><a href="#gcviewer" class="table-of-contents__link toc-highlight">GCViewer</a></li><li><a href="#分析器profilers" class="table-of-contents__link toc-highlight">分析器(Profilers)</a><ul><li><a href="#hprof" class="table-of-contents__link toc-highlight">hprof</a></li><li><a href="#java-visualvm" class="table-of-contents__link toc-highlight">Java VisualVM</a></li><li><a href="#aprof" class="table-of-contents__link toc-highlight">AProf</a></li></ul></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理 | Tommy"><meta data-rh="true" name="description" content="本文参考多篇优质技术博客，参考文章请在文末查看"><meta data-rh="true" property="og:description" content="本文参考多篇优质技术博客，参考文章请在文末查看"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合类总结">Java集合类总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：深入理解LinkedHashMap和LRU缓存">Java集合详解：深入理解LinkedHashMap和LRU缓存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理">Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable">Java集合详解：HashMap和HashTable</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：HashSet，TreeSet与LinkedHashSet">Java集合详解：HashSet，TreeSet与LinkedHashSet</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器">Java集合详解：Iterator，fail-fast机制与比较器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Java集合类细节精讲">Java集合详解：Java集合类细节精讲</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Queue和LinkedList">Java集  合详解：Queue和LinkedList</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：TreeMap和红黑树">Java集合详解：TreeMap和红黑树</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">集合</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理</h1></header><p>本文参考多篇优质技术博客，参考文章请在文末查看</p>
<p>《Java集合详解系列》是我在完成夯实Java基础篇的系列博客后准备开始整理的新系列文章。
为了更好地诠释知识点，形成体系文章，本系列文章整理了很多优质的博客内容，如有侵权请联系我，一定删除。</p>
<p>这些文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star、fork哈</p>
<p>本系列文章将整理于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>//一般讨论集合类无非就是。这里的两种数组类型更是如此
// 1底层数据结构
// 2增删改查方式
// 3初始容量，扩容方式，扩容时机。
// 4线程安全与否
// 5是否允许空，是否允许重复，是否有序</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="arraylist">ArrayList<a href="#arraylist" class="hash-link" aria-label="Direct link to ArrayList" title="Direct link to ArrayList">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="arraylist概述">ArrayList概述<a href="#arraylist概述" class="hash-link" aria-label="Direct link to ArrayList概述" title="Direct link to ArrayList概述">​</a></h3>
<p>ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p>
<p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。</p>
<p>在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p>
<p>注意，ArrayList实现不是同步的。如果多个  线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：</p>
<p>List list = Collections.synchronizedList(new ArrayList(...));</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="arraylist的继承关系">ArrayList的继承关系<a href="#arraylist的继承关系" class="hash-link" aria-label="Direct link to ArrayList的继承关系" title="Direct link to ArrayList的继承关系">​</a></h3>
<p>ArrayList继承AbstractList抽象父类，实现了List接口（规定了List的操作规范）、RandomAccess（可随机访问）、Cloneable（可拷贝）、Serializable（可序列化）。</p>
<p><img loading="lazy" src="https://img-blog.csdn.net/2018081819553095?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjM3ODkxNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" class="img_kGBN"></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="底层数据结构">底层数据结构<a href="#底层数据结构" class="hash-link" aria-label="Direct link to 底层数据结构" title="Direct link to 底层数据结构">​</a></h3>
<p>ArrayList的底层是一个object数组，并且由trasient修饰。</p>
<p>//transient Object[] elementData; //</p>
<p>non-private to simplify nested class access
//ArrayList底层数组不会参与序列化，而是使用另外的序列化方式。</p>
<p>//使用writeobject方法进行序列化,具体为什么这么做欢迎查看我之前的关于序列化的文章</p>
<p>//总结一下就是只复制数组中有值的位置，其他未赋值的位置不进行序列化，可以节省空间。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        private void writeObject(java.io.ObjectOutputStream s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        throws java.io.IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // Write out element count, and any hidden stuff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            int expectedModCount = modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            s.defaultWriteObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // Write out size as capacity for behavioural compatibility with clone()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            s.writeInt(size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // Write out all elements in the proper order.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            for (int i=0; i&lt;size; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                s.writeObject(elementData[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (modCount != expectedModCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="增删改查">增删改查<a href="#增删改查" class="hash-link" aria-label="Direct link to 增删改查" title="Direct link to 增删改查">​</a></h3>
<p>//增删改查</p>
<p>添加元素时，首先判断索引是否合法，然后检测是否需要扩容，最后使用System.arraycopy方法来完成数组的复制。</p>
<p>这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组)里面的数据复制到elementData数组中。这里就稍微介绍下System.arraycopy()，因为下面还将大量用到该方法</p>
<p>。该方法的原型为：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)。</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>它的根本目的就是进行数组元素的复制。即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p>
<p>将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        public void add(int index, E element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            rangeCheckForAdd(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            System.arraycopy(elementData, index, elementData, index + 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    size - index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            elementData[index] = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>删除元素时，同样判断索引是否和法，删除的方式是把被删除元素右边的元素左移，方法同样是使用System.arraycopy进行拷贝。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        public E remove(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            rangeCheck(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            E oldValue = elementData(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            int numMoved = size - index - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (numMoved &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                System.arraycopy(elementData, index+1, elementData, index,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                        numMoved);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            elementData[--size] = null; // clear to let GC do its work</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>ArrayList提供一个清空数组的办法，方法是将所有元素置为null，这样就可以让GC自动回收掉没有被引用的元素了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //         * Removes all of the elements from this list.  The list will</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //         * be empty after this call returns.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        public void clear() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // clear to let GC do its work</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            for (int i = 0; i &lt; size; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                elementData[i] = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>修改元素时，只需要检查下标即可进行修改操作。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        public E set(int index, E element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            rangeCheck(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            E oldValue = elementData(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            elementData[index] = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        public E get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            rangeCheck(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            return elementData(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述方法都使用了rangeCheck方法，其实就是简单地检查下标而已。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        private void rangeCheck(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (index &gt;= size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="modcount">modCount<a href="#modcount" class="hash-link" aria-label="Direct link to modCount" title="Direct link to modCount">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        protected transient int modCount = 0;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由以上代码可以看出，在一个迭代器初始的时候会赋予它调用这个迭代器的对象的mCount，如何在迭代器遍历的过程中，一旦发现这个对象的mcount和迭代器中存储的mcount不一样那就抛异常</p>
<blockquote>
<p>好的，下面是这个的完整解释
Fail-Fast 机制
我们知道 java.util.ArrayList 不是线程安全的，ArrayList，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p>
<p>这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对ArrayList 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。</p>
<p>在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 ArrayList。</p>
<p>所以在这里和大家建议，当大家遍历那些非线程安全的数据结构时，尽量使用迭代器</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="初始容量和扩容方式">初始容量和扩容方式<a href="#初始容量和扩容方式" class="hash-link" aria-label="Direct link to 初始容量和扩容方式" title="Direct link to 初始容量和扩容方式">​</a></h3>
<p>初始容量是10，下面是扩容方法。
首先先取</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //private static final int DEFAULT_CAPACITY = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 扩容发生在add元素时，传入当前元素容量加一</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elementData[size++] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    这里给出初始化时的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    这说明：如果数组还是初始数组，那么最小的扩容大小就是size+1和初始容量中较大的一个，初始容量为10。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    因为addall方法也会调用该函数，所以此时需要做判断。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void ensureCapacityInternal(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ensureExplicitCapacity(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //开始精确地扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void ensureExplicitCapacity(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            如果此时扩容容量大于数组长度吗，执行grow，否则不执行。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (minCapacity - elementData.length &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            grow(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>真正执行扩容的方法grow</p>
<p>扩容方式是让新容量等于旧容量的1.5被。</p>
<p>当新容量大于最大数组容量时，执行大数扩容</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        private void grow(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            int oldCapacity = elementData.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (newCapacity - minCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                newCapacity = minCapacity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                newCapacity = hugeCapacity(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // minCapacity is usually close to size, so this is a win:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            elementData = Arrays.copyOf(elementData, newCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当新容量大于最大数组长度，有两种情况，一种是溢出，抛异常，一种是没溢出，返回整数的最大值。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    private static int hugeCapacity(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (minCapacity &lt; 0) // overflow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new OutOfMemoryError();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Integer.MAX_VALUE :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MAX_ARRAY_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。</p>
<p>处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize()方法来实现。该方法可以最小化ArrayList实例的存储量。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public void trimToSize() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int oldCapacity = elementData.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (size &lt; oldCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elementData = Arrays.copyOf(elementData, size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="线程安全">线程安全<a href="#线程安全" class="hash-link" aria-label="Direct link to 线程安全" title="Direct link to 线程安全">​</a></h3>
<p>ArrayList是线程不安全的。在其迭代器iteator中，如果有多线程操作导致modcount改变，会执行fastfail。抛出异常。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">        final void checkForComodification() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (modCount != expectedModCount)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="vector">Vector<a href="#vector" class="hash-link" aria-label="Direct link to Vector" title="Direct link to Vector">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="vector简介">Vector简介<a href="#vector简介" class="hash-link" aria-label="Direct link to Vector简介" title="Direct link to Vector简介">​</a></h3>
<p>Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。</p>
<p>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍  历等功能。</p>
<p>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。</p>
<p>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。</p>
<p>vector底层数组不加transient，序列化时会全部复制</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">     protected Object[] elementData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private void writeObject(java.io.ObjectOutputStream s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            throws java.io.IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            final java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            final Object[] data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            synchronized (this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                fields.put(&quot;capacityIncrement&quot;, capacityIncrement);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                fields.put(&quot;elementCount&quot;, elementCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                data = elementData.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            fields.put(&quot;elementData&quot;, data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            s.writeFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Vector除了iterator外还提供Enumeration枚举方法，不过现在比较过时。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        public Enumeration&lt;E&gt; elements() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            return new Enumeration&lt;E&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                public boolean hasMoreElements() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    return count &lt; elementCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                public E nextElement() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    synchronized (Vector.this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                        if (count &lt; elementCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                            return elementData(count++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    throw new NoSuchElementException(&quot;Vector Enumeration&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="增删改查-1">增删改查<a href="#增删改查-1" class="hash-link" aria-label="Direct link to 增删改查" title="Direct link to 增删改查">​</a></h3>
<p>vector的增删改查既提供了自己的实现，也继承了abstractList抽象类的部分方法。
下面的方法是vector自己实现的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    public synchronized E elementAt(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        if (index &gt;= elementCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        return elementData(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    public synchronized void setElementAt(E obj, int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        if (index &gt;= elementCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    elementCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        elementData[index] = obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    public synchronized void removeElementAt(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        if (index &gt;= elementCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    elementCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        else if (index &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            throw new ArrayIndexOutOfBoundsException(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        int j = elementCount - index - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        if (j &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            System.arraycopy(elementData, index + 1, elementData, index, j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        elementCount--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        elementData[elementCount] = null; /* to let gc do its work */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    public synchronized void insertElementAt(E obj, int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        if (index &gt; elementCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            throw new ArrayIndexOutOfBoundsException(index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    + &quot; &gt; &quot; + elementCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        ensureCapacityHelper(elementCount + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        elementData[index] = obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        elementCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    public synchronized void addElement(E obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        ensureCapacityHelper(elementCount + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        elementData[elementCount++] = obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="初始容量和扩容">初始容量和扩容<a href="#初始容量和扩容" class="hash-link" aria-label="Direct link to 初始容量和扩容" title="Direct link to 初始容量和扩容">​</a></h3>
<p>扩容方式与ArrayList基本一样，但是扩容时不是1.5倍扩容，而是有一个扩容增量。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //    protected int elementCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    protected int capacityIncrement;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    public Vector() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        this(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //        public synchronized void ensureCapacity(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (minCapacity &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                ensureCapacityHelper(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private void ensureCapacityHelper(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (minCapacity - elementData.length &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                grow(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private void grow(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            int oldCapacity = elementData.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                    capacityIncrement : oldCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (newCapacity - minCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                newCapacity = minCapacity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                newCapacity = hugeCapacity(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            elementData = Arrays.copyOf(elementData, newCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>下面是扩容过程示意图</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404145205.png" alt="" class="img_kGBN"></p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404145237.png" alt="" class="img_kGBN"></p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404145305.png" alt="" class="img_kGBN"></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="线程安全-1">线程安全<a href="#线程安全-1" class="hash-link" aria-label="Direct link to 线程安全" title="Direct link to 线程安全">​</a></h3>
<p>vector大部分方法都使用了synchronized修饰符，所以他是线层安全的集合类。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="stack">Stack<a href="#stack" class="hash-link" aria-label="Direct link to Stack" title="Direct link to Stack">​</a></h2>
<p>我们最常用的数据结构之一大概就是stack了。在实际的程序执行，方法调用的过程中都离不开stack。那么，在一个成熟的类库里面，它的实现是怎么样的呢？也许平时我们实践的时候也会尝试着去写一个stack的实现玩玩。这里，我们就仔细的分析一下jdk里的详细实现。</p>
<h1>Stack</h1>
<p>如果我们去查jdk的文档，我们会发现stack是在java.util这个包里。它对应的一个大致的类关系图如下：</p>
<p><img loading="lazy" src="http://dl.iteye.com/upload/attachment/0081/2496/006da63f-388e-3669-b57f-1cdd1909d5f8.jpg" alt="" class="img_kGBN"></p>
<p>通过继承Vector类，Stack类可以很容易的实现他本身的功能。因为大部分的功能在Vector里面已经提供支持了。
在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。</p>
<p>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：</p>
<blockquote>
<p>empty()</p>
<p>测试堆栈是否为空。</p>
<p>peek()</p>
<p>查看堆栈顶部的对象，但不从堆栈中移除它。</p>
<p>pop()</p>
<p>移除堆栈顶部的对象，并作为此函数的值返回该对象。</p>
<p>push(E item)</p>
<p>把项压入堆栈顶部。</p>
<p>search(Object o)</p>
<p>返回对象在堆栈中的位置，以 1 为基数。</p>
</blockquote>
<p>Stack继承Vector，他对Vector进行了简单的扩展：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Stack&lt;E&gt; extends Vector&lt;E&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Stack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Stack() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  push函数：将元素存入栈顶</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public E push(E item) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将元素存入栈顶。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // addElement()的实现在Vector.java中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addElement(item);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pop函数：返回栈顶元素，并将其从栈中删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized E pop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        E    obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int    len = size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        obj = peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 删除栈顶元素，removeElementAt()的实现在Vector.java中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        removeElementAt(len - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * peek函数：返回栈顶元素，不执行删除操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized E peek() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int    len = size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (len == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new EmptyStackException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回栈顶元素，elementAt()具体实现在Vector.java中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return elementAt(len - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 栈是否为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return size() == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  查找“元素o”在栈中的位置：由栈底向栈顶方向数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized int search(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取元素索引，elementAt()具体实现在Vector.java中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int i = lastIndexOf(o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return size() - i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Stack的源码很多都是基于Vector，所以这里不再累述</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="三个集合类之间的区别">三个集合类之间的区别<a href="#三个集合类之间的区别" class="hash-link" aria-label="Direct link to 三个集合类之间的区别" title="Direct link to 三个集合类之间的区别">​</a></h2>
<p>ArrayList的优缺点</p>
<p>从上面的几个过程总结一下ArrayList的优缺点。ArrayList的优点如下：</p>
<blockquote>
<p>1、ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快</p>
<p>2、ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已</p>
</blockquote>
<p>不过ArrayList的 缺点也十分明显：</p>
<blockquote>
<p>1、删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p>
<p>2、插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p>
<p>因此，ArrayList比较适合顺序添加、随机访问的场景。</p>
</blockquote>
<p>ArrayList和Vector的区别</p>
<blockquote>
<p>ArrayList是线程非安全的，这很明显，因为ArrayList中所有的方法都不是同步的，在并发下一定会出现线程安全问题。那么我们想要使用ArrayList并且让它线程安全怎么办？一个方法是用Collections.synchronizedList方法把你的ArrayList变成一个线程安全的List，比如：</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">     List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     synchronizedList.add(&quot;aaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     synchronizedList.add(&quot;bbb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     for (int i = 0; i &lt; synchronizedList.size(); i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         System.out.println(synchronizedList.get(i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>另一个方法就是Vector，它是ArrayList的线程安全版本，其实现90%和ArrayList都完全一样，区别在于：</p>
<blockquote>
<p>1、Vector是线程安全的，ArrayList是线程非安全的</p>
<p>2、Vector可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，那么就给原数组大小*2，源代码是这样的：</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                     capacityIncrement : oldCapacity);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="Direct link to 参考文章" title="Direct link to 参考文章">​</a></h2>
<p><a href="https://www.cnblogs.com/williamjie/p/11158523.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/williamjie/p/11158523.html</a></p>
<p><a href="https://www.cnblogs.com/shenzhichipingguo/p/10075212.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/shenzhichipingguo/p/10075212.html</a></p>
<p><a href="https://www.cnblogs.com/rnmb/p/6553711.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/rnmb/p/6553711.html</a></p>
<p><a href="https://blog.csdn.net/u011419651/article/details/83831156" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u011419651/article/details/83831156</a></p>
<p><a href="https://www.jianshu.com/p/c4027084ac43" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/c4027084ac43</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/collection/Java集合详解：深入理解LinkedHashMap和LRU缓存"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java集合详解：深入理解LinkedHashMap和LRU缓存</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java集合详解：HashMap和HashTable</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#arraylist" class="table-of-contents__link toc-highlight">ArrayList</a><ul><li><a href="#arraylist概述" class="table-of-contents__link toc-highlight">ArrayList概述</a></li><li><a href="#arraylist的继承关系" class="table-of-contents__link toc-highlight">ArrayList的继承关系</a></li><li><a href="#底层数据结构" class="table-of-contents__link toc-highlight">底层数据结构</a></li><li><a href="#增删改查" class="table-of-contents__link toc-highlight">增删改查</a></li><li><a href="#modcount" class="table-of-contents__link toc-highlight">modCount</a></li><li><a href="#初始容量和扩容方式" class="table-of-contents__link toc-highlight">初始容量和扩容方式</a></li><li><a href="#线程安全" class="table-of-contents__link toc-highlight">线程安全</a></li></ul></li><li><a href="#vector" class="table-of-contents__link toc-highlight">Vector</a><ul><li><a href="#vector简介" class="table-of-contents__link toc-highlight">Vector简介</a></li><li><a href="#增删改查-1" class="table-of-contents__link toc-highlight">增删改查</a></li><li><a href="#初始容量和扩容" class="table-of-contents__link toc-highlight">初始容量和扩容</a></li><li><a href="#线程安全-1" class="table-of-contents__link toc-highlight">线程安全</a></li></ul></li><li><a href="#stack" class="table-of-contents__link toc-highlight">Stack</a></li><li><a href="#三个集合类之间的区别" class="table-of-contents__link toc-highlight">三个集合类之间的区别</a></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/collection/Java集合详解：HashMap和HashTable" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java集合详解：HashMap和HashTable | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java集合详解：HashMap和HashTable | Tommy"><meta data-rh="true" name="description" content="本文参考http://cmsblogs.com/?p=176"><meta data-rh="true" property="og:description" content="本文参考http://cmsblogs.com/?p=176"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合类总结">Java集合类总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：深入理解LinkedHashMap和LRU缓存">Java集合详解：深入理解LinkedHashMap和LRU缓存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理">Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable">Java集合详解：HashMap和HashTable</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：HashSet，TreeSet与LinkedHashSet">Java集合详解：HashSet，TreeSet与LinkedHashSet</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器">Java集合详解：Iterator，fail-fast机制与比较器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Java集合类细节精讲">Java集合详解：Java集合类细节精讲</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Queue和LinkedList">Java集  合详解：Queue和LinkedList</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：TreeMap和红黑树">Java集合详解：TreeMap和红黑树</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">集合</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java集合详解：HashMap和HashTable</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java集合详解：HashMap和HashTable</h1></header><p>本文参考<a href="http://cmsblogs.com/?p=176" target="_blank" rel="noopener noreferrer">http://cmsblogs.com/?p=176</a></p>
<p>《Java集合详解系列》是我在完成夯实Java基础篇的系列博客后准备开始整理的新系列文章。
为了更好地诠释知识点，形成体系文章，本系列文章整理了很多优质的博客内容，如有侵权请联系我，一定删除。</p>
<p>这些文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star、fork哈</p>
<p>本系列文章将整理于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="hashmap">HashMap<a href="#hashmap" class="hash-link" aria-label="Direct link to HashMap" title="Direct link to HashMap">​</a></h2>
<p>HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="定义">定义<a href="#定义" class="hash-link" aria-label="Direct link to 定义" title="Direct link to 定义">​</a></h3>
<p>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class HashMap&lt;K,V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extends AbstractMap&lt;K,V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="构造函数">构造函数<a href="#构造函数" class="hash-link" aria-label="Direct link to 构造函数" title="Direct link to 构造函数">​</a></h3>
<p>HashMap提供了三个构造函数：</p>
<p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</p>
<p>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</p>
<p>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</p>
<p>在这里提到了两个参数：初始容量，加载因子。</p>
<blockquote>
<p>这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</p>
<p>对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>
</blockquote>
<p>HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="数据结构">数据结构<a href="#数据结构" class="hash-link" aria-label="Direct link to 数据结构" title="Direct link to 数据结构">​</a></h3>
<blockquote>
<p>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它的数据结构：</p>
</blockquote>
<p>HashMap数据结构图</p>
<p>下图的table数组的每个格子都是一个桶。负载因子就是map中的元素占用的容量百分比。比如负载因子是0.75，初始容量（桶数量）为16时，那么允许装填的元素最大个数就是16*0.75 = 12，这个最大个数也被成为阈值，就是map中定义的threshold。超过这个阈值时，map就会自动扩容。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="存储实现putkeyvlaue">存储实现：put(key,vlaue)<a href="#存储实现putkeyvlaue" class="hash-link" aria-label="Direct link to 存储实现：put(key,vlaue)" title="Direct link to 存储实现：put(key,vlaue)">​</a></h3>
<p>首先我们先看源码</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return putForNullKey(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算key的hash值，此处对原来元素的hashcode进行了再次hash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key.hashCode());                  ------(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算key hash 值在 table 数组中的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = indexFor(hash, table.length);             ------(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //从i出开始迭代 e,找到 key 保存的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //判断该条链上是否有hash值相同的(key相同)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //若存在相同，则直接覆盖value，返回旧value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = e.value;    //旧值 = 新值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.recordAccess(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;     //返回旧值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //修改次数增加1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将key、value添加至i位置处</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addEntry(hash, key, value, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。</p>
<p>若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，==否则将该元素保存在链头（最 先保存的元素放在链尾）==。</p>
<p>若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：</p>
<blockquote>
<p>1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。</p>
<p>2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static int hash(int h) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static int indexFor(int h, int length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return h &amp; (length-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>HashMap的底层数组长度总是2的n次方，在构造函数中存在：<code>capacity &lt;&lt;= 1;</code>这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，<code>h&amp;(length - 1)</code>就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。</p>
<p>==对length取模来得到hash是常用的hash索引方法，这里采用位运算的话效率更高。==</p>
<p>我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。</p>
<p>这里我们假设length为16(2^n)和15，h为5、6、7。</p>
<p>当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p>
<blockquote>
<p>而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</p>
<p>这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。</p>
<p>如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">void addEntry(int hash, K key, V value, int bucketIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取bucketIndex处的Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry&lt;K, V&gt; e = table[bucketIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //若HashMap中元素的个数超过极限了，则容量扩大两倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (size++ &gt;= threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            resize(2 * table.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法中有两点需要注意：</p>
<p>后面添加的entry反而会接到前面。</p>
<p>一、是链的产生。</p>
<p>这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。</p>
<p>二、扩容问题。</p>
<p>随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。</p>
<p>该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="jdk18的hashmapput方法">JDK1.8的hashmap：put方法<a href="#jdk18的hashmapput方法" class="hash-link" aria-label="Direct link to JDK1.8的hashmap：put方法" title="Direct link to JDK1.8的hashmap：put方法">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               boolean evict) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((tab = table) == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = (tab = resize()).length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tab[i] = newNode(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; e; K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (p.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果p是红黑树节点，则用另外的处理方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (p instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int binCount = 0; ; ++binCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((e = p.next) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = newNode(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //当链表节点数超过8个，则直接进行红黑树化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        treeifyBin(tab, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) { // existing mapping for key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!onlyIfAbsent || oldValue == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            afterNodeAccess(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (++size &gt; threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    afterNodeInsertion(evict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>JDK1.8在链表长度超过8时会转换为红黑树。
转换方法如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n, index; Node&lt;K,V&gt; e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果节点数变小小于红黑树的节点数阈值时，调整空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //该方法直接返回一个红黑树结点。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (tl == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                hd = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //从链表头开始依次插入红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p.prev = tl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tl.next = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tl = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while ((e = e.next) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((tab[index] = hd) != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hd.treeify(tab);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// For treeifyBin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="扩容">扩容<a href="#扩容" class="hash-link" aria-label="Direct link to 扩容" title="Direct link to 扩容">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final Node&lt;K,V&gt;[] resize() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] oldTab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldThr = threshold;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newCap, newThr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (oldCap &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果原容量大于最大空间，则让阈值为最大值。因为不能再扩容了，最大容量就是整数最大值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threshold = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //两倍扩容，阈值也跟着变为两倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCap = oldThr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {               // zero initial threshold signifies using defaults</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (newThr == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float ft = (float)newCap * loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  (int)ft : Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = newThr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = newTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (oldTab != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; oldCap; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt; e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((e = oldTab[j]) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                oldTab[j] = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.next == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //当后面没有节点时，直接插入即可 //每个元素重新计算索引位置，此处的hash值并没有变，只是改变索引值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else if (e instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else { // preserve order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //否则，就从头到尾依次将节点进行索引然后插入新数组，这样插入后的链表顺序会和原来的顺序相反。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if ((e.hash &amp; oldCap) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (loTail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                loHead = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                loTail.next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            loTail = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (hiTail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                hiHead = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                hiTail.next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            hiTail = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } while ((e = next) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (loTail != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        loTail.next = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        newTab[j] = loHead;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (hiTail != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        hiTail.next = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        newTab[j + oldCap] = hiHead;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return newTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="读取实现getkey">读取实现：get(key)<a href="#读取实现getkey" class="hash-link" aria-label="Direct link to 读取实现：get(key)" title="Direct link to 读取实现：get(key)">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若为null，调用getForNullKey方法返回相对应的value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getForNullKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据该 key 的 hashCode 值计算它的 hash 码  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key.hashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 取出 table 数组中指定索引处的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //若搜索的key与查找的key相同，则返回相对应的value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。</p>
<p>同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。</p>
<p>在java中与有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="hashtable">HashTable<a href="#hashtable" class="hash-link" aria-label="Direct link to HashTable" title="Direct link to HashTable">​</a></h2>
<p>一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="定义-1">定义<a href="#定义-1" class="hash-link" aria-label="Direct link to 定义" title="Direct link to 定义">​</a></h3>
<p>HashTable在Java中的定义如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Hashtable&lt;K,V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extends Dictionary&lt;K,V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是&quot;key-value键值对&quot;接口。</p>
<p>HashTable采用&quot;拉链法&quot;实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。</p>
<p>table：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的&quot;key-value键值对&quot;都是存储在Entry数组中的。</p>
<p>count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。</p>
<p>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。</p>
<p>loadFactor：加载因子。</p>
<p>modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="构造方法">构造方法<a href="#构造方法" class="hash-link" aria-label="Direct link to 构造方法" title="Direct link to 构造方法">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Hashtable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this(11, 0.75f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      默认构造函数，容量为11，加载因子为0.75。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Hashtable(int initialCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this(initialCapacity, 0.75f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Hashtable(int initialCapacity, float loadFactor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //验证初始容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           initialCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //验证加载因子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity==0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initialCapacity = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.loadFactor = loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //初始化table，获得大小为initialCapacity的table数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = new Entry[initialCapacity];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算阀值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //初始化HashSeed值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initHashSeedAsNeeded(initialCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    private int hash(Object k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return hashSeed ^ k.hashCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>构造一个与给定的 Map 具有相同映射关系的新哈希表。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //设置table容器大小，其值==t.size * 2 + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this(Math.max(2*t.size(), 11), 0.75f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            putAll(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="主要方法">主要方法<a href="#主要方法" class="hash-link" aria-label="Direct link to 主要方法" title="Direct link to 主要方法">​</a></h3>
<p>HashTable的API对  外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//首先我们先看put方法：将指定 key 映射到此哈希表中的指定 value。注意这里键key和值value都不可为空。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 确保value不为null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 确保key在table[]是不重复的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 处理过程：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 1、计算key的hash值，确认在table[]中的索引位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 2、迭代index索引位置，如果该位置处的 链表中存在一个一样的key，则替换其value，返回旧值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry tab[] = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);    //计算key的hash值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;     //确认该key的索引位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //迭代，寻找该key，替换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V old = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return old;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (count &gt;= threshold) {  //如果容器中的元素数量已经达到阀值，则进行扩容操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rehash();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在索引位置处插入一个新的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; e = tab[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //容器中元素+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>put方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处</p>
</blockquote>
<p>在HashTabled的put方法中有两个地方需要注意：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //1、HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void rehash() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int oldCapacity = table.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Entry&lt;K,V&gt;[] oldMap = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //新容量=旧容量 * 2 + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (newCapacity - MAX_ARRAY_SIZE &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (oldCapacity == MAX_ARRAY_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newCapacity = MAX_ARRAY_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //新建一个size = newCapacity 的HashTable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Entry&lt;K,V&gt;[] newMap = new Entry[];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //重新计算阀值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //重新计算hashSeed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean rehash = initHashSeedAsNeeded(newCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            table = newMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //将原来的元素拷贝到新的HashTable中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = oldCapacity ; i-- &gt; 0 ;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Entry&lt;K,V&gt; e = old;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    old = old.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (rehash) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e.hash = hash(e.key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.next = newMap[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    newMap[index] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。</p>
<p>这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 * 2 + 1 =17，而阀值threshold=17*0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，依次类推。</p>
<p>下面是计算key的hash值，这里hashSeed发挥了作用。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private int hash(Object k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return hashSeed ^ k.hashCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回null。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry tab[] = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="hashtable与hashmap的异同点">HashTable与HashMap的异同点<a href="#hashtable与hashmap的异同点" class="hash-link" aria-label="Direct link to HashTable与HashMap的异同点" title="Direct link to HashTable与HashMap的异同点">​</a></h2>
<p>HashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。</p>
<blockquote>
<p>第一：我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。</p>
<p>第二：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：</p>
<p>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 return putForNullKey(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    第三：Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="面试题hashmap和hashtable的区别">面试题：HashMap和HashTable的区别<a href="#面试题hashmap和hashtable的区别" class="hash-link" aria-label="Direct link to 面试题：HashMap和HashTable的区别" title="Direct link to 面试题：HashMap和HashTable的区别">​</a></h2>
<p>HashMap线程不安全，HashTable是线程安全的。HashMap内部实现没有任何线程同步相关的代码，所以相对而言性能要好一点。如果在多线程中使用HashMap需要自己管理线程同步。HashTable大部分对外接口都使用synchronized包裹，所以是线程安全的，但是性能会相对差一些。</p>
<p>二者的基类不一样。HashMap派生于AbstractMap，HashTable派生于Dictionary。它们都实现Map, Cloneable, Serializable这些接口。AbstractMap中提供的基础方法更多，并且实现了多个通用的方法，而在Dictionary中只有少量的接口，并且都是abstract类型。</p>
<p>key和value的取值范围不同。HashMap的key和value都可以为null，但是HashTablekey和value都不能为null。对于HashMap如果get返回null，并不能表明HashMap不存在这个key，如果需要判断HashMap中是否包含某个key，就需要使用containsKey这个方法来判断。</p>
<p>算法不一样。HashMap的initialCapacity为16，而HashTable的initialCapacity为11。HashMap中初始容量必须是2的幂,如果初始化传入的initialCapacity不是2的幂，将会自动调整为大于出入的initialCapacity最小的2的幂。HashMap使用自己的计算hash的方法(会依赖key的hashCode方法)，HashTable则使用key的hashCode方法得到。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="Direct link to 参考文章" title="Direct link to 参考文章">​</a></h2>
<p><a href="http://cmsblogs.com/?p=176" target="_blank" rel="noopener noreferrer">http://cmsblogs.com/?p=176</a></p>
<p><a href="http://mini.eastday.com/mobile/180310183019559.html#" target="_blank" rel="noopener noreferrer">http://mini.eastday.com/mobile/180310183019559.html#</a></p>
<p><a href="https://blog.csdn.net/lihua5419/article/details/87691965" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/lihua5419/article/details/87691965</a></p>
<p><a href="https://www.cnblogs.com/aeolian/p/8468632.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/aeolian/p/8468632.html</a></p>
<p>​</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/collection/Java集合详解：HashMap和HashTable.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/collection/Java集合详解：HashSet，TreeSet与LinkedHashSet"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java集合详解：HashSet，TreeSet与LinkedHashSet</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#hashmap" class="table-of-contents__link toc-highlight">HashMap</a><ul><li><a href="#定义" class="table-of-contents__link toc-highlight">定义</a></li><li><a href="#构造函数" class="table-of-contents__link toc-highlight">构造函数</a></li><li><a href="#数据结构" class="table-of-contents__link toc-highlight">数据结构</a></li><li><a href="#存储实现putkeyvlaue" class="table-of-contents__link toc-highlight">存储实现：put(key,vlaue)</a></li><li><a href="#jdk18的hashmapput方法" class="table-of-contents__link toc-highlight">JDK1.8的hashmap：put方法</a></li><li><a href="#扩容" class="table-of-contents__link toc-highlight">扩容</a></li><li><a href="#读取实现getkey" class="table-of-contents__link toc-highlight">读取实现：get(key)</a></li></ul></li><li><a href="#hashtable" class="table-of-contents__link toc-highlight">HashTable</a><ul><li><a href="#定义-1" class="table-of-contents__link toc-highlight">定义</a></li><li><a href="#构造方法" class="table-of-contents__link toc-highlight">构造方法</a></li><li><a href="#主要方法" class="table-of-contents__link toc-highlight">主要方法</a></li></ul></li><li><a href="#hashtable与hashmap的异同点" class="table-of-contents__link toc-highlight">HashTable与HashMap的异同点</a></li><li><a href="#面试题hashmap和hashtable的区别" class="table-of-contents__link toc-highlight">面试题：HashMap和HashTable的区别</a></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
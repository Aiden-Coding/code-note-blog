<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/collection/Java集合详解：Iterator，fail-fast机制与比较器" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java集合详解：Iterator，fail-fast机制与比较器 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java集合详解：Iterator，fail-fast机制与比较器 | Tommy"><meta data-rh="true" name="description" content="本文参考 cmsblogs.com/p=1185"><meta data-rh="true" property="og:description" content="本文参考 cmsblogs.com/p=1185"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合类总结">Java集合类总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：深入理解LinkedHashMap和LRU缓存">Java集合详解：深入理解LinkedHashMap和LRU缓存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理">Java集合详解：一文读懂ArrayList,Vector与Stack使用方法和实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：HashMap和HashTable">Java集合详解：HashMap和HashTable</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：HashSet，TreeSet与LinkedHashSet">Java集合详解：HashSet，TreeSet与LinkedHashSet</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器">Java集合详解：Iterator，fail-fast机制与比较器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Java集合类细节精讲">Java集合详解：Java集合类细节精讲</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：Queue和LinkedList">Java集  合详解：Queue和LinkedList</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/collection/Java集合详解：TreeMap和红黑树">Java集合详解：TreeMap和红黑树</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">集合</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java集合详解：Iterator，fail-fast机制与比较器</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java集合详解：Iterator，fail-fast机制与比较器</h1></header><p>本文参考 cmsblogs.com/p=1185</p>
<p>《Java集合详解系列》是我在完成夯实Java基础篇的系列博客后准备开始整理的新系列文章。
为了更好地诠释知识点，形成体系文章，本系列文章整理了很多优质的博客内容，如有侵权请联系我，一定删除。</p>
<p>这些文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star、fork哈</p>
<p>本系列文章将整理于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>今天我们来探索一下LIterator，fail-fast机制与比较器的源码。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="iterator">Iterator<a href="#iterator" class="hash-link" aria-label="Direct link to Iterator" title="Direct link to Iterator">​</a></h2>
<p>迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">Iterator iterator = list.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while(iterator.hasNext()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String string = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。</p>
<p>它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：</p>
<p>对于数组我们是使用下标来进行处理的</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">int[] arrays = new int[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for(int i = 0 ; i  arrays.length ; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int a = arrays[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>对于ArrayList是这么处理的</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">ListString list = new ArrayListString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for(int i = 0 ; i  list.size() ;  i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  String string = list.get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。</p>
<p>在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。</p>
<p>使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送向前，向后，取当前元素的命令，就可以间接遍历整个集合。</p>
<p>上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="javautiliterator">java.util.Iterator<a href="#javautiliterator" class="hash-link" aria-label="Direct link to java.util.Iterator" title="Direct link to java.util.Iterator">​</a></h3>
<p>在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：</p>
<p>1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。</p>
<p>2、方法名称得到了改进。</p>
<p>其接口定义如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Iterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">　　boolean hasNext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">　　Object next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">　　void remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中：</p>
<p>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型</p>
<p>boolean hasNext()：判断容器内是否还有可供访问的元素</p>
<p>void remove()：删除迭代器刚越过的元素</p>
<p>对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">for(Iterator it = c.iterator(); it.hasNext(); ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">　　Object o = it.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">　　 do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>==前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。==</p>
<p>但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。下面就ArrayList的源码进行分析分析。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="各个集合的iterator的实现">各个集合的Iterator的实现<a href="#各个集合的iterator的实现" class="hash-link" aria-label="Direct link to 各个集合的Iterator的实现" title="Direct link to 各个集合的Iterator的实现">​</a></h3>
<p>下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。</p>
<p>ArrayList的Iterator实现</p>
<p>在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private class Itr implements IteratorE {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">而ArrayList的iterator()方法实现：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public IteratorE iterator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Itr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：</p>
<p>在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置</p>
<p>int cursor;<br>
<!-- -->int lastRet = -1;<br>
<!-- -->int expectedModCount = modCount;</p>
<p>从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean hasNext() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return cursor != size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public E next() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    checkForComodification();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = cursor;    记录索引位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (i = size)    如果获取元素大于集合元素个数，则抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NoSuchElementException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object[] elementData = ArrayList.this.elementData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (i = elementData.length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cursor = i + 1;      cursor + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (E) elementData[lastRet = i];  lastRet + 1 且返回cursor处元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>checkForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。</p>
<p>。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。</p>
<p>该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。</p>
<p>所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final void checkForComodification() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (modCount != expectedModCount)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void remove() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (lastRet  0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    checkForComodification();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList.this.remove(lastRet);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cursor = lastRet;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastRet = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        expectedModCount = modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IndexOutOfBoundsException ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="fail-fast机制">fail-fast机制<a href="#fail-fast机制" class="hash-link" aria-label="Direct link to fail-fast机制" title="Direct link to fail-fast机制">​</a></h3>
<p>这部分参考<a href="http://cmsblogs.com/p=1220" target="_blank" rel="noopener noreferrer">http://cmsblogs.com/p=1220</a></p>
<p>在JDK的Collection中我们时常会看到类似于这样的话：</p>
<p>例如，ArrayList</p>
<p>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出ConcurrentModificationException。
因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p>
<p>HashMap中：</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<p>在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？</p>
<p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。</p>
<p>记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException异常，从  而产生fail-fast机制。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="fail-fast示例">fail-fast示例<a href="#fail-fast示例" class="hash-link" aria-label="Direct link to fail-fast示例" title="Direct link to fail-fast示例">​</a></h4>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class FailFastTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ListInteger list = new ArrayList();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class threadOne extends Thread{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            IteratorInteger iterator = list.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(iterator.hasNext()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int i = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(ThreadOne 遍历 + i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>desc当i == 3时，修改list</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">        private static class threadTwo extends Thread{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int i = 0 ; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while(i  6){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(ThreadTwo run： + i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(i == 3){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        list.remove(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for(int i = 0 ; i  10;i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                list.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new threadOne().start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new threadTwo().start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>运行结果：</p>
<p>ThreadOne 遍历0
ThreadTwo run：0
ThreadTwo run：1
ThreadTwo run：2
ThreadTwo run：3
ThreadTwo run：4
ThreadTwo run：5
Exception in thread Thread-0 java.util.ConcurrentModificationException
at java.util.ArrayList$Itr.checkForComodification(Unknown Source)
at java.util.ArrayList$Itr.next(Unknown Source)
at test.ArrayListTest$threadOne.run(ArrayListTest.java23)</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="fail-fast产生原因">fail-fast产生原因<a href="#fail-fast产生原因" class="hash-link" aria-label="Direct link to fail-fast产生原因" title="Direct link to fail-fast产生原因">​</a></h4>
<p>通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</p>
<p>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</p>
<p>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最  大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。</p>
<p>从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private class Itr implements IteratorE {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cursor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastRet = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int expectedModCount = ArrayList.this.modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean hasNext() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (this.cursor != ArrayList.this.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public E next() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkForComodification();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         省略此处代码 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void remove() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.lastRet  0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkForComodification();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         省略此处代码 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void checkForComodification() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ArrayList.this.modCount == this.expectedModCount)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount  若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。</p>
<p>expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：</p>
<p>protected transient int modCount = 0;
那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E paramE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ensureCapacityInternal(this.size + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     省略此处代码 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void ensureCapacityInternal(int paramInt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (this.elementData == EMPTY_ELEMENTDATA)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        paramInt = Math.max(10, paramInt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ensureExplicitCapacity(paramInt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void ensureExplicitCapacity(int paramInt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.modCount += 1;    修改modCount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     省略此处代码 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean remove(Object paramObject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (paramObject == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i = 0; i  this.size; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.elementData[i] != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fastRemove(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i = 0; i  this.size; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!(paramObject.equals(this.elementData[i])))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fastRemove(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void fastRemove(int paramInt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.modCount += 1;   修改modCount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     省略此处代码 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void clear() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.modCount += 1;    修改modCount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     省略此处代码 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。</p>
<p>所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：</p>
<p>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。</p>
<p>线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount  = N  ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<p>所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="fail-fast解决办法">fail-fast解决办法<a href="#fail-fast解决办法" class="hash-link" aria-label="Direct link to fail-fast解决办法" title="Direct link to fail-fast解决办法">​</a></h4>
<p>通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：</p>
<p>方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</p>
<p>方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。</p>
<p>CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。</p>
<p>1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。</p>
<p>2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？</p>
<p>第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。</p>
<p>第二、CopyOnWriterArrayList根本就不会产  生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private static class COWIteratorE implements ListIteratorE {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public E next() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!(hasNext()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NoSuchElementException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.snapshot[(this.cursor++)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E paramE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReentrantLock localReentrantLock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        localReentrantLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object[] arrayOfObject1 = getArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int i = arrayOfObject1.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arrayOfObject2[i] = paramE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setArray(arrayOfObject2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int j = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            localReentrantLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void setArray(Object[] paramArrayOfObject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.array = paramArrayOfObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：</p>
<p>Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);
arrayOfObject2[i] = paramE;
setArray(arrayOfObject2);
就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。</p>
<p>所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</p>
<h1>Comparable 和 Comparator</h1>
<p>Java 中为我们提供了两种比较机制：Comparable 和 Comparator，他们之间有什么区别呢？今天来了解一下。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="comparable">Comparable<a href="#comparable" class="hash-link" aria-label="Direct link to Comparable" title="Direct link to Comparable">​</a></h2>
<p>Comparable 在 java.lang包下，是一个接口，内部只有一个方法 compareTo()：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public interface ComparableT {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int compareTo(T o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Comparable 可以让实现它的类的对象进行比较，具体的比较规则是按照 compareTo 方法中的规则进行 。这种顺序称为 自然顺序。</p>
<p>compareTo 方法的返回值有三种情况：</p>
<p>e1.compareTo(e2)  0 即 e1  e2
e1.compareTo(e2) = 0 即 e1 = e2
e1.compareTo(e2)  0 即 e1  e2</p>
<p>注意：</p>
<p>1.由于 null 不是一个类，也不是一个对象，因此在重写 compareTo 方法时应该注意 e.compareTo(null) 的情况，即使 e.equals(null) 返回 false，compareTo 方法也应该主动抛出一个空指针异常 NullPointerException。</p>
<p>2.Comparable 实现类重写 compareTo 方法时一般要求 e1.compareTo(e2) == 0 的结果要和 e1.equals(e2) 一致。这样将来使用 SortedSet 等根据类的自然排序进行排序的集合容器时可以保证保存的数据的顺序和想象中一致。
有人可能好奇上面的第二点如果违反了会怎样呢？</p>
<p>举个例子，如果你往一个 SortedSet 中先后添加两个对象 a 和 b，a b 满足 (!a.equals(b) &amp;&amp; a.compareTo(b) == 0)，同时也没有另外指定个 Comparator，那当你添加完 a 再添加 b 时会添加失败返回 false, SortedSet 的 size 也不会增加，因为在 SortedSet 看来它们是相同的，而 SortedSet 中是不允许重复的。</p>
<p>实际上所有实现了 Comparable 接口的 Java 核心类的结果都和 equlas 方法保持一致。
实现了 Comparable 接口的 List 或则数组可以使用 Collections.sort() 或者 Arrays.sort() 方法进行排序。</p>
<p>实现了 Comparable 接口的对象才能够直接被用作 SortedMap (SortedSet) 的 key，要不然得在外边指定 Comparator 排序规则。</p>
<p>因此自己定义的类如果想要使用有序的集合类，需要实现 Comparable 接口，比如：</p>
<p>description 测试用的实体类 书, 实现了 Comparable 接口，自然排序</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class BookBean implements Serializable, Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BookBean(String name, int count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.count = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setName(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getCount() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setCount(int count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.count = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean equals(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this == o) return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!(o instanceof BookBean)) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BookBean bean = (BookBean) o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (getCount() != bean.getCount()) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getName().equals(bean.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>重写 hashCode 的计算方法
根据所有属性进行 迭代计算，避免重复
计算 hashCode 时 计算因子 31 见得很多，是一个质数，不能再被除</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        调用 String 的 hashCode(), 唯一表示一个字符串内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = getName().hashCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        乘以 31, 再加上 count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = 31  result + getCount();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return BookBean{ +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                name=&#x27; + name + &#x27;&#x27;&#x27; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                , count= + count +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;}&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当向 TreeSet 中添加 BookBean 时，会调用这个方法进行排序</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int compareTo(Object another) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (another instanceof BookBean){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BookBean anotherBook = (BookBean) another;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            比如这里按照书价排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result = getCount() - anotherBook.getCount();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          或者按照 String 的比较顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          result = getName().compareTo(anotherBook.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (result == 0){   当书价一致时，再对比书名。 保证所有属性比较一遍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                result = getName().compareTo(anotherBook.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         一样就返回 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述代码还重写了 equlas(), hashCode() 方法，自定义的类将来可能会进行比较时，建议重写这些方法。</p>
<p>这里我想表达的是在有些场景下 equals 和 compareTo 结果要保持一致，这时候不重写 equals，使用 Object.equals 方法得到的结果会有问题，比如说 HashMap.put() 方法，会先调用 key 的 equals 方法进行比较，然后才调用 compareTo。</p>
<p>后面重写 compareTo 时，要判断某个相同时对比下一个属性，把所有属性都比较一次。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="comparator">Comparator<a href="#comparator" class="hash-link" aria-label="Direct link to Comparator" title="Direct link to Comparator">​</a></h3>
<p>首先认识一下Comparator：</p>
<p>Comparator 是javase中的接口，位于java.util包下，该接口抽象度极高，有必要掌握该接口的使用
大多数文章告诉大家Comparator是用来排序，但我想说排序是Comparator能实现的功能之一，他不仅限于排序</p>
<p>排序例子：
题目描述
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组<code>{3，32，321}</code>，则打印出这三个数字能排成的最小数字为321323。</p>
<p>代码实现：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.ArrayList;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Collections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Comparator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Solution {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String PrintMinNumber(int [] s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(s==null) return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String s1=&quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int i=0;i&lt;s.length;i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             list.add(s[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collections.sort(list,new Comparator&lt;Integer&gt;(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public int compare(Integer str1,Integer str2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String s1=str1+&quot;&quot;+str2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String s2=str2+&quot;&quot;+str1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return s1.compareTo(s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         for(int j:list){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                s1+=j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>一般需要做比较的逻辑都可以使用的上Comparator，最常用的场景就是排序和分组，排序常使用Arrays和Collections的sort方法，而分组则可以使用提供的divider方法。</p>
<p>排序和分组的区别在于:
排序时，两个对象比较的结果有三种：大于，等于，小于。
分组时，两个对象比较的结果只有两种：等于(两个对象属于同一组)，不等于(两个对象属于不同组)</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="java8中使用lambda实现比较器">Java8中使用lambda实现比较器<a href="#java8中使用lambda实现比较器" class="hash-link" aria-label="Direct link to Java8中使用lambda实现比较器" title="Direct link to Java8中使用lambda实现比较器">​</a></h3>
<p>今天先看看Lambda 表达式的简单使用：
首先：Lambda表达式的基本语法：(parameters) -&gt; expression或（请注意语句的花括号）</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">(parameters) -&gt; { statements; }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>第一感觉就是这个箭头感觉有点怪，不过多用几次习惯就好，它主要是为了把参数列表与Lambda主体分隔开，箭头左边的是参数列表，右边的是Lambda主体。注意：Lambda表达式可以包含多行语句。
在用Lambda 之前，我们先看看之前写比较器的写法</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    Comparator&lt;Developer&gt; byName = new Comparator&lt;Developer&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int compare(Developer o1, Developer o2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return o1.getName().compareTo(o2.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>感觉也不是很复杂，没几行代码，再来看看Lambda 表达式的写法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    Comparator&lt;Developer&gt; byName =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (Developer o1, Developer o2)-&gt;o1.getName().compareTo(o2.getName());</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>比之前要简单许多有木有。
下面再来看看排序功能示例：
先用Collections.sort如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class TestSorting {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;Developer&gt; listDevs = getDevelopers();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Before Sort&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Developer developer : listDevs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(developer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //安装年龄排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Collections.sort(listDevs, new Comparator&lt;Developer&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public int compare(Developer o1, Developer o2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return o1.getAge() - o2.getAge();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;After Sort&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Developer developer : listDevs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(developer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static List&lt;Developer&gt; getDevelopers() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;mkyong&quot;, new BigDecimal(&quot;70000&quot;), 33));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;), 20));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;), 10));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;), 55));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>输出结果：</p>
<p>Before Sort
Developer [name=mkyong, salary=70000, age=33]
Developer [name=alvin, salary=80000, age=20]
Developer [name=jason, salary=100000, age=10]
Developer [name=iris, salary=170000, age=55]</p>
<p>After Sort
Developer [name=jason, salary=100000, age=10]
Developer [name=alvin, salary=80000, age=20]
Developer [name=mkyong, salary=70000, age=33]
Developer [name=iris, salary=170000, age=55]</p>
<p>看起来整个流程完全没毛病，下面再来看看Lambda的方式:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class TestSorting {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;Developer&gt; listDevs = getDevelopers();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Before Sort&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Developer developer : listDevs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(developer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;After Sort&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //对比上面的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            listDevs.sort((Developer o1, Developer o2)-&gt;o1.getAge()-o2.getAge());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //这样打印感觉也不错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            listDevs.forEach((developer)-&gt;System.out.println(developer));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static List&lt;Developer&gt; getDevelopers() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;Developer&gt; result = new ArrayList&lt;Developer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;mkyong&quot;, new BigDecimal(&quot;70000&quot;), 33));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;alvin&quot;, new BigDecimal(&quot;80000&quot;), 20));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;jason&quot;, new BigDecimal(&quot;100000&quot;), 10));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.add(new Developer(&quot;iris&quot;, new BigDecimal(&quot;170000&quot;), 55));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>输出结果：</p>
<p>Before Sort
Developer [name=mkyong, salary=70000, age=33]
Developer [name=alvin, salary=80000, age=20]
Developer [name=jason, salary=100000, age=10]
Developer [name=iris, salary=170000, age=55]</p>
<p>After Sort
Developer [name=jason, salary=100000, age=10]
Developer [name=alvin, salary=80000, age=20]
Developer [name=mkyong, salary=70000, age=33]
Developer [name=iris, salary=170000, age=55]</p>
<p>总体来说，写法与之前有较大的改变，写的代码更少，更简便，感觉还不错。
后续会带来更多有关Java8相关的东西，毕竟作为一只程序狗，得不停的学习才能不被淘汰。Java语言都在不停的改进更新，我们有啥理由不跟上节奏呢？
由于时间问题这里只是一个简单的应用，想了解更多可到官网查找相关示例。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>Java 中的两种排序方式：</p>
<p>Comparable 自然排序。（实体类实现）
Comparator 是定制排序。（无法修改实体类时，直接在调用方创建）
同时存在时采用 Comparator（定制排序）的规则进行比较。</p>
<p>对于一些普通的数据类型（比如 String, Integer, Double…），它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</p>
<p>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</p>
<p>这就是 Comparable 和 Comparator 的区别。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="Direct link to 参考文章" title="Direct link to 参考文章">​</a></h2>
<p><a href="https://blog.csdn.net/weixin_30363263/article/details/80867590" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_30363263/article/details/80867590</a></p>
<p><a href="https://www.cnblogs.com/shizhijie/p/7657049.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/shizhijie/p/7657049.html</a></p>
<p><a href="https://www.cnblogs.com/xiaweicn/p/8688216.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/xiaweicn/p/8688216.html</a></p>
<p><a href="https://cmsblogs.com/p=1185" target="_blank" rel="noopener noreferrer">https://cmsblogs.com/p=1185</a></p>
<p><a href="https://blog.csdn.net/android_hl/article/details/53228348" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/android_hl/article/details/53228348</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/collection/Java集合详解：Iterator，fail-fast机制与比较器.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/collection/Java集合详解：HashSet，TreeSet与LinkedHashSet"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java集合详解：HashSet，TreeSet与LinkedHashSet</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/collection/Java集合详解：Java集合类细节精讲"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java集合详解：Java集合类细节精讲</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#iterator" class="table-of-contents__link toc-highlight">Iterator</a><ul><li><a href="#javautiliterator" class="table-of-contents__link toc-highlight">java.util.Iterator</a></li><li><a href="#各个集合的iterator的实现" class="table-of-contents__link toc-highlight">各个集合的Iterator的实现</a></li><li><a href="#fail-fast机制" class="table-of-contents__link toc-highlight">fail-fast机制</a></li></ul></li><li><a href="#comparable" class="table-of-contents__link toc-highlight">Comparable</a><ul><li><a href="#comparator" class="table-of-contents__link toc-highlight">Comparator</a></li><li><a href="#java8中使用lambda实现比较器" class="table-of-contents__link toc-highlight">Java8中使用lambda实现比较器</a></li></ul></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
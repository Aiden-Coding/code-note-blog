<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/basic/Java中的Class类和Object类" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java中的Class类和Object类 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/Java中的Class类和Object类"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java中的Class类和Object类 | Tommy"><meta data-rh="true" name="description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><meta data-rh="true" property="og:description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/Java中的Class类和Object类"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/Java中的Class类和Object类" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/Java中的Class类和Object类" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/抽象类和接口">抽象类和接口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/序列化和反序列化">序列化和反序列化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/代码块和代码执行顺序">代码块和代码执行顺序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/多线程">多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/反射">反射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/泛型">泛型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/继承、封装、多态的实现原理">继承、封装、多态的实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/解读Java中的回调">解读Java中的回调</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/枚举类">枚举类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/面向对象基础">面向对象基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/深入理解内部类">深入理解内部类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/final关键字特性">final关键字特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java8新特性终极指南">Java8新特性终极指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java基本数据类型">Java基本数据类型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java集合框架梳理">Java集合框架梳理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java类和包">Java类和包</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java异常">Java异常</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/basic/Java中的Class类和Object类">Java中的Class类和Object类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java注解和最佳实践">Java注解和最佳实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java自动拆箱装箱里隐藏的秘密">Java自动拆箱装箱里隐藏的秘密</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/javac和javap">javac和javap</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/JavaIO流">JavaIO流</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/string和包装类">string和包装类</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">基础</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java中的Class类和Object类</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java中的Class类和Object类</h1></header><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章首发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。
该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="java中class类及用法">Java中Class类及用法<a href="#java中class类及用法" class="hash-link" aria-label="Direct link to Java中Class类及用法" title="Direct link to Java中Class类及用法">​</a></h2>
<p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。</p>
<blockquote>
<p>这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p>
</blockquote>
<p>说白了就是：</p>
<blockquote>
<p>Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言。</p>
</blockquote>
<blockquote>
<p>Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象</p>
</blockquote>
<blockquote>
<p>Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Private constructor. Only the Java Virtual Machine creates Class objects.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * This constructor is not used and prevents the default constructor being</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * generated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> //私有构造方法，只能由jvm进行实例化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Class(ClassLoader loader) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Initialize final field for classLoader.  The initialization value of non-null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // prevents future JIT optimizations from assuming this final field is null.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    classLoader = loader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>Class类的作用是运行时提供或获得某个对象的类型信息，和C++中的typeid()函数类似。这些信息也可用于反射。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="class类原理">Class类原理<a href="#class类原理" class="hash-link" aria-label="Direct link to Class类原理" title="Direct link to Class类原理">​</a></h3>
<p>看一下Class类的部分源码</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //Class类中封装了类型的各种信息。在jvm中就是通过Class类的实例来获取每个Java类的所有信息的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class Class类 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class aClass = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    private EnclosingMethodInfo getEnclosingMethodInfo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        Object[] enclosingInfo = getEnclosingMethod0();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        if (enclosingInfo == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            return new EnclosingMethodInfo(enclosingInfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**提供原子类操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Atomic operations support.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    private static class Atomic {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // initialize Unsafe machinery here, since we need to call Class.class instance method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // and have to avoid calling it in the static initializer of the Class class...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // offset of Class.reflectionData instance field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private static final long reflectionDataOffset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // offset of Class.annotationType instance field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private static final long annotationTypeOffset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // offset of Class.annotationData instance field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private static final long annotationDataOffset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            Field[] fields = Class.class.getDeclaredFields0(false); // bypass caches</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            reflectionDataOffset = objectFieldOffset(fields, &quot;reflectionData&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            annotationTypeOffset = objectFieldOffset(fields, &quot;annotationType&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            annotationDataOffset = objectFieldOffset(fields, &quot;annotationData&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //提供反射信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // reflection data that might get invalidated when JVM TI RedefineClasses() is called</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    private static class ReflectionData&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Field[] declaredFields;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Field[] publicFields;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Method[] declaredMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Method[] publicMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Constructor&lt;T&gt;[] declaredConstructors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Constructor&lt;T&gt;[] publicConstructors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // Intermediate results for getFields and getMethods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Field[] declaredPublicFields;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Method[] declaredPublicMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        volatile Class&lt;?&gt;[] interfaces;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // Value of classRedefinedCount when we created this ReflectionData instance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        final int redefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        ReflectionData(int redefinedCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            this.redefinedCount = redefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //方法数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    static class MethodArray {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // Don&#x27;t add or remove methods except by add() or remove() calls.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private Method[] methods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private int length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        private int defaults;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        MethodArray() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            this(20);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        MethodArray(int initialSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            if (initialSize &lt; 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                throw new IllegalArgumentException(&quot;Size should be 2 or more&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            methods = new Method[initialSize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            length = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            defaults = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //注解信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // annotation data that might get invalidated when JVM TI RedefineClasses() is called</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    private static class AnnotationData {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        // Value of classRedefinedCount when we created this AnnotationData instance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        final int redefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                       Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                       int redefinedCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            this.annotations = annotations;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            this.declaredAnnotations = declaredAnnotations;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            this.redefinedCount = redefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。</p>
<p>我们自己无法生成一个Class对象（构造函数为private)，而 这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //通过该方法可以动态地将字节码转为一个Class类对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws ClassFormatError</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return defineClass(name, b, off, len, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="如何获得一个class类对象">如何获得一个Class类对象<a href="#如何获得一个class类对象" class="hash-link" aria-label="Direct link to 如何获得一个Class类对象" title="Direct link to 如何获得一个Class类对象">​</a></h3>
<p>请注意，以下这些方法都是值、指某个类对应的Class对象已经在堆中生成以后，我们通过不同方式获取对这个Class对象的引用。而上面说的DefineClass才是真正将字节码加载到虚拟机的方法，会在堆中生成新的一个Class对象。</p>
<p>第一种办法，Class类的forName函数</p>
<blockquote>
<p>public class shapes<br>
<!-- -->Class obj= Class.forName(&quot;shapes&quot;);
第二种办法，使用对象的getClass()函数</p>
</blockquote>
<blockquote>
<p>public class shapes<!-- -->
shapes s1=new shapes();
Class obj=s1.getClass();
Class obj1=s1.getSuperclass();//这个函数作用是获取shapes类的父类的类型</p>
</blockquote>
<p>第三种办法，使用类字面常量</p>
<blockquote>
<p>Class obj=String.class;
Class obj1=int.class;
注意，使用这种办法生成Class类对象时，不会使JVM自动加载该类（如String类）。==而其他办法会使得JVM初始化该类。==</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用class类的对象来生成目标类的实例">使用Class类的对象来生成目标类的实例<a href="#使用class类的对象来生成目标类的实例" class="hash-link" aria-label="Direct link to 使用Class类的对象来生成目标类的实例" title="Direct link to 使用Class类的对象来生成目标类的实例">​</a></h3>
<blockquote>
<p>生成不精确的object实例</p>
</blockquote>
<p>获取一个Class类的对象后，可以用 newInstance() 函数来生成目标类的一个实例。然而，该函数并不能直接生成目标类的实例，只能生成object类的实例</p>
<blockquote>
<p>Class obj=Class.forName(&quot;shapes&quot;);
Object ShapesInstance=obj.newInstance();
使用泛化Class引用生成带类型的目标实例</p>
</blockquote>
<blockquote>
<p><code>Class&lt;shapes&gt; obj=shapes.class</code>;
shapes newShape=obj.newInstance();
因为有了类型限制，所以使用泛化Class语法的对象引用不能指向别的类。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    Class obj1=int.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;Integer&gt; obj2=int.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj1=double.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //obj2=double.class; 这一行代码是非法的，obj2不能改指向别的类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    然而，有个灵活的用法，使得你可以用Class的对象指向 基类的任何子类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;? extends Number&gt; obj=int.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj=Number.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj=double.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    因此，以下语法生成的Class对象可以指向任何类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; obj=int.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj=double.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj=shapes.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    最后一个奇怪的用法是，当你使用这种泛型语法来构建你手头有的一个Class类的对象的基类对象时，必须采用以下的特殊语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class shapes{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class round extends shapes{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;round&gt; rclass=round.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;? super round&gt; sclass= rclass.getSuperClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Class&lt;shapes&gt; sclass=rclass.getSuperClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    我们明知道，round的基类就是shapes，但是却不能直接声明 Class &lt; shapes &gt;，必须使用特殊语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class &lt; ? super round &gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    这个记住就可以啦。</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="object类">Object类<a href="#object类" class="hash-link" aria-label="Direct link to Object类" title="Direct link to Object类">​</a></h2>
<p>这部分主要参考<a href="http://ihenu.iteye.com/blog/2233249" target="_blank" rel="noopener noreferrer">http://ihenu.iteye.com/blog/2233249</a></p>
<p>Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。</p>
<p>Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会 自动导入。Object类没有定义属性，一共有13个方法，13个方法之中并不是所有方法都是子类可访问的，一共有9个方法是所有子类都继承了的。</p>
<p>先大概介绍一下这些方法</p>
<p>1．clone方法
保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
2．getClass方法
final方法，获得运行时类型。
3．toString方法
该方法用得比较多，一般子类都有覆盖。
4．finalize方法
该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
5．equals方法
该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
6．hashCode方法
该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。
7．wait方法
wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
调用该方法后当前线程进入睡眠状态，直到以下事件发生。
（1）其他线程调用了该对象的notify方法。
（2）其他线程调用了该对象的notifyAll方法。
（3）其他线程调用了interrupt中断该线程。
（4）时间间隔到了。
此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
8．notify方法
该方法唤醒在该对象上等待的某个线程。
9．notifyAll方法
该方法唤醒在该对象上等待的所有线程。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="类构造器public-object">类构造器public Object();<a href="#类构造器public-object" class="hash-link" aria-label="Direct link to 类构造器public Object();" title="Direct link to 类构造器public Object();">​</a></h3>
<blockquote>
<p>大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中A即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。</p>
</blockquote>
<blockquote>
<p>为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</p>
<p>当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="registernatives方法">registerNatives()方法;<a href="#registernatives方法" class="hash-link" aria-label="Direct link to registerNatives()方法;" title="Direct link to registerNatives()方法;">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private static native void registerNatives();</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。</p>
<p>方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。</p>
<p>具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。</p>
<p>既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块：</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private static native void registerNatives();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     registerNatives();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="clone方法实现浅拷贝">Clone()方法实现浅拷贝<a href="#clone方法实现浅拷贝" class="hash-link" aria-label="Direct link to Clone()方法实现浅拷贝" title="Direct link to Clone()方法实现浅拷贝">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">protected native Object clone() throwsCloneNotSupportedException;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>看，clode()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为&quot;克隆&quot;，其目的是创建并返回此对象的一个副本。</p>
</blockquote>
<blockquote>
<p>形象点理解，这有一辆科鲁兹，你看着不错，想要个一模一样的。你调用此方法即可像变魔术一样变出一辆一模一样的科鲁兹出来。配置一样，长相一样。但从此刻起，原来的那辆科鲁兹如果进行了新的装饰，与你克隆出来的这辆科鲁兹没有任何关系了。</p>
<p>你克隆出来的对象变不变完全在于你对克隆出来的科鲁兹有没有进行过什么操作了。Java术语表述为：clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。</p>
</blockquote>
<p>明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。</p>
<p>首先看一下下面的这个例子：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    package com.corn.objectsummary;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    import com.corn.Person;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class ObjectTest {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object o1 = new Object();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // The method clone() from the type Object is not visible  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object clone = o1.clone();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>例子很简单，在main()方法中，new一个Oject对象后，想直接调用此对象的clone方法克隆一个对象，但是出现错误提示：&quot;The method clone() from the type Object is not visible&quot;</p>
<p>why? 根据提示，第一反应是ObjectTest类中定义的Oject对象无法访问其clone()方法。回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。</p>
<p>显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对&quot;不同包中的子类可以访问&quot;没有正确理解。</p>
<p>&quot;不同包中的子类可以访问&quot;，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外）</p>
</blockquote>
<p>于是，上例改成如下形式，我们发现，可以正常编译：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class clone方法 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    User user = new User();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //User copy = user.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    User user = new User();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //User copy = (User)user.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>是的，因为此时的主调已经是子类的引用了。</p>
<blockquote>
<p>上述代码在运行过程中会抛出&quot;java.lang.CloneNotSupportedException&quot;,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定：</p>
<p>clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。</p>
<p>Cloneable接口仅是一个表示接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。</p>
<p>于是，上述代码改成如下形式，即可正确指定clone()方法以实现克隆。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class User implements Cloneable{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public UserInfo userInfo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        User user = new User();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserInfo userInfo = new UserInfo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        user.userInfo = userInfo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(user.userInfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            User copy = (User) user.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(copy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(copy.userInfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (CloneNotSupportedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //拷贝的User实例与原来不一样，是两个对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    com.javase.Class和Object.Object方法.用到的类.User@4dc63996</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    com.javase.Class和Object.Object方法.用到的类.UserInfo@d716361</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //而拷贝后对象的userinfo引用对象是同一个。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //所以这是浅拷贝</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    com.javase.Class和Object.Object方法.用到的类.User@6ff3c5b5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    com.javase.Class和Object.Object方法.用到的类.UserInfo@d716361</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>总结：
clone方法实现的是浅拷贝，只拷贝当前对象，并且在堆中分配新的空间，放这个复制的对象。但是对象如果里面有其他类的子对象，那么就不会拷贝到新的对象中。</p>
<p>深拷贝和浅拷贝的区别</p>
<blockquote>
<p>浅拷贝
浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p>深拷贝
深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。</p>
</blockquote>
<p>那么这两种方式有什么相同和不同呢？</p>
<blockquote>
<p>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。</p>
<p>分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p>
<p>而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，</p>
<p>填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p>
</blockquote>
<p>也就是说，一个对象在浅拷贝以后，只是把对象复制了一份放在堆空间的另一个地方，但是成员变量如果有引用指向其他对象，这个引用指向的对象和被拷贝的对象中引用指向的对象是一样的。当然，基本数据类型还是会重新拷贝一份的。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="getclass方法">getClass()方法<a href="#getclass方法" class="hash-link" aria-label="Direct link to getClass()方法" title="Direct link to getClass()方法">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final native Class&lt;?&gt; getClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象<code>Class&lt;?&gt;</code>。效果与Object.class相同。</p>
<p>首先解释下&quot;类对象&quot;的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。</p>
<p>作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。</p>
<p>于是，Java中定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为&quot;类对象&quot;。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class getClass方法 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            User user = new User();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //getclass方法是native方法，可以取到堆区唯一的Class&lt;User&gt;对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; aClass = user.getClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class bClass = User.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Class cClass = Class.forName(&quot;com.javase.Class和Object.Object方法.用到的类.User&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (ClassNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(aClass);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(bClass);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        class com.javase.Class和Object.Object方法.用到的类.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        class com.javase.Class和Object.Object方法.用到的类.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                User a = (User) aClass.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InstantiationException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (IllegalAccessException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此处主要大量涉及到Java中的反射知识</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="equals方法">equals()方法<a href="#equals方法" class="hash-link" aria-label="Direct link to equals()方法" title="Direct link to equals()方法">​</a></h3>
<p>5.public boolean equals(Object obj);</p>
<blockquote>
<p>与equals在Java中经常被使用，大家也都知道与equals的区别：</p>
<p>==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；</p>
<p>equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。</p>
</blockquote>
<p>实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean equals(Object obj) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         return (this == obj);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？</p>
<p>equals()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？</p>
<p>如上，在object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到object基类。</p>
<p>如下场景的实际业务需求，对于User bean，由实际的业务需求可知当属性uid相同时，表示的是同一个User，即两个User对象相等。则可以重写equals以重定义User对象相等的标尺。</p>
</blockquote>
<p>ObjectTest中打印出true，因为User类定义中重写 了equals()方法，这很好理解，很可能张三是一个人小名，张三丰才是其大名，判断这两个人是不是同一个人，这时只用判断uid是否相同即可。</p>
<blockquote>
<p>如上重写equals方法表面上看上去是可以了，实则不然。因为它破坏了Java中的约定：重写equals()方法必须重写hasCode()方法。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="hashcode方法">hashCode()方法;<a href="#hashcode方法" class="hash-link" aria-label="Direct link to hashCode()方法;" title="Direct link to hashCode()方法;">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public native int hashCode()</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p>
<p>hashCode()具有如下约定：</p>
<blockquote>
<p>1).在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致；</p>
<p>2).如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等；</p>
<p>3).反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。</p>
</blockquote>
<p>即严格的数学逻辑表示为： 两个对象相等 <code>&lt;=&gt; </code> equals()相等 <code>=&gt;</code>hashCode()相等。因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出：hasCode()不相等<code>=&gt;</code>equals（）不相等 <code>&lt;=&gt; </code>两个对象不相等。</p>
<p>可能有人在此产生疑问：既然比较两个对象是否相等的唯一条件（也是冲要条件）是equals，那么为什么还要弄出一个hashCode()，并且进行如此约定，弄得这么麻烦？</p>
<p>其实，这主要体现在hashCode()方法的作用上，其主要用于增强哈希表的性能。</p>
<p>以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）</p>
<blockquote>
<p>在此需要纠正一个理解上的误区：对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。</p>
<p>因此，在上述代码中，重写了equals()方法后，需要重写hashCode()方法。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class equals和hashcode方法 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //修改equals时必须同时修改hashcode方法，否则在作为key时会出问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean equals(Object obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (this == obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //相同的对象必须有相同hashcode，不同对象可能有相同hashcode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return hashCode() &gt;&gt; 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="tostring方法">toString()方法<a href="#tostring方法" class="hash-link" aria-label="Direct link to toString()方法" title="Direct link to toString()方法">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public String toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public String toString() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。</p>
<p>getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。</p>
<p>如上例中的u1的哈希码是638，则对应的16进制为27e，调用toString()方法返回的结果为：com.corn.objectsummary.User@27e。</p>
<p>因此：toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="wait-notify-notifall">wait() notify() notifAll()<a href="#wait-notify-notifall" class="hash-link" aria-label="Direct link to wait() notify() notifAll()" title="Direct link to wait() notify() notifAll()">​</a></h3>
<blockquote>
<p>一说到wait(...) / notify() | notifyAll()几个方法，首先想到的是线程。确实，这几个方法主要用于java多线程之间的协作。先具体看下这几个方法的主要含义：</p>
<p>wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。</p>
<p>wait(long timeout)/wait(long timeout, int nanos)： 调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notisfy()/notisfyAll()方法，或超过指定的超时时间量。</p>
<p>notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。</p>
<p>wait(...) / notify() | notifyAll()一般情况下都是配套使用。下面来看一个简单的例子：</p>
</blockquote>
<p>这是一个生产者消费者的模型，只不过这里只用flag来标识哪个线程需要工作</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class wait和notify {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //volatile保证线程可见性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile static int flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //object作为锁对象，用于线程使用wait和notify方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile static Object o = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //wait和notify只能在同步代码块内使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    synchronized (o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (flag == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    System.out.println(&quot;thread1 wait&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    //释放锁，线程挂起进入object的等待队列，后续代码运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    o.wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;thread1 run&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;notify t2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            flag = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            //通知等待队列的一个线程获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            o.notify();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //解释同上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        synchronized (o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (flag == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    System.out.println(&quot;thread2 wait&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    o.wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;thread2 run&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;notify t1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            o.notify();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //输出结果是</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    thread1 run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    notify t2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    thread1 wait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    thread2 run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    notify t1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    thread2 wait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    thread1 run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    notify t2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //不断循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p> 从上述例子的输出结果中可以得出如下结论：</p>
<p>1、wait(...)方法调用后当前线程将立即阻塞，且适当其所持有的同步代码块中的锁，直到被唤醒或超时或打断后且重新获取到锁后才能继续执行；</p>
<p>2、notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。</p>
</blockquote>
<p>在Java源码中，可以看到wait()具体定义如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void wait() throws InterruptedException {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     wait(0);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此  ，wait(...)方法本质上都是native方式实现。</p>
</blockquote>
<p>notify()/notifyAll()方法也都是native方法。</p>
<p>Java中线程具有较多的知识点，是一块比较大且重要的知识点。后期会有博文专门针对Java多线程作出详细总结。此处不再细述。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="finalize方法">finalize()方法<a href="#finalize方法" class="hash-link" aria-label="Direct link to finalize()方法" title="Direct link to finalize()方法">​</a></h3>
<p>finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">protected void finalize() throws Throwable { }  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？</p>
<p>首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对形象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="class类和object类的关系">CLass类和Object类的关系<a href="#class类和object类的关系" class="hash-link" aria-label="Direct link to CLass类和Object类的关系" title="Direct link to CLass类和Object类的关系">​</a></h2>
<blockquote>
<p>Object类和Class类没有直接的关系。</p>
<p>Object类是一切java类的父类，对于普通的java类，即便不声明，也是默认继承了Object类。典型的，可以使用Object类中的toString()方法。</p>
<p>Class类是用于java反射机制的，一切java类，都有一个对应的Class对象，他是一个final类。Class 类的实例表示，正在运行的 Java 应用程序中的类和接口。</p>
</blockquote>
<p>转一个知乎很有趣的问题
<a href="https://www.zhihu.com/question/30301819" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/30301819</a></p>
<p>Java的对象模型中：
1 所有的类都是Class类的实例，Object是类，那么Object也是Class类的一个实例。</p>
<p>2 所有的类都最终继承自Object类，Class是类，那么Class也继承自Object。</p>
<p>3 这就像是先有鸡还是先有蛋的问题，请问实际中JVM是怎么处理的？</p>
<blockquote>
<p>这个问题中，第1个假设是错的：java.lang.Object是一个Java类，但并不是java.lang.Class的一个实例。后者只是一个用于描述Java类与接口的、用于支持反射操作的类型。这点上Java跟其它一些更纯粹的面向对象语言（例如Python和Ruby）不同。</p>
<p>而第2个假设是对的：java.lang.Class是java.lang.Object的派生类，前者继承自后者。虽然第1个假设不对，但“鸡蛋问题”仍然存在：在一个已经启动完毕、可以使用的Java对象系统里，必须要有一个java.lang.Class实例对应java.lang.Object这个类；而java.lang.Class是java.lang.Object的派生类，按“一般思维”前者应该要在后者完成初始化之后才可以初始化…</p>
<p>事实是：这些相互依赖的核心类型完全可以在“混沌”中一口气都初始化好，然后对象系统的状态才叫做完成了“bootstrap”，后面就可以按照Java对象系统的一般规则去运行。JVM、JavaScript、Python、Ruby等的运行时都有这样的bootstrap过程。</p>
<p>在“混沌”（boostrap过程）里，JVM可以为对象系统中最重要的一些核心类型先分配好内存空间，让它们进入[已分配空间]但[尚未完全初始化]状态。此时这些对象虽然已经分配了空间，但因为状态还不完整所以尚不可使用。</p>
<p>然后，通过这些分配好的空间把这些核心类型之间的引用关系串好。到此为止所有动作都由JVM完成，尚未执行任何Java字节码。然后这些核心类型就进入了[完全初始化]状态，对象系统就可以开始自我运行下去，也就是可以开始执行Java字节码来进一步完成Java系统的初始化了。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="Direct link to 参考文章" title="Direct link to 参考文章">​</a></h2>
<p><a href="https://www.cnblogs.com/congsg2016/p/5317362.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/congsg2016/p/5317362.html</a>
<a href="https://www.jb51.net/article/125936.htm" target="_blank" rel="noopener noreferrer">https://www.jb51.net/article/125936.htm</a>
<a href="https://blog.csdn.net/dufufd/article/details/80537638" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/dufufd/article/details/80537638</a>
<a href="https://blog.csdn.net/farsight1/article/details/80664104" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/farsight1/article/details/80664104</a>
<a href="https://blog.csdn.net/xiaomingdetianxia/article/details/77429180" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/xiaomingdetianxia/article/details/77429180</a></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="java技术江湖">Java技术江湖<a href="#java技术江湖" class="hash-link" aria-label="Direct link to Java技术江湖" title="Direct link to Java技术江湖">​</a></h3>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源，关注公众号后，后台回复关键字 <strong>“Java”</strong> 即可免费无套路获取。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/1.png" alt="" class="img_kGBN"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/basic/Java中的Class类和Object类.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/basic/Java异常"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java异常</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/basic/Java注解和最佳实践"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java注解和最佳实践</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#java中class类及用法" class="table-of-contents__link toc-highlight">Java中Class类及用法</a><ul><li><a href="#class类原理" class="table-of-contents__link toc-highlight">Class类原理</a></li><li><a href="#如何获得一个class类对象" class="table-of-contents__link toc-highlight">如何获得一个Class类对象</a></li><li><a href="#使用class类的对象来生成目标类的实例" class="table-of-contents__link toc-highlight">使用Class类的对象来生成目标类的实例</a></li></ul></li><li><a href="#object类" class="table-of-contents__link toc-highlight">Object类</a><ul><li><a href="#类构造器public-object" class="table-of-contents__link toc-highlight">类构造器public Object();</a></li><li><a href="#registernatives方法" class="table-of-contents__link toc-highlight">registerNatives()方法;</a></li><li><a href="#clone方法实现浅拷贝" class="table-of-contents__link toc-highlight">Clone()方法实现浅拷贝</a></li><li><a href="#getclass方法" class="table-of-contents__link toc-highlight">getClass()方法</a></li><li><a href="#equals方法" class="table-of-contents__link toc-highlight">equals()方法</a></li><li><a href="#hashcode方法" class="table-of-contents__link toc-highlight">hashCode()方法;</a></li><li><a href="#tostring方法" class="table-of-contents__link toc-highlight">toString()方法</a></li><li><a href="#wait-notify-notifall" class="table-of-contents__link toc-highlight">wait() notify() notifAll()</a></li><li><a href="#finalize方法" class="table-of-contents__link toc-highlight">finalize()方法</a></li></ul></li><li><a href="#class类和object类的关系" class="table-of-contents__link toc-highlight">CLass类和Object类的关系</a></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a><ul><li><a href="#java技术江湖" class="table-of-contents__link toc-highlight">Java技术江湖</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/basic/final关键字特性" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">final关键字特性 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/final关键字特性"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="final关键字特性 | Tommy"><meta data-rh="true" name="description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><meta data-rh="true" property="og:description" content="本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/final关键字特性"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/final关键字特性" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/basic/final关键字特性" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/抽象类和接口">抽象类和接口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/序列化和反序列化">序列化和反序列化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/代码块和代码执行顺序">代码块和代码执行顺序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/多线程">多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/反射">反射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/泛型">泛型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/继承、封装、多态的实现原理">继承、封装、多态的实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/解读Java中的回调">解读Java中的回调</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/枚举类">枚举类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/面向对象基础">面向对象基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/深入理解内部类">深入理解内部类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/basic/final关键字特  性">final关键字特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java8新特性终极指南">Java8新特性终极指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java基本数据类型">Java基本数据类型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java集合框架梳理">Java集合框架梳理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java类和包">Java类和包</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java异常">Java异常</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java中的Class类和Object类">Java中的Class类和Object类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java注解和最佳实践">Java注解和最佳实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/Java自动拆箱装箱里隐藏的秘密">Java自动拆箱装箱里隐藏的秘密</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/javac和javap">javac和javap</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/JavaIO流">JavaIO流</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/basic/string和包装类">string和包装类</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">基础</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">final关键字特性</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>final关键字特性</h1></header><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章首发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《夯实Java基础系列博文》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。
该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<p>final关键字在java中使用非常广泛，可以申明成员变量、方法、类、本地变量。一旦将引用声明为final，将无法再改变这个引用。final关键字还能保证内存同步，本博客将会从final关键字的特性到从java内存层面保证同步讲解。这个内容在面试中也有可能会出现。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="final使用">final使用<a href="#final使用" class="hash-link" aria-label="Direct link to final使用" title="Direct link to final使用">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final变量">final变量<a href="#final变量" class="hash-link" aria-label="Direct link to final变量" title="Direct link to final变量">​</a></h3>
<p>final变量有成员变量或者是本地变量(方法内的局部变量)，在类成员中final经常和static一起使用，作为类常量使用。<strong>其中类常量必须在声明时初始化，final成员常量可以在构造函数初始化。</strong></p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final int i; //报错，必须初始化 因为常量在常量池中就存在了，调用时不需要类的初始化，所以必须在声明时初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final int j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        j = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>就如上所说的，对于类常量，JVM会缓存在常量池中，在  读取该变量时不会加载这个类。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final int i = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;调用构造函数&quot;); // 该方法不会调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Main.i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final修饰基本数据类型变量和引用">final修饰基本数据类型变量和引用<a href="#final修饰基本数据类型变量和引用" class="hash-link" aria-label="Direct link to final修饰基本数据类型变量和引用" title="Direct link to final修饰基本数据类型变量和引用">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void final修饰基本类型变量和引用() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int[] b = {1};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int[] c = {1};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  b = c;报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b[0] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String aa = &quot;a&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Fi f = new Fi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //aa = &quot;b&quot;;报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // f = null;//报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f.a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>final方法表示该方法不能被子类的方法重写，将方法声明为final，在编译的时候就已经静态绑定了，不需要在运行时动态绑定。final方法调用时使用的是invokespecial指令。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">class PersonalLoan{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final String getName(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return&quot;personal loan”;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CheapPersonalLoan extends PersonalLoan{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final String getName(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return&quot;cheap personal loan&quot;;//编译错误，无法被重载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getName(); //可以调用，因为是public方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final类">final类<a href="#final类" class="hash-link" aria-label="Direct link to final类" title="Direct link to final类">​</a></h3>
<p>final类不能被继承，final类中的方法默认也会是final类型的，java中的String类和Integer类都是final类型的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    class Si{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //一般情况下final修饰的变量一定要被初始化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //只有下面这种情况例外，要求该变量必须在构造方法中被初始化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //并且不能有空参数的构造方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这样就可以让每个实例都有一个不同的变量，并且这个变量在每个实例中只会被初始化一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //于是这个变量在单个实例里就是常量了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int s ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Si(int s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.s = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Bi {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final void go() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //final修饰方法无法被继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Ci extends Bi {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        void go() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //            //final修饰方法无法被继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final char[]a = {&#x27;a&#x27;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int[]b = {1};</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final class PersonalLoan{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CheapPersonalLoan extends PersonalLoan {  //编译错误，无法被继承 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void final修饰类() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //引用没有被final修饰，所以是可变的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //final只修饰了Fi类型，即Fi实例化的对象在堆中内存地址是不可变的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //虽然内存地址不可变，但是可以对内部的数据做改变。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fi f = new Fi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f.a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f.a = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //改变实例中的值并不改变内存地址。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fi ff = f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //让引用指向新的Fi对象，原来的f对象由新的引用ff持有。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //引用的指向改变也不会改变原来对象的地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f = new Fi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(ff);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final关键字的知识点">final关键字的知识点<a href="#final关键字的知识点" class="hash-link" aria-label="Direct link to final关键字的知识点" title="Direct link to final关键字的知识点">​</a></h3>
<ol>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值。</li>
<li>本地变量必须在声明时赋值。 因为没有初始化的过程</li>
<li>在匿名类中所有变量都必须是final变量。</li>
<li>final方法不能被重写, final类不能被继承</li>
<li>接口中声明的所有变量本身是final的。类似于匿名类</li>
<li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li>
<li>final方法在编译阶段绑定，称为静态绑 定(static binding)。</li>
<li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li>
</ol>
<p>final方法的好处:</p>
<ol>
<li>提高了性能，JVM在常量池中会缓存final变量</li>
<li>final变量在多线程中并发安全，无需额外的同步开销</li>
<li>final方法是静态编译的，提高了调用速度</li>
<li><strong>final类创建的对象是只可读的，在多线程可以安全共享</strong></li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="final关键字的最佳实践">final关键字的最佳实践<a href="#final关键字的最佳实践" class="hash-link" aria-label="Direct link to final关键字的最佳实践" title="Direct link to final关键字的最佳实践">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final的用法">final的用法<a href="#final的用法" class="hash-link" aria-label="Direct link to final的用法" title="Direct link to final的用法">​</a></h3>
<p>1、final 对于常量来说，意味着值不能改变，例如 final int i=100。这个i的值永远都是100。
但是对于变量来说又不一样，只是标识这个引用不可被改变，例如 final File f=new File(&quot;c:\test.txt&quot;);</p>
<p>那么这个f一定是不能被改变的，如果f本身有方法修改其中的成员变量，例如是否可读，是允许修改的。有个形象的比喻：一个女子定义了一个final的老公，这个老公的职业和收入都是允许改变的，只是这个女人不会换老公而已。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="关于空白final">关于空白final<a href="#关于空白final" class="hash-link" aria-label="Direct link to 关于空白final" title="Direct link to 关于空白final">​</a></h3>
<p>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>
<!-- -->　另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final  空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。
　
但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class FinalTest { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int p; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int q=3; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FinalTest(){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p=1; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FinalTest(int i){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p=i;//可以赋值，相当于直接定义p </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    q=i;//不能为一个final变量赋值 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final内存分配">final内存分配<a href="#final内存分配" class="hash-link" aria-label="Direct link to final内存分配" title="Direct link to final内存分配">​</a></h3>
<p>刚提到了内嵌机制，现在详细展开。
要知道调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数（类内部有一个函数签名和函数地址的映射表）。所以减少函数调用次数就等于降低了性能消耗。</p>
<p>final修饰的函数会被编译器优化，优化的结果是减少了函数调用的次数。如何实现的，举个例子给你看：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class Test{ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void func(){System.out.println(&quot;g&quot;);}; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void main(String[] args){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int j=0;j&lt;1000;j++)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    func(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    经过编译器优化之后，这个类变成了相当于这样写： </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class Test{ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void func(){System.out.println(&quot;g&quot;);}; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void main(String[] args){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int j=0;j&lt;1000;j++)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {System.out.println(&quot;g&quot;);} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }} </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>看出来区别了吧？编译器直接将func的函数体内嵌到了调用函数的地方，这样的结果是节省了1000次函数调用，当然编译器处理成字节码，只是我们可以想象成这样，看个明白。</p>
<p>不过，当函数体太长的话，用final可能适得其反，因为经过编译器内嵌之后代码长度大大增加，于是就增加了jvm解释字节码的时间。</p>
<p>在使用final修饰方法的时候，编译器会将被final修饰过的方法插入到调用者代码处，提高运行速度和效率，但被final修饰的方法体不能过大，编译器可能会放弃内联，但究竟多大的方法会放弃，我还没有做测试来计算过。</p>
<p><strong>下面这些内容是通过两个疑问来继续阐述的</strong></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用final修饰方法会提高速度和效率吗">使用final修饰方法会提高速度和效率吗<a href="#使用final修饰方法会提高速度和效率吗" class="hash-link" aria-label="Direct link to 使用final修饰方法会提高速度和效率吗" title="Direct link to 使用final修饰方法会提高速度和效率吗">​</a></h3>
<p>见下面的测试代码，我会执行五次：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class Test   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void getJava()   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String str1 = &quot;Java &quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String str2 = &quot;final &quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 10000; i++)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                str1 += str2;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static final void getJava_Final()   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String str1 = &quot;Java &quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String str2 = &quot;final &quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 10000; i++)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                str1 += str2;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long start = System.currentTimeMillis();   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getJava();   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;调用不带final修饰的方法执行时间为:&quot; + (System.currentTimeMillis() - start) + &quot;毫秒时间&quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            start = System.currentTimeMillis();   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String str1 = &quot;Java &quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String str2 = &quot;final &quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 10000; i++)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                str1 += str2;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;正常的执行时间为:&quot; + (System.currentTimeMillis() - start) + &quot;毫秒时间&quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            start = System.currentTimeMillis();   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getJava_Final();   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;调用final修饰的方法执行时间为:&quot; + (System.currentTimeMillis() - start) + &quot;毫秒时间&quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>结果为：
第一次：
调用不带final修饰的方法执行时间为:1732毫秒时间
正常的执行时间为:1498毫秒时间
调用final修饰的方法执行时间为:1593毫秒时间
第二次：
调用不带final修饰的方法执行时间为:1217毫秒时间
正常的执行时间为:1031毫秒时间
调用final修饰的方法执行时间为:1124毫秒时间
第三次：
调用不带final修饰的方法执行时间为:1154毫秒时间
正常的执行时间为:1140毫秒时间
调用final修饰的方法执行时间为:1202毫秒时间
第四次：
调用不带final修饰的方法执行时间为:1139毫秒时间
正常的执行时间为:999毫秒时间
调用final修饰的方法执行时间为:1092毫秒时间
第五次：
调用不带final修饰的方法执行时间为:1186毫秒时间
正常的执行时间为:1030毫秒时间
调用final修饰的方法执行时间为:1109毫秒时间</p>
<p>由以上运行结果不难看出，执行最快的是“正常的执行”即代码直接编写，而使用final修饰的方法，不像有些书上或者文章上所说的那样，速度与效率与“正常的执行”无异，而是位于第二位，最差的是调用不加final 修饰的方法。</p>
<p>观点：加了比不加好一点。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用final修饰变量会让变量的值不能被改变吗">使用final修饰变量会让变量的值不能被改变吗；<a href="#使用final修饰变量会让变量的值不能被改变吗" class="hash-link" aria-label="Direct link to 使用final修饰变量会让变量的值不能被改变吗；" title="Direct link to 使用final修饰变量会让变量的值不能被改变吗；">​</a></h3>
<p>见代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public class Final   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color.color[3] = &quot;white&quot;;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (String color : Color.color)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.print(color+&quot; &quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Color   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static final String[] color = { &quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot; };   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    执行结果： </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    red blue yellow white </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    看！，黑色变成了白色。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在使用findbugs插件时，就会提示public static String[] color = <!-- -->black<!-- -->;这行代码不安全，但加上final修饰，这行代码仍然是不安全的，因为final没有做到保证变量的值不会被修改！</p>
<p>原因是：final关键字只能保证变量本身不能被赋与新值，而不能保证变量的内部结构不被修改。例如在main方法有如下代码Color.color = new String[]<!-- -->;就会报错了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="如何保证数组内部不被修改">如何保证数组内部不被修改<a href="#如何保证数组内部不被修改" class="hash-link" aria-label="Direct link to 如何保证数组内部不被修改" title="Direct link to 如何保证数组内部不被修改">​</a></h3>
<p>那可能有的同学就会问了，加上final关键字不能保证数组不会被外部修改，那有什么方法能够保证呢？答案就是降低访问级别，把数组设为private。这样的话，就解决了数组在外部被修改的不安全性，但也产生了另一个问题，那就是这个数组要被外部使用的。</p>
<p>解决这个问题见代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    import java.util.AbstractList;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    import java.util.List;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class Final   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static void main(String[] args)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (String color : Color.color)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.print(color + &quot; &quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color.color.set(3, &quot;white&quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Color   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static String[] _color = { &quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot; };   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static List&lt;String&gt; color = new AbstractList&lt;String&gt;()   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public String get(int index)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return _color[index];   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public String set(int index, String value)   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new RuntimeException(&quot;为了代码安全,不能修改数组&quot;);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public int size()   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return _color.length;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这样就OK了，既保证了代码安全，又能让数组中的元素被访问了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="final方法的三条规则">final方法的三条规则<a href="#final方法的三条规则" class="hash-link" aria-label="Direct link to final方法的三条规则" title="Direct link to final方法的三条规则">​</a></h3>
<p>规则1：final修饰的方法不可以被重写。</p>
<p>规则2：final修饰的方法仅仅是不能重写，但它完全可以被重载。</p>
<p>规则3：父类中private final方法，子类可以重新定义，这种情况不是重写。</p>
<p>代码示例</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    规则1代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class FinalMethodTest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	public final void test(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Sub extends FinalMethodTest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	// 下面方法定义将出现编译错误，不能重写final方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	public void test(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    规则2代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class Finaloverload {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	//final 修饰的方法只是不能重写，完全可以重载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	public final void test(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	public final void test(String arg){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    规则3代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class PrivateFinalMethodTest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	private final void test(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Sub extends PrivateFinalMethodTest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	// 下面方法定义将不会出现问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    	public void test(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="final-和-jvm的关系">final 和 jvm的关系<a href="#final-和-jvm的关系" class="hash-link" aria-label="Direct link to final 和 jvm的关系" title="Direct link to final 和 jvm的关系">​</a></h2>
<p>与前面介绍的锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ol>
<p>  下面，我们通过一些示例性的代码来分别说明这两个规则：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class FinalExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i;                            // 普通变量 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int j;                      //final 变量 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static FinalExample obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void FinalExample () {     // 构造函数 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i = 1;                        // 写普通域 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        j = 2;                        // 写 final 域 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void writer () {    // 写线程 A 执行 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        obj = new FinalExample ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void reader () {       // 读线程 B 执行 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FinalExample object = obj;       // 读对象引用 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int a = object.i;                // 读普通域 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int b = object.j;                // 读 final 域 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里假设一个线程 A 执行 writer () 方法，随后另一个线程 B 执行 reader () 方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="写-final-域的重排序规则">写 final 域的重排序规则<a href="#写-final-域的重排序规则" class="hash-link" aria-label="Direct link to 写 final 域的重排序规则" title="Direct link to 写 final 域的重排序规则">​</a></h3>
<p>写 final 域的重排序规则禁止把 final 域的写重排 序到构造函数之外。这个规则的实现包含下面 2 个方面：</p>
<ul>
<li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li>
</ul>
<p>现在让我们分析 writer () 方法。writer () 方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p>
<ol>
<li>构造一个 FinalExample 类型的对象；</li>
<li>把这个对象的引用赋值给引用变量 obj。</li>
</ol>
<p>假设线程 B 读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/6628576a54f0ba625c8c3af4586cef3a.jpg" alt="img" class="img_kGBN"></p>
<p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p>
<p>写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 1 还没有写入普通域 i）。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="读-final-域的重排序规则">读 final 域的重排序规则<a href="#读-final-域的重排序规则" class="hash-link" aria-label="Direct link to 读 final 域的重排序规则" title="Direct link to 读 final 域的重排序规则">​</a></h3>
<p>读 final 域的重排序规则 如下：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li>
</ul>
<p>初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。</p>
<p>reader() 方法包含三个操作：</p>
<ol>
<li>初次读引用变量 obj;</li>
<li>初次读引用变量 obj 指向对象的普通域 i。</li>
<li>初次读引用变量 obj 指向对象的 final 域 j。</li>
</ol>
<p>现在我们假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p>
<p><img loading="lazy" src="https://static001.infoq.cn/resource/image/a0/36/a0a9b023bc56ab97bbda8812cdca7236.png" alt="" class="img_kGBN"></p>
<p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p>
<p>读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。在这个示例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="如果-final-域是引用类型"> 如果 final 域是引用类型<a href="#如果-final-域是引用类型" class="hash-link" aria-label="Direct link to 如果 final 域是引用类型" title="Direct link to 如果 final 域是引用类型">​</a></h3>
<p>上面我们看到的 final 域是基础数据类型，下面让我们看看如果 final 域是引用类型，将会有什么效果？</p>
<p>请看下列示例代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class FinalReferenceExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int[] intArray;                     //final 是引用类型 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static FinalReferenceExample obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public FinalReferenceExample () {        // 构造函数 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    intArray = new int[1];              //1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    intArray[0] = 1;                   //2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void writerOne () {          // 写线程 A 执行 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj = new FinalReferenceExample ();  //3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void writerTwo () {          // 写线程 B 执行 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    obj.intArray[0] = 2;                 //4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void reader () {              // 读线程 C 执行 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (obj != null) {                    //5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int temp1 = obj.intArray[0];       //6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p>
<ol>
<li>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ol>
<p>对上面的示例程序，我们假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。下面是一种可能的线程执行时序：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/29b097c36fd531028991826bb7c835db.png" alt="" class="img_kGBN">
在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p>
<p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步原语（lock 或 volatile）来确保内存可见性。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="Direct link to 参考文章" title="Direct link to 参考文章">​</a></h2>
<p><a href="https://www.infoq.cn/article/java-memory-model-6" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/java-memory-model-6</a>
<a href="https://www.jianshu.com/p/067b6c89875a" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/067b6c89875a</a>
<a href="https://www.jianshu.com/p/f68d6ef2dcf0" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/f68d6ef2dcf0</a>
<a href="https://www.cnblogs.com/xiaoxi/p/6392154.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/xiaoxi/p/6392154.html</a>
<a href="https://www.iteye.com/blog/cakin24-2334965" target="_blank" rel="noopener noreferrer">https://www.iteye.com/blog/cakin24-2334965</a>
<a href="https://blog.csdn.net/chengqiuming/article/details/70139503" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/chengqiuming/article/details/70139503</a>
<a href="https://blog.csdn.net/hupuxiang/article/details/7362267" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/hupuxiang/article/details/7362267</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/basic/final关键字特性.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/basic/深入理解内部类"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">深入理解内部类</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/basic/Java8新特性终极指南"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java8新特性终极指南</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#final使用" class="table-of-contents__link toc-highlight">final使用</a><ul><li><a href="#final变量" class="table-of-contents__link toc-highlight">final变量</a></li><li><a href="#final修饰基本数据类型变量和引用" class="table-of-contents__link toc-highlight">final修饰基本数据类型变量和引用</a></li><li><a href="#final类" class="table-of-contents__link toc-highlight">final类</a></li><li><a href="#final关键字的知识点" class="table-of-contents__link toc-highlight">final关键字的知识点</a></li></ul></li><li><a href="#final关键字的最佳实践" class="table-of-contents__link toc-highlight">final关键字的最佳实践</a><ul><li><a href="#final的用法" class="table-of-contents__link toc-highlight">final的用法</a></li><li><a href="#关于空白final" class="table-of-contents__link toc-highlight">关于空白final</a></li><li><a href="#final内存分配" class="table-of-contents__link toc-highlight">final内存分配</a></li><li><a href="#使用final修饰方法会提高速度和效率吗" class="table-of-contents__link toc-highlight">使用final修饰方法会提高速度和效率吗</a></li><li><a href="#使用final修饰变量会让变量的值不能被改变吗" class="table-of-contents__link toc-highlight">使用final修饰变量会让变量的值不能被改变吗；</a></li><li><a href="#如何保证数组内部不被修改" class="table-of-contents__link toc-highlight">如何保证数组内部不被修改</a></li><li><a href="#final方法的三条规则" class="table-of-contents__link toc-highlight">final方法的三条规则</a></li></ul></li><li><a href="#final-和-jvm的关  系" class="table-of-contents__link toc-highlight">final 和 jvm的关系</a><ul><li><a href="#写-final-域的重排序规则" class="table-of-contents__link toc-highlight">写 final 域的重排序规则</a></li><li><a href="#读-final-域的重排序规则" class="table-of-contents__link toc-highlight">读 final 域的重排序规则</a></li><li><a href="#如果-final-域是引用类型" class="table-of-contents__link toc-highlight">如果 final 域是引用类型</a></li></ul></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
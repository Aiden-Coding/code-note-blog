<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/concurrency/Java并发指南：JUC的核心类AQS详解" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java并发指南：JUC的核心类AQS详解 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java并发指南：JUC的核心类AQS详解 | Tommy"><meta data-rh="true" name="description" content="本文转自：https://www.javadoop.com/post/AbstractQueuedSynchronizer#toc4"><meta data-rh="true" property="og:description" content="本文转自：https://www.javadoop.com/post/AbstractQueuedSynchronizer#toc4"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">Java并发编程学习总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发基础与Java多线程">Java并发指南：并发基础与Java多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发三大问题与volatile关键字，CAS操作">Java并发指南：并发三大问题与volatile关键字，CAS操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：解读Java阻塞队列BlockingQueue">Java并发指南：解读Java阻塞队列BlockingQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现">Java并发指南：深度解读Java线程池设计思想及源码实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM">Java并发指南：深入理解Java内存模型JMM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现">Java并发指南：AQS共享模式与并发工具类的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion">Java并发指南：AQS中的公平锁与非公平锁，Condtion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：ForkJoin并发框架与工作窃取算法剖析">Java并发指南：ForkJoin并发框架与工作窃取算法剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java读写锁ReentrantReadWriteLock源码分析">Java并发指南：Java读写锁ReentrantReadWriteLock源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java内存模型JMM总结">Java并发指南：Java内存模型JMM总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的锁Lock和synchronized">Java并发指南：Java中的锁Lock和synchronized</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析">Java并发指南：JMM中的final关键字解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解">Java并发指南：JUC的核心类AQS详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC中常用的Unsafe和Locksupport">Java并发指南：JUC中常用的Unsafe和Locksupport</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">并发</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java并发指南：JUC的核心类AQS详解</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java并发指南：JUC的核心类AQS详解</h1></header><p>本文转自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer#toc4" target="_blank" rel="noopener noreferrer">https://www.javadoop.com/post/AbstractQueuedSynchronizer#toc4</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章同步发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="简介">简介<a href="#简介" class="hash-link" aria-label="Direct link to 简介" title="Direct link to 简介">​</a></h2>
<p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p>
<p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p>
<p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p>
<p>申明以下几点：</p>
<ol>
<li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li>
<li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li>
<li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-3" target="_blank" rel="noopener noreferrer">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li>
<li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li>
<li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener noreferrer">第二篇文章</a>做了介绍。</li>
<li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="aqs-结构">AQS 结构<a href="#aqs-结构" class="hash-link" aria-label="Direct link to AQS 结构" title="Direct link to AQS 结构">​</a></h2>
<p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient volatile Node head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient volatile Node tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private volatile int state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// if (currentThread == getExclusiveOwnerThread()) {state++}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404200412.png" alt="" class="img_kGBN"></p>
<p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static final class Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 标识节点当前在共享模式下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final Node SHARED = new Node();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 标识节点当前在独占模式下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final Node EXCLUSIVE = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ======== 下面的几个int常量是给waitStatus用的 ===========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** waitStatus value to indicate thread has cancelled */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 代码此线程取消了争抢这个锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int CANCELLED =  1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int SIGNAL    = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** waitStatus value to indicate thread is waiting on condition */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int CONDITION = -2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * waitStatus value to indicate the next acquireShared should</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * unconditionally propagate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 同样的不分析，略过吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int PROPAGATE = -3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // =====================================================</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile int waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 前驱节点的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Node prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 后继节点的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Node next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个就是线程本尊</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Thread thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p>
<p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" class="img_kGBN"></p>
<p>首先，我们先看下 ReentrantLock 的使用方式。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 我用个web开发中的service概念吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class OrderService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ReentrantLock reentrantLock = new ReentrantLock(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void createOrder() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 比如我们同一时间，只允许一个线程创建订单</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reentrantLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通常，lock 之后紧跟着 try 语句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 执行代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 执行代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 执行代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reentrantLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">abstract static class Sync extends AbstractQueuedSynchronizer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public ReentrantLock(boolean fair) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync = fair ? new FairSync() : new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="线程抢锁">线程抢锁<a href="#线程抢锁" class="hash-link" aria-label="Direct link to 线程抢锁" title="Direct link to 线程抢锁">​</a></h2>
<p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static final class FairSync extends Sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final long serialVersionUID = -3000897897090466540L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 争锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 否则，acquireQueued方法会将线程压到队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final void acquire(int arg) { // 此时 arg == 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!tryAcquire(arg) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * recursive call or no waiters or is first.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返  回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // state == 0 此时此刻没有线程持有锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 看看有没有别人在队列中等了半天了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!hasQueuedPredecessors() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 因为刚刚还没人的，我判断过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                compareAndSetState(0, acquires)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里不存在并发问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (current == getExclusiveOwnerThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextc = c + acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nextc &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(nextc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 回到上面一个外层调用方法继续看:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if (!tryAcquire(arg) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Creates and enqueues node for current thread and given mode.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the new node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 此方法的作用是把线程包装成node，同时进入到队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node addWaiter(Node mode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node node = new Node(Thread.currentThread(), mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Try the fast path of enq; backup to full enq on failure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node pred = tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pred != null) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将当前的队尾节点，设置为自己的前驱 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node.prev = pred; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndSetTail(pred, node)) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pred.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 线程入队了，可以返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 仔细看看上面的代码，如果会到这里，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enq(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Inserts node into queue, initializing if necessary. See picture above.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node the node to insert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return node&#x27;s predecessor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 采用自旋的方式入队</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node enq(final Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node t = tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 之前说过，队列为空也会进来  这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (t == null) { // Must initialize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 初始化head节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (compareAndSetHead(new Node()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这个时候有了head，但是tail还是null，设置一下，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    tail = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 下面几行，和上一个方法 addWaiter 是一样的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.prev = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (compareAndSetTail(t, node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    t.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 现在，又回到这段代码了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // if (!tryAcquire(arg) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //     selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final boolean acquireQueued(final Node node, int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean interrupted = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final Node p = node.predecessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 注 意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 所以当前节点可以去试抢一下锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里我们说一下，为什么可以去试试：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (p == head &amp;&amp; tryAcquire(arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setHead(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = null; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return interrupted;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    interrupted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 什么时候 failed 会为 true???</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // tryAcquire() 方法抛异常的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cancelAcquire(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Checks and updates status for a node that failed to acquire.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Returns true if thread should block. This is the main signal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * control in all acquire loops.  Requires that pred == node.prev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pred node&#x27;s predecessor holding status</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node the node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return {@code true} if thread should block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ws = pred.waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ws == Node.SIGNAL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * This node has already set status asking a release</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * to signal it, so it can safely park.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ws &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * Predecessor was cancelled. Skip over predecessors and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * indicate retry.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                node.prev = pred = pred.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } while (pred.waitStatus &gt; 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pred.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * retry to make sure it cannot acquire before parking.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 仔细想想，如果进入到这个分支意味着什么</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个方法返回 false，那么会再走一次 for 循序，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     然后再次进来此方法，此时会从第一个分支返回 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个方法结束根据返回值我们简单分析下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以  后被唤醒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 跳回到前面是这个方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                interrupted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1\. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 那么需要执行parkAndCheckInterrupt():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final boolean parkAndCheckInterrupt() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.park(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Thread.interrupted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2\. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>说到这里，也就明白了，多看几遍<code>final boolean acquireQueued(final Node node, int arg)</code>这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="解锁操作">解锁操作<a href="#解锁操作" class="hash-link" aria-label="Direct link to 解锁操作" title="Direct link to 解锁操作">​</a></h2>
<p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被<code>LockSupport.park(this);</code>挂起停止，等待被唤醒。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void unlock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.release(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean release(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 往后看吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tryRelease(arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node h = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            unparkSuccessor(h);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 回到ReentrantLock看tryRelease方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected final boolean tryRelease(int releases) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = getState() - releases;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalMonitorStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是否完全释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean free = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setExclusiveOwnerThread(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setState(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return free;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Wakes up node&#x27;s successor, if one exists.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param node the node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 唤醒后继 节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 从上面调用处知道，参数node是head头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void unparkSuccessor(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * If status is negative (i.e., possibly needing signal) try</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * to clear in anticipation of signalling.  It is OK if this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * fails or if status is changed by waiting thread.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ws = node.waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ws &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compareAndSetWaitStatus(node, ws, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Thread to unpark is held in successor, which is normally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * just the next node.  But if cancelled or apparently null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * traverse backwards from tail to find the actual</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * non-cancelled successor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node s = node.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (s == null || s.waitStatus &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (t.waitStatus &lt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                s = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (s != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 唤醒线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.unpark(s.thread);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final boolean parkAndCheckInterrupt() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LockSupport.park(this); // 刚刚线程被挂起在这里了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Thread.interrupted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>总结一下吧。</p>
<p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener noreferrer">关于CLH的介绍</a>，写得简单明了。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="示例图解析">示例图解析<a href="#示例图解析" class="hash-link" aria-label="Direct link to 示例图解析" title="Direct link to 示例图解析">​</a></h2>
<p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p>
<p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p>
<p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p>
<p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private Node enq(final Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node t = tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t == null) { // Must initialize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndSetHead(new Node()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tail = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node.prev = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndSetTail(t, node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                t.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404200724.png" alt="" class="img_kGBN"></p>
<p>然后线程 2 入队：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404200745.png" alt="" class="img_kGBN"></p>
<p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p>
<p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230404200816.png" alt="" class="img_kGBN">
这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java并发指南：JMM中的final关键字解析</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC中常用的Unsafe和Locksupport"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java并发指南：JUC中常用的Unsafe和Locksupport</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#简介" class="table-of-contents__link toc-highlight">简介</a></li><li><a href="#aqs-结构" class="table-of-contents__link toc-highlight">AQS 结构</a></li><li><a href="#线程抢锁" class="table-of-contents__link toc-highlight">线程抢锁</a></li><li><a href="#解锁操作" class="table-of-contents__link toc-highlight">解锁操作</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li><li><a href="#示例图解析" class="table-of-contents__link toc-highlight">示例图解析</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java并发指南：Java中的HashMap和ConcurrentHashMap全解析 | Tommy"><meta data-rh="true" name="description" content="本文转自：https://www.javadoop.com/"><meta data-rh="true" property="og:description" content="本文转自：https://www.javadoop.com/"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">Java并发编程学习总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发基础与Java多线程">Java并发指南：并发基础与Java多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发三大问题与volatile关键字，CAS操作">Java并发指南：并发三大问题与volatile关键字，CAS操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：解读Java阻塞队列BlockingQueue">Java并发指南：解读Java阻塞队列BlockingQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现">Java并发指南：深度解读Java线程池设计思想及源码实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM">Java并发指南：深入理解Java内存模型JMM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现">Java并发指南：AQS共享模式与并发工具类的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion">Java并发指南：AQS中的公平锁与非公平锁，Condtion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：ForkJoin并发框架与工作窃取算法剖析">Java并发指南：ForkJoin并发框架与工作窃取算法剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java读写锁ReentrantReadWriteLock源码分析">Java并发指南：Java读写锁ReentrantReadWriteLock源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java内存模型JMM总结">Java并发指南：Java内存模型JMM总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的锁Lock和synchronized">Java并发指南：Java中的锁Lock和synchronized</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析">Java并发指南：JMM中的final关键字解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解">Java并发指南：JUC的核心类AQS详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC中常用的Unsafe和Locksupport">Java并发指南：JUC中常用的Unsafe和Locksupport</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">并发</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</h1></header><p>本文转自：<a href="https://www.javadoop.com/" target="_blank" rel="noopener noreferrer">https://www.javadoop.com/</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章同步发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="前言">前言<a href="#前言" class="hash-link" aria-label="Direct link to 前言" title="Direct link to 前言">​</a></h2>
<p>今天发一篇&quot;水文&quot;，可能很多读者都会表示不理解，不过我想把它作为并发序列文章中不可缺少的一块来介绍。本来以为花不了多少时间的，不过最终还是投入了挺多时间来完成这篇文章的。</p>
<p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p>
<p>阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap  顺序进行阅读，可适当降低阅读门槛。</p>
<p>阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="java7-hashmap">Java7 HashMap<a href="#java7-hashmap" class="hash-link" aria-label="Direct link to Java7 HashMap" title="Direct link to Java7 HashMap">​</a></h2>
<p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p>
<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/map/1.png" alt="1" class="img_kGBN"></p>
<blockquote>
<p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p>
</blockquote>
<p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p>
<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>
<p>loadFactor：负载因子，默认为 0.75。</p>
<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="put-过程分析">put 过程分析<a href="#put-过程分析" class="hash-link" aria-label="Direct link to put 过程分析" title="Direct link to put 过程分析">​</a></h3>
<p>还是比较简单的，跟着代码走一遍吧。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当插入第一个元素的时候，需要先初始化数组大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (table == EMPTY_TABLE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inflateTable(threshold);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return putForNullKey(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1\. 求 key 的 hash 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2\. 找到对应的数组下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = indexFor(hash, table.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3\. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    如果有，直接覆盖，put 方法返回旧值就结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.recordAccess(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 4\. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addEntry(hash, key, value, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="数组初始化">数组初始化<a href="#数组初始化" class="hash-link" aria-label="Direct link to 数组初始化" title="Direct link to 数组初始化">​</a></h4>
<p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void inflateTable(int toSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 保证数组大小一定是 2 的 n 次方。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int capacity = roundUpToPowerOf2(toSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计算扩容阈值：capacity * loadFactor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 算是初始化数组吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = new Entry[capacity];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initHashSeedAsNeeded(capacity); //ignore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="计算具体数组位置">计算具体数组位置<a href="#计算具体数组位置" class="hash-link" aria-label="Direct link to 计算具体数组位置" title="Direct link to 计算具体数组位置">​</a></h4>
<p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static int indexFor(int hash, int length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return hash &amp; (length-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="添加节点到链表中">添加节点到链表中<a href="#添加节点到链表中" class="hash-link" aria-label="Direct link to 添加节点到链表中" title="Direct link to 添加节点到链表中">​</a></h4>
<p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的<strong>表头</strong>。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">void addEntry(int hash, K key, V value, int bucketIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 扩容，后面会介绍一下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize(2 * table.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 扩容以后，重新计算 hash 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hash = (null != key) ? hash(key) : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 重新计算扩容后的新的下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bucketIndex = indexFor(hash, table.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 往下看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    createEntry(hash, key, value, bucketIndex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void createEntry(int hash, K key, V value, int bucketIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="数组扩容">数组扩容<a href="#数组扩容" class="hash-link" aria-label="Direct link to 数组扩容" title="Direct link to 数组扩容">​</a></h4>
<p>前面我们看到，在插入新值的时候，如果<strong>当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素</strong>，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">void resize(int newCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] oldTable = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCapacity = oldTable.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (oldCapacity == MAXIMUM_CAPACITY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        threshold = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] newTable = new Entry[newCapacity];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将原来数组中的值迁移到新的更大的数组中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = newTable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="get-过程分析">get 过程分析<a href="#get-过程分析" class="hash-link" aria-label="Direct link to get 过程分析" title="Direct link to get 过程分析">​</a></h3>
<p>相对于 put 过程，get 过程是非常简单的。</p>
<ol>
<li>根据 key 计算 hash 值。</li>
<li>找到相应的数组下标：hash &amp; (length - 1)。</li>
<li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li>
</ol>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getForNullKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null == entry ? null : entry.getValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>getEntry(key):</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final Entry&lt;K,V&gt; getEntry(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (size == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = (key == null) ? 0 : hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 确定数组下标，然后从头开始遍历链表，直到找到为止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         e != null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="java7-concurrenthashmap">Java7 ConcurrentHashMap<a href="#java7-concurrenthashmap" class="hash-link" aria-label="Direct link to Java7 ConcurrentHashMap" title="Direct link to Java7 ConcurrentHashMap">​</a></h2>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“<strong>槽</strong>”来代表一个 segment。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/map/3.png" alt="3" class="img_kGBN"></p>
<p><strong>concurrencyLevel</strong>：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="初始化">初始化<a href="#初始化" class="hash-link" aria-label="Direct link to 初始化" title="Direct link to 初始化">​</a></h3>
<p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>
<p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public ConcurrentHashMap(int initialCapacity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         float loadFactor, int concurrencyLevel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        concurrencyLevel = MAX_SEGMENTS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Find power-of-two sizes best matching arguments</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sshift = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ssize = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计算并  行级别 ssize，因为要保持并行级别是 2 的 n 次方</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ssize &lt; concurrencyLevel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++sshift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssize &lt;&lt;= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.segmentShift = 32 - sshift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.segmentMask = ssize - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initialCapacity = MAXIMUM_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // initialCapacity 是设置整个 map 初始的大小，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = initialCapacity / ssize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (c * ssize &lt; initialCapacity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插入一个元素不至于扩容，插入第二个的时候才会扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (cap &lt; c)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cap &lt;&lt;= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建 Segment 数组，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 并创建数组的第一个元素 segment[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s0 =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 往数组写入 segment[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.segments = ss;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>初始化完成，我们得到了一个 Segment 数组。</p>
<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为<strong>移位数</strong>和<strong>掩码</strong>，  这两个值马上就会用到</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="put-过程分析-1">put 过程分析<a href="#put-过程分析-1" class="hash-link" aria-label="Direct link to put 过程分析" title="Direct link to put 过程分析">​</a></h3>
<p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1\. 计算 key 的 hash 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2\. 根据 hash 值找到 Segment 数组中的位置 j</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ensureSegment(j) 对 segment[j] 进行初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s = ensureSegment(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3\. 插入新值到 槽 s 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s.put(key, hash, value, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p>Segment 内部是由<strong>数组+链表</strong>组成的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final V put(K key, int hash, V value, boolean onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    先看主流程，后面还会具体介绍这部分内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanAndLockForPut(key, hash, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个是 segment 内部的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt;[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 再利用 hash 值，求应该放置的数组下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = (tab.length - 1) &amp; hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // first 是数组该位置处的链表的表头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (HashEntry&lt;K,V&gt; e = first;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((k = e.key) == key ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (e.hash == hash &amp;&amp; key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (!onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 覆盖旧值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 继续顺着链表走</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (node != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node.setNext(first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int c = count + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rehash(node); // 扩容后面也会具体分析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 其实就是将新的节点设置成原链表的表头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setEntryAt(tab, index, node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count = c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                oldValue = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 解锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="初始化槽-ensuresegment">初始化槽: ensureSegment<a href="#初始化槽-ensuresegment" class="hash-link" aria-label="Direct link to 初始化槽: ensureSegment" title="Direct link to 初始化槽: ensureSegment">​</a></h4>
<p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private Segment&lt;K,V&gt; ensureSegment(int k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Segment&lt;K,V&gt;[] ss = this.segments;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; seg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里看到为什么之前要初始化 segment[0] 了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Segment&lt;K,V&gt; proto = ss[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int cap = proto.table.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float lf = proto.loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int threshold = (int)(cap * lf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化 segment[k] 内部的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            == null) { // 再次检查一遍该槽是否被其他线程初始化了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return seg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>
<blockquote>
<p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p>
<p>感谢评论区的<strong>李子木</strong>，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="获取写入锁-scanandlockforput">获取写入锁: scanAndLockForPut<a href="#获取写入锁-scanandlockforput" class="hash-link" aria-label="Direct link to 获取写入锁: scanAndLockForPut" title="Direct link to 获取写入锁: scanAndLockForPut">​</a></h4>
<p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; e = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; node = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retries = -1; // negative while locating node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 循环获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; f; // to recheck first below</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (retries &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (node == null) // speculatively create node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 进到这里说明数组该位置的链表是空的，没有任何元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (key.equals(e.key))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 顺着链表往下走</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //    lock() 是阻塞方法，直到获取锁后返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (++retries &gt; MAX_SCAN_RETRIES) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (f = entryForHash(this, hash)) != first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = first = f; // re-traverse if entry changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retries = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="扩容-rehash">扩容: rehash<a href="#扩容-rehash" class="hash-link" aria-label="Direct link to 扩容: rehash" title="Direct link to 扩容: rehash">​</a></h4>
<p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 <code>HashEntry&lt;K,V&gt;[]</code> 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void rehash(HashEntry&lt;K,V&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCapacity = oldTable.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2 倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newCapacity = oldCapacity &lt;&lt; 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = (int)(newCapacity * loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建新数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] newTable =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sizeMask = newCapacity - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; oldCapacity ; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // e 是链表的第一个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            HashEntry&lt;K,V&gt; next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 计算应该放置在新数组中的位置，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int idx = e.hash &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (next == null)   // 该位置处只有一个元素，那比较好办</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newTable[idx] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else { // Reuse consecutive sequence at same slot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // e 是链表表头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                HashEntry&lt;K,V&gt; lastRun = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // idx 是当前链表的头结点 e 的新位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int lastIdx = idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (HashEntry&lt;K,V&gt; last = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     last != null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     last = last.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int k = last.hash &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (k != lastIdx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lastIdx = k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lastRun = last;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newTable[lastIdx] = lastRun;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 下面的操作是处理 lastRun 之前的节点，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    V v = p.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int h = p.hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int k = h &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int nodeIndex = node.hash &amp; sizeMask; // add the new node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node.setNext(newTable[nodeIndex]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newTable[nodeIndex] = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = newTable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循 环，第一个 for 有什么用呢？</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆</strong>。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="get-过程分析-1">get 过程分析<a href="#get-过程分析-1" class="hash-link" aria-label="Direct link to get 过程分析" title="Direct link to get 过程分析">​</a></h3>
<p>相对于 put 来说，get 真的不要太简单。</p>
<ol>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ol>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] tab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1\. hash 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2\. 根据 hash 找到对应的 segment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (tab = s.table) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3\. 找到segment 内部数组相应位置的链表，遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="并发问题分析">并发问题分析<a href="#并发问题分析" class="hash-link" aria-label="Direct link to 并发问题分析" title="Direct link to 并发问题分析">​</a></h3>
<p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p>
<ol>
<li>
<p>put 操作的线程安全性。</p>
<ol>
<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>
<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>
<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>
</ol>
</li>
<li>
<p>remove 操作的线程安全性。</p>
<p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>
<p>get 操作需要遍历链表，但是 remove 操作会&quot;破坏&quot;链表。</p>
<p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p>
<p>如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="java8-hashmap">Java8 HashMap<a href="#java8-hashmap" class="hash-link" aria-label="Direct link to Java8 HashMap" title="Direct link to Java8 HashMap">​</a></h2>
<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由<strong>数组+链表+红黑树</strong>组成。</p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为<strong>O(n)</strong>。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间 复杂度为<strong>O(logN)</strong>。</p>
<p>来一张图简单示意一下吧：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/map/2.png" alt="2" class="img_kGBN"></p>
<blockquote>
<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>
</blockquote>
<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用<strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用<strong>TreeNode</strong>。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="put-过程分析-2">put 过程分析<a href="#put-过程分析-2" class="hash-link" aria-label="Direct link to put 过程分析" title="Direct link to put 过程分析">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return putVal(hash(key), key, value, false, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 第四个参数 evict 我们这里不关心</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               boolean evict) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((tab = table) == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = (tab = resize()).length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tab[i] = newNode(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {// 数组该位置有数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; e; K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (p.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (p instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 到这里，说明数组该位置上是一个链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int binCount = 0; ; ++binCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((e = p.next) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = newNode(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        treeifyBin(tab, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!onlyIfAbsent || oldValue == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            afterNodeAccess(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (++size &gt; threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    afterNodeInsertion(evict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="数组扩容-1">数组扩容<a href="#数组扩容-1" class="hash-link" aria-label="Direct link to 数组扩容" title="Direct link to 数组扩容">​</a></h4>
<p>resize() 方法用于<strong>初始化数组</strong>或<strong>数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final Node&lt;K,V&gt;[] resize() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] oldTab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldThr = threshold;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newCap, newThr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (oldCap &gt; 0) { // 对应数组扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threshold = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将数组大小扩大一倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将阈值扩大一倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCap = oldThr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (newThr == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float ft = (float)newCap * loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  (int)ft : Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = newThr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用新的数组大小初始化新的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (oldTab != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开始遍历原数组，进行数据迁移。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; oldCap; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt; e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((e = oldTab[j]) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                oldTab[j] = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.next == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果是红黑树，具体我们就不展开了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else if (e instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这块是处理链表的情况，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if ((e.hash &amp; oldCap) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (loTail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                loHead = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                loTail.next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            loTail = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (hiTail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                hiHead = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                hiTail.next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            hiTail = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } while ((e = next) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (loTail != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        loTail.next = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 第一条链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        newTab[j] = loHead;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (hiTail != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        hiTail.next = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        newTab[j + oldCap] = hiHead;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return newTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="get-过程分析-2">get 过程分析<a href="#get-过程分析-2" class="hash-link" aria-label="Direct link to get 过程分析" title="Direct link to get 过程分析">​</a></h3>
<p>相对于 put 来说，get 真的太简单了。</p>
<ol>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>
<li>遍历链表，直到找到相等(==或equals)的 key</li>
</ol>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt; e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final Node&lt;K,V&gt; getNode(int hash, Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (first = tab[(n - 1) &amp; hash]) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断第一个节点是不是就是需要的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (first.hash == hash &amp;&amp; // always check first node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((e = first.next) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 判断是否是红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (first instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 链表遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } while ((e = e.next) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="java8-concurrenthashmap">Java8 ConcurrentHashMap<a href="#java8-concurrenthashmap" class="hash-link" aria-label="Direct link to Java8 ConcurrentHashMap" title="Direct link to Java8 ConcurrentHashMap">​</a></h2>
<p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复  杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>
<p><strong>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</strong></p>
<p>我们先用一个示意图来描述下其结构：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/map/4.png" alt="4" class="img_kGBN"></p>
<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="初始化-1">初始化<a href="#初始化-1" class="hash-link" aria-label="Direct link to 初始化" title="Direct link to 初始化">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 这构造函数里，什么都不干</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ConcurrentHashMap() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public ConcurrentHashMap(int initialCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               MAXIMUM_CAPACITY :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.sizeCtl = cap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>
<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>
<p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="put-过程分析-3">put 过程分析<a href="#put-过程分析-3" class="hash-link" aria-label="Direct link to put 过程分析" title="Direct link to put 过程分析">​</a></h3>
<p>仔细地一行一行代码看下去：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return putVal(key, value, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final V putVal(K key, V value, boolean onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null || value == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 得到 hash 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = spread(key.hashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用于记录相应链表的长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int binCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Node&lt;K,V&gt;[] tab = table;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; f; int n, i, fh;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果数组&quot;空&quot;，进行数组初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tab == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 初始化数组，后面会详细介绍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tab = initTable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找该 hash 值对应的数组下标，得到第一个节点 f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果数组该位置为空，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (casTabAt(tab, i, null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;                   // no lock when adding to empty bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((fh = f.hash) == MOVED)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tab = helpTransfer(tab, f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else { // 到这里就是说，f 是该位置的头结点，而且不为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldVal = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取数组该位置的头结点的监视器锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (f) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (tabAt(tab, i) == f) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (fh &gt;= 0) { // 头结点的 hash 值大于 0，说明是链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 用于累加，记录链表的长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        binCount = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 遍历链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        for (Node&lt;K,V&gt; e = f;; ++binCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            K ek;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                ((ek = e.key) == key ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 (ek != null &amp;&amp; key.equals(ek)))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                oldVal = e.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                if (!onlyIfAbsent)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    e.val = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 到了链表的最末端，将这个新值放到链表的最后面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Node&lt;K,V&gt; pred = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if ((e = e.next) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                          value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (f instanceof TreeBin) { // 红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt; p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        binCount = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 调用红黑树的插值方法插入新节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                       value)) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            oldVal = p.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (!onlyIfAbsent)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                p.val = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (binCount != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //    具体源码我们就不看了，扩容部分后面说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    treeifyBin(tab, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (oldVal != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return oldVal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addCount(1L, binCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="初始化数组inittable">初始化数组：initTable<a href="#初始化数组inittable" class="hash-link" aria-label="Direct link to 初始化数组：initTable" title="Direct link to 初始化数组：initTable">​</a></h4>
<p>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。</p>
<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final Node&lt;K,V&gt;[] initTable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] tab; int sc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while ((tab = table) == null || tab.length == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((sc = sizeCtl) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.yield(); // lost initialization race; just spin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((tab = table) == null || tab.length == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // DEFAULT_CAPACITY 默认初始容量是 16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 初始化数组，长度为 16 或初始化时提供的长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将这个数组赋值给 table，table 是 volatile 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    table = tab = nt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果 n 为 16 的话，那么这里 sc = 12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 其实就是 0.75 * n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sc = n - (n &gt;&gt;&gt; 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 设置 sizeCtl 为 sc，我们就当是 12 吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sizeCtl = sc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return tab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="链表转红黑树-treeifybin">链表转红黑树: treeifyBin<a href="#链表转红黑树-treeifybin" class="hash-link" aria-label="Direct link to 链表转红黑树: treeifyBin" title="Direct link to 链表转红黑树: treeifyBin">​</a></h4>
<p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt; b; int n, sc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tab != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // MIN_TREEIFY_CAPACITY 为 64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 后面我们再详细分析这个方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tryPresize(n &lt;&lt; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // b 是头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (tabAt(tab, index) == b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 下面就是遍历链表，建立一颗红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TreeNode&lt;K,V&gt; p =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              null, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if ((p.prev = tl) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            hd = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            tl.next = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        tl = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将红黑树设置到数组相应位置中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="扩容trypresize">扩容：tryPresize<a href="#扩容trypresize" class="hash-link" aria-label="Direct link to 扩容：tryPresize" title="Direct link to 扩容：tryPresize">​</a></h3>
<p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final void tryPresize(int size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while ((sc = sizeCtl) &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt;[] tab = table; int n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tab == null || (n = tab.length) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            n = (sc &gt; c) ? sc : c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (table == tab) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        table = nt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        sc = n - (n &gt;&gt;&gt; 2); // 0.75 * n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sizeCtl = sc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (tab == table) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 我没看懂 rs 的真正含义是什么，不过也关系不大</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int rs = resizeStamp(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sc &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Node&lt;K,V&gt;[] nt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    transferIndex &lt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 2\. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //    此时 nextTab 不为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    transfer(tab, nt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1\. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  调用 transfer 方法，此时 nextTab 参数为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                transfer(tab, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行<strong>1 次 transfer(tab, null) + 多次 transfer(tab, nt)</strong>，这里怎么结束循环的需要看完 transfer 源码才清楚。</p>
<h4 class="anchor anchorWithStickyNavbar_HWLp" id="数据迁移transfer">数据迁移：transfer<a href="#数据迁移transfer" class="hash-link" aria-label="Direct link to 数据迁移：transfer" title="Direct link to 数据迁移：transfer">​</a></h4>
<p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>
<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>
<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>
<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是<strong>步长</strong>，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>
<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后<strong>从后往前</strong>的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int n = tab.length, stride;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 nextTab 为 null，先进行一次初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (nextTab == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 容量翻倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nextTab = nt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable ex) {      // try to cope with OOME</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sizeCtl = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // nextTable 是 ConcurrentHashMap 中的属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nextTable = nextTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transferIndex = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int nextn = nextTab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ForwardingNode 翻译过来就是正在被迁移的 Node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    所以它其实相当于是一个标志。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean advance = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // i 是位置索引，bound 是边界，注意是从后往前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0, bound = 0;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; f; int fh;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 下面这个 while 真的是不好理解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // advance 为 true 表示可以进行下一个位置的迁移了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (advance) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextIndex, nextBound;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (--i &gt;= bound || finishing)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                advance = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将 transferIndex 值赋给 nextIndex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if ((nextIndex = transferIndex) &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                advance = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (U.compareAndSwapInt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     (this, TRANSFERINDEX, nextIndex,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      nextBound = (nextIndex &gt; stride ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   nextIndex - stride : 0))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bound = nextBound;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i = nextIndex - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                advance = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int sc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (finishing) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 所有的迁移操作已经完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nextTable = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将新的 nextTab 赋值给 table 属性，完成迁移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                table = nextTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 任务结束，方法退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                finishing = advance = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i = n; // recheck before commit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((f = tabAt(tab, i)) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            advance = casTabAt(tab, i, null, fwd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if ((fh = f.hash) == MOVED)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            advance = true; // already processed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (f) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (tabAt(tab, i) == f) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;K,V&gt; ln, hn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 头结点的 hash 大于 0，说明是链表的 Node 节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (fh &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 需要将链表一分为二，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int runBit = fh &amp; n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Node&lt;K,V&gt; lastRun = f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            int b = p.hash &amp; n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (b != runBit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                runBit = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                lastRun = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (runBit == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ln = lastRun;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            hn = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            hn = lastRun;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ln = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if ((ph &amp; n) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 其中的一个链表放在新数组的位置 i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(nextTab, i, ln);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 另一个链表放在新数组的位置 i+n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(nextTab, i + n, hn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(tab, i, fwd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // advance 设置为 true，代表该位置已经迁移完毕</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        advance = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (f instanceof TreeBin) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 红黑树的迁移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int lc = 0, hc = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            int h = e.hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                (h, e.key, e.val, null, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if ((h &amp; n) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                if ((p.prev = loTail) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    lo = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    loTail.next = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                loTail = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                ++lc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                if ((p.prev = hiTail) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    hi = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    hiTail.next = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                hiTail = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                ++hc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 将 ln 放置在新数组的位置 i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(nextTab, i, ln);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 将 hn 放置在新数组的位置 i+n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(nextTab, i + n, hn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setTabAt(tab, i, fwd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // advance 设置为 true，代表该位置已经迁移完毕</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        advance = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>
<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="get-过程分析-3">get 过程分析<a href="#get-过程分析-3" class="hash-link" aria-label="Direct link to get 过程分析" title="Direct link to get 过程分析">​</a></h3>
<p>get 方法从来都是最简单的，这里也不例外：</p>
<ol>
<li>计算 hash 值</li>
<li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li>
<li>根据该位置处结点性质进行相应查找<!-- -->
<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
</li>
</ol>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h = spread(key.hashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (e = tabAt(tab, (n - 1) &amp; h)) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断头结点是否就是我们需要的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((eh = e.hash) == h) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return e.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (eh &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (p = e.find(h, key)) != null ? p.val : null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while ((e = e.next) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e.hash == h &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return e.val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p>
<p>看源码不算  是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p>
<p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分。</p>
<p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~~~</p>
<p>（全文完）</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的锁Lock和synchronized"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java并发指南：Java中的锁Lock和synchronized</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java并发指南：JMM中的final关键字解析</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#java7-hashmap" class="table-of-contents__link toc-highlight">Java7 HashMap</a><ul><li><a href="#put-过程分析" class="table-of-contents__link toc-highlight">put 过程分析</a></li><li><a href="#get-过程分析" class="table-of-contents__link toc-highlight">get 过程分析</a></li></ul></li><li><a href="#java7-concurrenthashmap" class="table-of-contents__link toc-highlight">Java7 ConcurrentHashMap</a><ul><li><a href="#初始化" class="table-of-contents__link toc-highlight">初始化</a></li><li><a href="#put-过程分析-1" class="table-of-contents__link toc-highlight">put 过程分析</a></li><li><a href="#get-过程分析-1" class="table-of-contents__link toc-highlight">get 过程分析</a></li><li><a href="#并发问题分析" class="table-of-contents__link toc-highlight">并发问题分析</a></li></ul></li><li><a href="#java8-hashmap" class="table-of-contents__link toc-highlight">Java8 HashMap</a><ul><li><a href="#put-过程分析-2" class="table-of-contents__link toc-highlight">put 过程分析</a></li><li><a href="#get-过程分析-2" class="table-of-contents__link toc-highlight">get 过程分析</a></li></ul></li><li><a href="#java8-concurrenthashmap" class="table-of-contents__link toc-highlight">Java8 ConcurrentHashMap</a><ul><li><a href="#初始化-1" class="table-of-contents__link toc-highlight">初始化</a></li><li><a href="#put-过程分析-3" class="table-of-contents__link toc-highlight">put 过程分析</a></li><li><a href="#扩容trypresize" class="table-of-contents__link toc-highlight">扩容：tryPresize</a></li><li><a href="#get-过程分析-3" class="table-of-contents__link toc-highlight">get 过程分析</a></li></ul></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
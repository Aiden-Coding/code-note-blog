<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java并发指南：深度解读Java线程池设计思想及源码实现 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java并发指南：深度解读Java线程池设计思想及源码实现 | Tommy"><meta data-rh="true" name="description" content="本文转自：https://www.javadoop.com/"><meta data-rh="true" property="og:description" content="本文转自：https://www.javadoop.com/"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">Java并发编程学习总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发基础与Java多线程">Java并发指南：并发基础与Java多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发三大问题与volatile关键字，CAS操作">Java并发指南：并发三大问题与volatile关键字，CAS操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：解读Java阻塞队列BlockingQueue">Java并发指南：解读Java阻塞队列BlockingQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现">Java并发指南：深度解读Java线程池设计思想及源码实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM">Java并发指南：深入理解Java内存模型JMM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现">Java并发指南：AQS共享模式与并发工具类的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion">Java并发指南：AQS中的公平锁与非公平锁，Condtion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：ForkJoin并发框架与工作窃取算法剖析">Java并发指南：ForkJoin并发框架与工作窃取算法剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java读写锁ReentrantReadWriteLock源码分析">Java并发指南：Java读写锁ReentrantReadWriteLock源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java内存模型JMM总结">Java并发指南：Java内存模型JMM总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的锁Lock和synchronized">Java并发指南：Java中的锁Lock和synchronized</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析">Java并发指南：JMM中的final关键字解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解">Java并发指南：JUC的核心类AQS详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC中常用的Unsafe和Locksupport">Java并发指南：JUC中常用的Unsafe和Locksupport</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">并发</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java并发指南：深度解读Java线程池设计思想及源码实现</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java并发指南：深度解读Java线程池设计思想及源码实现</h1></header><p>本文转自：<a href="https://www.javadoop.com/" target="_blank" rel="noopener noreferrer">https://www.javadoop.com/</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章同步发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="前言">前言<a href="#前言" class="hash-link" aria-label="Direct link to 前言" title="Direct link to 前言">​</a></h2>
<p>我相信大家都看过很多的关于线程池的文章，基本上也是面试的时候必问的，如果你在看过很多文章以后，还是一知半解的，那希望这篇文章能让你真正的掌握好 Java 线程池。</p>
<p>本文一大重点是源码解析，同时会有少量篇幅介绍线程池设计思想以及作者 Doug Lea 实现过程中的一些巧妙用法。本文还是会一行行关键代码进行分析，目的是为了让那些自己看源码不是很理解的同学可以得到参考。</p>
<p>线程池是非常重要的工具，如果你要成为一个好的工程师，还是得比较好地掌握这个知识，很多线上问题都是因为没有用好线程池导致的。即使你为了谋生，也要知道，这基本上是面试必问的题目，而且面试官很容易从被面试者的回答 中捕捉到被面试者的技术水平。</p>
<p>本文略长，建议在 pc 上阅读，边看文章边翻源码（Java7 和 Java8 都一样），建议想好好看的读者抽出至少 30 分钟的整块时间来阅读。当然，如果读者仅为面试准备，可以直接滑到最后的<strong>总结</strong>部分。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总览">总览<a href="#总览" class="hash-link" aria-label="Direct link to 总览" title="Direct link to 总览">​</a></h2>
<p>开篇来一些废话。下图是 java 线程池几个相关类的继承结构：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/java-thread-pool/1.jpg" alt="1" class="img_kGBN"></p>
<p>先简单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 execute(Runnable runnable) 接口方法定义。</p>
<p>ExecutorService 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以<strong>一般来说我们会使用这个接口</strong>。</p>
<p>然后再下来一层是 AbstractExecutorService，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p>
<p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p>
<p>另外，我们还涉及到下图中的这些类：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/java-thread-pool/others.png" alt="others" class="img_kGBN"></p>
<p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newCachedThreadPool() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  60L, TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newFixedThreadPool(int nThreads) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  0L, TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p>
<p>当然，线程池中的 BlockingQueue 也是非常重要的概念，如果线程数达到 corePoolSize，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行。这里的 BlockingQueue 通常我们使用其实现类 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue，每个实现类都有不同的特征，使用场景之后会慢慢分析。想要详细了解各个 BlockingQueue 的读者，可以参考我的前面的一篇对 BlockingQueue 的各个实现类进行详细分析的文章。</p>
<blockquote>
<p>把事情说完整：除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 ThreadPoolExecutor，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p>
</blockquote>
<p>以上就是本文要介绍的知识，废话不多说，开始进入正文。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="executor-接口">Executor 接口<a href="#executor-接口" class="hash-link" aria-label="Direct link to Executor 接口" title="Direct link to Executor 接口">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/* </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author Doug Lea</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void execute(Runnable command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们可以看到 Executor 接口非常简单，就一个<code>void execute(Runnable command)</code>方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p>
<p>我们经常这样启动一个线程：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">new Thread(new Runnable(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).start();</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>用了线程池 Executor 后就可以像下面这么使用：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">Executor executor = anExecutor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executor.execute(new RunnableTask1());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executor.execute(new RunnableTask2());</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">class DirectExecutor implements Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void execute(Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r.run();// 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">class ThreadPerTaskExecutor implements Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void execute(Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(r).start();  // 每个任务都用一个新的线程来执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">class SerialExecutor implements Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 任务队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个才是真正的执行器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Executor executor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前正在执行的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Runnable active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 初始化的时候，指定执行器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SerialExecutor(Executor executor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.executor = executor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void execute(final Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tasks.offer(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    r.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    scheduleNext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (active == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            scheduleNext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected synchronized void scheduleNext() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((active = tasks.poll()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 具体的执行转给真正的执行器 executor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(active);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自<code>Executor</code>接口的<code>ExecutorService</code>接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="executorservice">ExecutorService<a href="#executorservice" class="hash-link" aria-label="Direct link to ExecutorService" title="Direct link to ExecutorService">​</a></h2>
<p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">ExecutorService executor = Executors.newFixedThreadPool(args...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ExecutorService executor = Executors.newCachedThreadPool(args...);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p>
<p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ExecutorService extends Executor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭线程池，已提交的任务继续执行，不接受 继续提交新任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Runnable&gt; shutdownNow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 线程池是否已关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isShutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isTerminated();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等待所有任务完成，并设置超时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 提交一个 Callable 任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为 Runnable 的 run 方法本身并不返回任何东西</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 提交一个 Runnable 任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Future&lt;?&gt; submit(Runnable task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 执行所有任务，返回 Future 类型的一个 list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也是执行所有任务，但是这里设置了超时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException, ExecutionException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException, ExecutionException, TimeoutException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="futuretask">FutureTask<a href="#futuretask" class="hash-link" aria-label="Direct link to FutureTask" title="Direct link to FutureTask">​</a></h2>
<p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">Future      Runnable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   \           /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    \         /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   RunnableFuture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      FutureTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以每个 Runnable 通常都先包装成 FutureTask，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">然后调用 executor.execute(Runnable command) 将其提交给线程池</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常，如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其实到时候会通过这两个参数，将其包装成 Callable。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Callable&lt;V&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V call() throws Exception;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在这里，就不展开说 FutureTask 类了，因为本文篇幅本来就够大了，这里我们需要知道怎么用就行了。</p>
<p>下面，我们来看看<code>ExecutorService</code>的抽象实现<code>AbstractExecutorService</code>。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="abstractexecutorservice">AbstractExecutorService<a href="#abstractexecutorservice" class="hash-link" aria-label="Direct link to AbstractExecutorService" title="Direct link to AbstractExecutorService">​</a></h2>
<p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。</p>
<p>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的<code>void execute(Runnable command)</code>由于不需要获取结果，不会进行 FutureTask 的包装。</p>
<blockquote>
<p>需要获取结果（FutureTask），用 submit 方法，不需要获取结果，可以用 execute 方法。</p>
</blockquote>
<p>下面，我将一行一行源码地来分析这个类，跟着源码来看看其实现吧：</p>
<blockquote>
<p>Tips: invokeAny 和 invokeAll 方法占了这整个类的绝大多数篇幅，读者可以选择适当跳过，因为它们可能在你的实践中使用的频次比较低，而且它们不带有承前启后的作用，不用担心会漏掉什么导致看不懂后面的代码。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractExecutorService implements ExecutorService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new FutureTask&lt;T&gt;(runnable, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new FutureTask&lt;T&gt;(callable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 提交任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Future&lt;?&gt; submit(Runnable task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. 将任务包装成 FutureTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. 交给执行器执行，execute 方法由具体的子类来实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 前面也说了，FutureTask 间接实现了Runnable 接口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. 将任务包装成 FutureTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. 交给执行器执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. 将任务包装成 FutureTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. 交给执行器执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            boolean timed, long nanos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException, TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tasks == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 任务数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ntasks = tasks.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ntasks == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Future&lt;T&gt;&gt; futures= new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorCompletionService&lt;T&gt; ecs =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new ExecutorCompletionService&lt;T&gt;(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ExecutionException ee = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long lastTime = timed ? System.nanoTime() : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            futures.add(ecs.submit(it.next()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 提交了一个任务，所以任务数量减 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --ntasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int active = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Future&lt;T&gt; f = ecs.poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 为 null，说明刚刚提交的第一个线程还没有执行完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (f == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ntasks &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        --ntasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        futures.add(ecs.submit(it.next()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ++active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 2018-02-23 感谢读者 newmicro 的 comment，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //  这里的 active == 0，说明所有的任务都执行失败，那么这里是 for 循环出口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (active == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (timed) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 带等待的 poll 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (f == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            throw new TimeoutException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        long now = System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        nanos -= now - lastTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lastTime = now;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // take() 方法会阻塞，直到有元素返回，说明有任务结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f = ecs.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * 我感觉上面这一段并不是很好理解，这里简单说下。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * 1\. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 *     那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * 2\. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       这件事情上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * 3\. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       等待获取第一个执行结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 * 4\. 如果所有的任务都执行失败，也就是说 future 都返回了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       但是 f.get() 抛出异常，那么从 active == 0 分支出去(感谢 newmicro 提出)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         // 当然，这个需要看下面的 if 分支。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 有任务结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (f != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    --active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 返回执行结果，如果有异常，都包装成 ExecutionException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return f.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (ExecutionException eex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ee = eex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (RuntimeException rex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ee = new ExecutionException(rex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }// 注意看 for 循环的范围，一直到这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ee == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ee = new ExecutionException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw ee;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 方法退出之前，取消其他的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Future&lt;T&gt; f : futures)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                f.cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return doInvokeAny(tasks, false, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (TimeoutException cannotHappen) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            assert false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, ExecutionException, TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return doInvokeAny(tasks, true, unit.toNanos(timeout));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 执行所有的任务，返回任务结果。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tasks == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean done = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个很简单</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Callable&lt;T&gt; t : tasks) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 包装成 FutureTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                futures.add(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 提交任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                execute(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Future&lt;T&gt; f : futures) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!f.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 这是一个阻塞方法，直到获取到值，或抛出了异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (CancellationException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (ExecutionException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            done = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个方法返回是真正的返回，任务都结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 为什么要这个？就是上面说的有异常的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!done)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Future&lt;T&gt; f : futures)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    f.cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 带超时的 invokeAll，我们找不同吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tasks == null || unit == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long nanos = unit.toNanos(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean done = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Callable&lt;T&gt; t : tasks)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                futures.add(newTaskFor(t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long lastTime = System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 每提交一个任务，检测一次是否超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (it.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                execute((Runnable)(it.next()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                long now = System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nanos -= now - lastTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastTime = now;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (nanos &lt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Future&lt;T&gt; f : futures) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!f.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (nanos &lt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 因为上面其实已经用掉了一些时间了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (CancellationException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (ExecutionException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (TimeoutException toe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long now = System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    nanos -= now - lastTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastTime = now;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            done = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return futures;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!done)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Future&lt;T&gt; f : futures)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    f.cancel(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实  现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p>
<blockquote>
<p>鉴于本文的篇幅，我觉得看到这里的读者应该已经不多了，大家都习惯了快餐文化。我写的每篇文章都力求让读者可以通过我的一篇文章而对相关内容有全面的了解，所以篇幅不免长了些。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="threadpoolexecutor">ThreadPoolExecutor<a href="#threadpoolexecutor" class="hash-link" aria-label="Direct link to ThreadPoolExecutor" title="Direct link to ThreadPoolExecutor">​</a></h2>
<p>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p>
<p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。当然，这不是本文关注的重点，下面，还是赶紧进行源码分析吧。</p>
<p>首先，我们来看看线程池实现中的几个概念和处理流程。</p>
<p>我们先回顾下提交任务的几个方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public Future&lt;?&gt; submit(Runnable task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (task == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    execute(ftask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ftask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new Thread(<strong>runnable</strong>).start() 中的，此处的这个参数不是用于启动线程的，这里指的是<strong>任务</strong>，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p>
<p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法。</p>
<p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/java-thread-pool/pool-1.png" alt="pool-1" class="img_kGBN"></p>
<p>当然，上图没有考虑队列是否有界，提交任务时队列满了怎么办？什么情况下会创建新的线程？提交任务时线程池满了怎么办？空闲线程怎么关掉？这些问题下面我们会一一解决。</p>
<p>我们经常会使用<code>Executors</code>这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newFixedThreadPool(int nThreads) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  0L, TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newCachedThreadPool() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  60L, TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里先不 说有什么区别，它们最终都会导向这个构造方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    public ThreadPoolExecutor(int corePoolSize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              int maximumPoolSize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              long keepAliveTime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              TimeUnit unit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              ThreadFactory threadFactory,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              RejectedExecutionHandler handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (corePoolSize &lt; 0 ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maximumPoolSize &lt;= 0 ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            maximumPoolSize &lt; corePoolSize ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            keepAliveTime &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这几个参数都是必须要有的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (workQueue == null || threadFactory == null || handler == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.corePoolSize = corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.maximumPoolSize = maximumPoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.workQueue = workQueue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.threadFactory = threadFactory;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.handler = handler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p>
<ul>
<li>
<p>corePoolSize</p>
<blockquote>
<p>核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</p>
</blockquote>
</li>
<li>
<p>maximumPoolSize</p>
<blockquote>
<p>最大线程数，线程池允许创建的最大线程数。</p>
</blockquote>
</li>
<li>
<p>workQueue</p>
<blockquote>
<p>任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</p>
</blockquote>
</li>
<li>
<p>keepAliveTime</p>
<blockquote>
<p>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用<code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</p>
</blockquote>
</li>
<li>
<p>threadFactory</p>
<blockquote>
<p>用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</p>
</blockquote>
</li>
<li>
<p>handler：</p>
<blockquote>
<p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</p>
</blockquote>
</li>
</ul>
<p>除了上面几个属性外，我们再看看其他重要的属性。</p>
<p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位  ，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 000 11111111111111111111111111111</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 以我们现在计算机的实际情况，这个数量还是够用的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 我们说了，线程池的状态存放在高 3 位中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 000 00000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 001 00000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 010 00000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 011 00000000000000000000000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int workerCountOf(int c)  { return c &amp; CAPACITY; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int ctlOf(int rs, int wc) { return rs | wc; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Bit field accessors that don&#x27;t require unpacking ctl.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * These depend on the bit layout and on workerCount being never negative.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static boolean runStateLessThan(int c, int s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return c &lt; s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static boolean runStateAtLeast(int c, int s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return c &gt;= s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static boolean isRunning(int c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return c &lt; SHUTDOWN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p>
<p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p>
<ul>
<li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li>
<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>
</ul>
<blockquote>
<p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p>
</blockquote>
<p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li>
<li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li>
<li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li>
<li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li>
</ul>
<p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p>
<p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道<strong>任务是 Runnable（内部变量名叫 task 或 command），线程是 Worker</strong>。</p>
<p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式（对 AQS 源码感兴趣的读者请参看我之前写的几篇文章）。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final class Worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extends AbstractQueuedSynchronizer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    implements Runnable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final long serialVersionUID = 6138294804551838833L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个是真正的线程，任务靠你啦</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Thread thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当然了，也可以为 null，这样线程起 来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Runnable firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile long completedTasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Worker(Runnable firstTask) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setState(-1); // inhibit interrupts until runWorker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.firstTask = firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用 ThreadFactory 来创建一个新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.thread = getThreadFactory().newThread(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里调用了外部类的 runWorker 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        runWorker(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void execute(Runnable command) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (command == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (workerCountOf(c) &lt; corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 至于执行的结果，到时候会包装到 FutureTask 中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回 false 代表线程池不允许提交任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (addWorker(command, true))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int recheck = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (workerCountOf(recheck) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            addWorker(null, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 workQueue 队列满了，那么进入到这个分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 以 maximumPoolSize 为界创建新的 worker，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (!addWorker(command, false))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。</p>
<p>从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p>
</blockquote>
<p>上面这些一时半会也不可能全部消化搞定，我们先继续往下吧，到时候再回头看几遍。</p>
<p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界限，也就说创建这个线程的时候，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         如果是 false，代表使用最大线程数 maximumPoolSize 作为界限</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean addWorker(Runnable firstTask, boolean core) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retry:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rs = runStateOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个非常不好理解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. firstTask != null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3\. workQueue.isEmpty()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 简单分析下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这是因为 SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ! (rs == SHUTDOWN &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               firstTask == null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               ! workQueue.isEmpty()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int wc = workerCountOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (wc &gt;= CAPACITY ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndIncrementWorkerCount(c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break retry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 由于有并发，重新再读取一下 ctl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那么需要回到外层的for循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (runStateOf(c) != rs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue retry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // else CAS failed due to workerCount change; retry inner loop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // worker 是否已经启动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean workerStarted = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是否已将这个 worker 添加到 workers 这个 HashSet 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean workerAdded = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Worker w = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final ReentrantLock mainLock = this.mainLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 把 firstTask 传给 worker 的构造方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        w = new Worker(firstTask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 取 worker 中的线程对象，之前说了，Worker的构 造方法会调用 ThreadFactory 来创建一个新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread t = w.thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mainLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int rs = runStateOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (rs &lt; SHUTDOWN ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // worker 里面的 thread 可不能是已经启动的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (t.isAlive())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        throw new IllegalThreadStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 加到 workers 这个 HashSet 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    workers.add(w);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int s = workers.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // largestPoolSize 用于记录 workers 中的个数的最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (s &gt; largestPoolSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        largestPoolSize = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    workerAdded = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                mainLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 添加成功的话，启动这个线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (workerAdded) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 启动线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                t.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                workerStarted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (! workerStarted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            addWorkerFailed(w);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回线程是否启动成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return workerStarted;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>简单看下 addWorkFailed 的处理：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// workers 中删除掉相应的 worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// workCount 减 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void addWorkerFailed(Worker w) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock mainLock = this.mainLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mainLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (w != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            workers.remove(w);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        decrementWorkerCount();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // rechecks for termination, in case the existence of this worker was holding up termination</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tryTerminate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mainLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>回过头来，继续往下走。我们知道，worker 中的线程 start 后，其 run 方法会调用 runWorker 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// Worker 类的 run() 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    runWorker(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>继续往下看 runWorker 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final void runWorker(Worker w) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread wt = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该线程的第一个任务(如果有的话)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Runnable task = w.firstTask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    w.firstTask = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    w.unlock(); // allow interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean completedAbruptly = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 循环调用 getTask 获取任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (task != null || (task = getTask()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            w.lock();          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (Thread.interrupted() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                !wt.isInterrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wt.interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这是一个钩子方法，留给需要的子类实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                beforeExecute(wt, task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Throwable thrown = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 到这里终于可以执行任务了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    task.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (RuntimeException x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    thrown = x; throw x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Error x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    thrown = x; throw x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Throwable x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 这里不允许抛出 Throwable，所以转换为 Error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    thrown = x; throw new Error(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    afterExecute(task, thrown);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 置空 task，准备 getTask 获取下一个任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                task = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 累加完成的任务数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                w.completedTasks++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 释放掉 worker 的独占锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                w.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        completedAbruptly = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果到这里，需要执行线程关闭：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. 说明 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. 任务执行过程  中发生了异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        processWorkerExit(w, completedAbruptly);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们看看 getTask() 是怎么获取任务的，这个方法写得真的很好，每一行都很简单，组合起来却所有的情况都想好了：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 此方法有三种可能：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1\. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      它们会一直等待任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2\. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3\. 如果发生了以下条件，此方法必须返回 null:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Runnable getTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean timedOut = false; // Did the last poll() time out?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retry:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rs = runStateOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 两种可能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. rs &gt;= STOP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // CAS 操作，减少工作线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            decrementWorkerCount();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean timed;      // Are workers subject to culling?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int wc = workerCountOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    换句话说，返回 null 意味着关闭线程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那是因为有可能开发者调用了 setMaximumPoolSize() 将线程池的 maximumPoolSize 调小了，那么多余的 Worker 就需要被关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareAndDecrementWorkerCount(c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            c = ctl.get();  // Re-read ctl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // compareAndDecrementWorkerCount(c)  失败，线程池中的线程数发生了改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (runStateOf(c) != rs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue retry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // else CAS failed due to workerCount change; retry inner loop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // wc &lt;= maximumPoolSize 同时没有超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 到 workQueue 中获取任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Runnable r = timed ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                workQueue.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (r != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            timedOut = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException retry) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果此 worker 发生了中断，采取的方案是重试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            timedOut = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void execute(Runnable command) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (command == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (workerCountOf(c) &lt; corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 至于执行的结果，到时候会包装到 FutureTask 中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回 false 代表线程池不允许提交任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (addWorker(command, true))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int recheck = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (workerCountOf(recheck) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            addWorker(null, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 workQueue 队列满了，那么进入到这个分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 以 maximumPoolSize 为界创建新的 worker，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (!addWorker(command, false))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上面各个分支中，有两种情况会调用 reject(command) 来处理任务，因为按照正常的流程，线程池此时不能接受这个任务，所以需要执行我们的拒绝策略。接下来，我们说一说 ThreadPoolExecutor 中的拒绝策略。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final void reject(Runnable command) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    handler.rejectedExecution(command, this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此处的 handler 我们需要在构造线程池的时候就传入这个参数，它是 RejectedExecutionHandler 的实例。</p>
<p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static class CallerRunsPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CallerRunsPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!e.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            r.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 不管怎样，直接抛出 RejectedExecutionException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static class AbortPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AbortPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             &quot; rejected from &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             e.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 不做任何处理，直接忽略掉这个任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static class DiscardPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DiscardPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个相对霸道一点，如果线程池没有被关闭的话，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static class DiscardOldestPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DiscardOldestPolicy() { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!e.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.getQueue().poll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.execute(r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到这里，ThreadPoolExecutor 的源码算是分析结束了。单纯从源码的难易程度来说，ThreadPoolExecutor 的源码还算是比较简单的，只是需要我们静下心来好好看看罢了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="executors">Executors<a href="#executors" class="hash-link" aria-label="Direct link to Executors" title="Direct link to Executors">​</a></h2>
<p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p>
<ul>
<li>生成一个固定大小的线程池：</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newFixedThreadPool(int nThreads) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  0L, TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p>
<p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p>
<ul>
<li>生成只有<strong>一个线程</strong>的固定线程池，这个更简单，和上面的一样，只要设置线程数为 1 就可以了：</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newSingleThreadExecutor() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new FinalizableDelegatedExecutorService</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (new ThreadPoolExecutor(1, 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                0L, TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newCachedThreadPool() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  60L, TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</p>
<p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p>
<p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支创建新线程。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// corePoolSize 为 0，所以不会进到这个 if 分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (workerCountOf(c) &lt; corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (addWorker(command, true))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int recheck = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (! isRunning(recheck) &amp;&amp; remove(command))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reject(command);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (workerCountOf(recheck) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addWorker(null, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else if (!addWorker(command, false))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reject(command);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>SynchronousQueue 是一个比较特殊的 BlockingQueue，其本身不储存任何元素，它有一个虚拟队列（或虚拟栈），不管读操作还是写操作，如果当前队列中存储的是与当前操作相同模式的线程，那么当前操作也进入队列中等待；如果是相反模式，则配对成功，从当前队列中取队头节点。具体的信息，可以看我的另一篇关于 BlockingQueue 的文章。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="gettask">getTask<a href="#gettask" class="hash-link" aria-label="Direct link to getTask" title="Direct link to getTask">​</a></h2>
<p>前文已经分析了<code>runWorker</code>方法，我们可以看到该方法中有一行这样的代码</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> while (task != null || (task = getTask()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//...</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这一行代码如果<code>task!=null</code>，即前一个条件为<code>true</code>时意味着传入的一个非<code>null</code>的<code>task</code>，同时代码会优化使得第二个条件不去执行；那么前一个条件为<code>false</code>时，就会尝试调用<code>getTask</code>方法。在这一个方法中，<code>worker</code>会尝试从工作队列中取出任务来进行执行。</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> private Runnable getTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      boolean timedOut = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //不断尝试获得任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          int c = ctl.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          int rs = runStateOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 前文已有相似的状态，这里不再赘述</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              decrementWorkerCount();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          int wc = workerCountOf(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //是否设置了允许核心线程超时（设置了之后核心线程在超时后会销毁），或者当前worker数量比核心池大</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))&amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              if (compareAndDecrementWorkerCount(c))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //是否设置了允许核心线程超时（设置了之后核心线程在超时后会销毁），或者当前worker数量比核心池大</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //如果是调用queue的poll(int,TimeUnit)方法，否则直接调用take方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //能获取到非空的任务就返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //对于不设置允许核心线程超时的情况，核心线程就一直在getTask的这个循环中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //一直等待有新的任务来执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              if (r != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  return r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              timedOut = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          } catch (InterruptedException retry) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              timedOut = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>我一向不喜欢写总结，因为我把所有需要表达的都写在正文中了，写小篇幅的总结并不能真正将话说清楚，本文的总结部分为准备面试的读者而写，希望能帮到面试者或者没有足够的时间看完全文的读者。</p>
<ol>
<li>
<p>java 线程池有哪些关键属性？</p>
<blockquote>
<p>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</p>
<p>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p>
<p>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取  任务。</p>
<p>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p>
<p>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有<strong>抛出 RejectedExecutionException 异常</strong>、<strong>忽略任务</strong>、<strong>使用提交任务的线程来执行此任务</strong>和<strong>将队列中等待最久的任务删除，然后提交此任务</strong>这四种策略，默认为抛出异常。</p>
</blockquote>
</li>
<li>
<p>说说线程池中的线程创建时机？</p>
<blockquote>
<ol>
<li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li>
<li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li>
<li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
</blockquote>
<ul>
<li>注意：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。因为后面的任务直接往队列塞就行了，此时 maximumPoolSize 参数就没有什么意义。</li>
</ul>
</li>
<li>
<p>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</p>
<blockquote>
<p>细说太长，往上滑一点点，在 Executors 的小节进行了详尽的描述。</p>
</blockquote>
</li>
<li>
<p>任务执行过程中发生异常怎么处理？</p>
<blockquote>
<p>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</p>
</blockquote>
</li>
<li>
<p>什么时候会执行拒绝策略？</p>
<blockquote>
<ol>
<li>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li>
<li>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
</blockquote>
</li>
</ol>
<p>因为本文实在太长了，所以我没有说执行结果是怎么获取的，也没有说关闭线程池相关的部分，这个就留给读者吧。</p>
<p>本文篇幅是有点长，如果读者发现什么不对的地方，或者有需要补充的地方，请不吝提出，谢谢。</p>
<p>（全文完）</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/concurrency/Java并发指南：解读Java阻塞队列BlockingQueue"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java并发指南：解读Java阻塞队列BlockingQueue</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java并发指南：深入理解Java内存模型JMM</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#总览" class="table-of-contents__link toc-highlight">总览</a></li><li><a href="#executor-接口" class="table-of-contents__link toc-highlight">Executor 接口</a></li><li><a href="#executorservice" class="table-of-contents__link toc-highlight">ExecutorService</a></li><li><a href="#futuretask" class="table-of-contents__link toc-highlight">FutureTask</a></li><li><a href="#abstractexecutorservice" class="table-of-contents__link toc-highlight">AbstractExecutorService</a></li><li><a href="#threadpoolexecutor" class="table-of-contents__link toc-highlight">ThreadPoolExecutor</a></li><li><a href="#executors" class="table-of-contents__link toc-highlight">Executors</a></li><li><a href="#gettask" class="table-of-contents__link toc-highlight">getTask</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java并发指南：AQS共享模式与并发工具类的实现 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java并发指南：AQS共享模式与并发工具类的实现 | Tommy"><meta data-rh="true" name="description" content="本文转自：https://www.javadoop.com/"><meta data-rh="true" property="og:description" content="本文转自：https://www.javadoop.com/"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">Java并发编程学习总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发基础与Java多线程">Java并发指南：并发基础与Java多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发三大问题与volatile关键字，CAS操作">Java并发指南：并发三大问题与volatile关键字，CAS操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：解读Java阻塞队列BlockingQueue">Java并发指南：解读Java阻塞队列BlockingQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现">Java并发指南：深度解读Java线程池设计思想及源码实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM">Java并发指南：深入理解Java内存模型JMM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现">Java并发指南：AQS共享模式与并发工具类的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion">Java并发指南：AQS中的公平锁与非公平锁，Condtion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：ForkJoin并发框架与工作窃取算法剖析">Java并发指南：ForkJoin并发框架与工作窃取算法剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java读写锁ReentrantReadWriteLock源码分析">Java并发指南：Java读写锁ReentrantReadWriteLock源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java内存模型JMM总结">Java并发指南：Java内存模型JMM总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的锁Lock和synchronized">Java并发指南：Java中的锁Lock和synchronized</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析">Java并发指南：JMM中的final关键字解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解">Java并发指南：JUC的核心类AQS详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC中常用的Unsafe和Locksupport">Java并发指南：JUC中常用的Unsafe和Locksupport</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">并发</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java并发指南：AQS共享模式与并发工具类的实现</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java并发指南：AQS共享模式与并发工具类的实现</h1></header><p>本文转自：<a href="https://www.javadoop.com/" target="_blank" rel="noopener noreferrer">https://www.javadoop.com/</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章同步发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="前言">前言<a href="#前言" class="hash-link" aria-label="Direct link to 前言" title="Direct link to 前言">​</a></h2>
<p>这篇文章是 AQS 系列的最后一篇，第一篇，我们通过 ReentrantLock 公平锁分析了 AQS 的核心，第二篇的重点是把 Condition 说明白，同时也说清楚了对于线程中断的使用。</p>
<p>这篇，我们的关注点是 AQS 最后的部分，<strong>AQS 共享模式</strong>的使用。有前两篇文章的铺垫，剩下的源码分析将会简单很多。</p>
<p>本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的源码一起过一下。</p>
<p>相对来说，如果读者有前面两篇文章的基础，这篇文章是简单很多，不过对于初学者来说，1 小时估计也是免不了的。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="countdownlatch">CountDownLatch<a href="#countdownlatch" class="hash-link" aria-label="Direct link to CountDownLatch" title="Direct link to CountDownLatch">​</a></h2>
<p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用例子">使用例子<a href="#使用例子" class="hash-link" aria-label="Direct link to 使用例子" title="Direct link to 使用例子">​</a></h3>
<p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p>
<p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p>
<p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">class Driver2 { // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void main() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch doneSignal = new CountDownLatch(N);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Executor e = Executors.newFixedThreadPool(8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建 N 个任务，提交给线程池来执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; N; ++i) // create and start threads</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.execute(new WorkerRunnable(doneSignal, i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 等待所有的任务完成，这个方法才会返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doneSignal.await();           // wait for all to finish</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class WorkerRunnable implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CountDownLatch doneSignal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WorkerRunnable(CountDownLatch doneSignal, int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.doneSignal = doneSignal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.i = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doWork(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个线程的任务完成了，调用 countDown 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doneSignal.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } // return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void doWork() { ...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p>
<p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">class Driver { // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void main() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch startSignal = new CountDownLatch(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch doneSignal = new CountDownLatch(N);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; N; ++i) // create and start threads</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(new Worker(startSignal, doneSignal)).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doSomethingElse();            // don&#x27;t let run yet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        startSignal.countDown();      // let all threads proceed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doSomethingElse();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 等待所有任务结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doneSignal.await();           // wait for all to finish</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Worker implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CountDownLatch startSignal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CountDownLatch doneSignal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.startSignal = startSignal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.doneSignal = doneSignal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 等大家都准备好了，再打开这个门栓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            startSignal.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doWork();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doneSignal.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } // return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void doWork() { ...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/5.png" alt="5" class="img_kGBN"></p>
<p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="源码分析">源码分析<a href="#源码分析" class="hash-link" aria-label="Direct link to 源码分析" title="Direct link to 源码分析">​</a></h3>
<p>Talk is cheap, show me the code.</p>
<p>构造方法，需要传入一个不小于 0 的整数：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public CountDownLatch(int count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.sync = new Sync(count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 老套路了，内部封装一个 Sync 类继承自 AQS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final class Sync extends AbstractQueuedSynchronizer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Sync(int count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这样就 state == count 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setState(count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p>
</blockquote>
<p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p>
<p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p>
<p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class CountDownLatchDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch latch = new CountDownLatch(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t1 = new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(5000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                latch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, &quot;t1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t2 = new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(10000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException ignore) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                latch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, &quot;t2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t3 = new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 阻塞，等待 state 减为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    latch.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;线程 t3 从 await 中返回了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;线程 t3 await 被中断&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, &quot;t3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t4 = new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 阻塞，等待 state 减为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    latch.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;线程 t4 从 await 中返回了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;线程 t4 await 被中断&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, &quot;t4&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t3.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t4.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述程序，大概在过了 10 秒左右的时候，会输出：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">线程 t3 从 await 中返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">线程 t4 从 await 中返回了</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>这两条输出，顺序不是绝对的</p>
<p>后面的分析，我们假设 t3 先进入阻塞队列</p>
</blockquote>
<p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p>
<p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void await() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireSharedInterruptibly(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquireSharedInterruptibly(int arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这也是老套路了，我在第二篇的中断那一节说过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Thread.interrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也就是说，这个 if 返回 true，然后往里看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tryAcquireShared(arg) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doAcquireSharedInterruptibly(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 只有当 state == 0 的时候，这个方法才会返回 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected int tryAcquireShared(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (getState() == 0) ? 1 : -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void doAcquireSharedInterruptibly(int arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1\. 入队</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node node = addWaiter(Node.SHARED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Node p = node.predecessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (p == head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 同上，只要 state 不等于 0，那么这个方法返回 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int r = tryAcquireShared(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (r &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setHeadAndPropagate(node, r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = null; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelAcquire(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/2.png" alt="2" class="img_kGBN"></p>
<p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/3.png" alt="3" class="img_kGBN"></p>
<p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p>
<p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/4.png" alt="4" class="img_kGBN"></p>
<p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p>
<p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/1.png" alt="1" class="img_kGBN"></p>
<p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p>
<p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void countDown() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.releaseShared(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean releaseShared(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tryReleaseShared(arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 唤醒 await 的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doReleaseShared();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个方法很简单，用自旋的方法实现 state 减 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected boolean tryReleaseShared(int releases) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (c == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int nextc = c-1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compareAndSetState(c, nextc))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return nextc == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 调用这个方法的时候，state == 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void doReleaseShared() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node h = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h != null &amp;&amp; h != tail) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int ws = h.waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ws == Node.SIGNAL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将 head 的 waitStatue 设置为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;            // loop to recheck cases</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 在这里，也就是唤醒 t3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unparkSuccessor(h);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (ws == 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // todo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;                // loop on failed CAS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h == head)                   // loop if head changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void doAcquireSharedInterruptibly(int arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node node = addWaiter(Node.SHARED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Node p = node.predecessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (p == head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int r = tryAcquireShared(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (r &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setHeadAndPropagate(node, r); // 2\. 这里是下一步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = null; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 1\. 唤醒后这个方法返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelAcquire(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void setHeadAndPropagate(Node node, int propagate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node h = head; // Record old head for check below</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setHead(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (h = head) == null || h.waitStatus &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node s = node.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (s == null || s.isShared())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doReleaseShared();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 调用这个方法的时候，state == 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void doReleaseShared() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node h = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1\. h == null: 说明阻塞队列为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. h == tail: 说明头结点可能是刚刚初始化的头节点，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 所以这两种情况不需要进行唤醒后继节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h != null &amp;&amp; h != tail) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int ws = h.waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ws == Node.SIGNAL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里 CAS 失败的场景请看下面的解读</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;            // loop to recheck cases</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 在这里，也就是唤醒 t4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unparkSuccessor(h);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (ws == 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     // 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;                // loop on failed CAS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 否则，就是 head 没变，那么退出循环，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h == head)                   // loop if head changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>
<ol>
<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>
<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重 新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7...，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>
</ol>
<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p>
<p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p>
<p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="cyclicbarrier">CyclicBarrier<a href="#cyclicbarrier" class="hash-link" aria-label="Direct link to CyclicBarrier" title="Direct link to CyclicBarrier">​</a></h2>
<p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-2.png" alt="cyclicbarrier-2" class="img_kGBN"></p>
<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
<p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟 悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p>
<p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-3.png" alt="cyclicbarrier-3" class="img_kGBN"></p>
<blockquote>
<p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p>
</blockquote>
<p>大家先把图看完，然后我们开始源码分析：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class CyclicBarrier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&quot;一代&quot;，或者&quot;一个周期&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class Generation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean broken = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** The lock for guarding barrier entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CyclicBarrier 是基于 Condition 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Condition trip = lock.newCondition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 参与的线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int parties;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Runnable barrierCommand;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前所处的“代”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Generation generation = new Generation();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CyclicBarrier(int parties, Runnable barrierAction) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (parties &lt;= 0) throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.parties = parties;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.count = parties;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.barrierCommand = barrierAction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CyclicBarrier(int parties) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this(parties, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>首先，先看怎么开启新的一代：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void nextGeneration() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 首先，需要唤醒所有的在栅栏上等待的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trip.signalAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新 count 的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    count = parties;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重新生成“新一代”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    generation = new Generation();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p>
</blockquote>
<p>看看怎么打破一个栅栏：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void breakBarrier() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置状态 broken 为 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    generation.broken = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重置 count 为初始值 parties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    count = parties;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 唤醒所有已经在等待的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trip.signalAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 不带超时机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public int await() throws InterruptedException, BrokenBarrierException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return dowait(false, 0L);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (TimeoutException toe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new Error(toe); // cannot happen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 带超时机制，如果超时抛出 TimeoutException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public int await(long timeout, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throws InterruptedException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           BrokenBarrierException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dowait(true, unit.toNanos(timeout));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>继续往里看：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private int dowait(boolean timed, long nanos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException, BrokenBarrierException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               TimeoutException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先要获取到锁，然后在 finally 中要记得释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Generation g = generation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (g.broken)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new BrokenBarrierException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 检查中断状态，如果中断了，抛出 InterruptedException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Thread.interrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            breakBarrier();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // index 是这个 await 方法的返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 注意到这里，这个是从 count 递减后得到的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = --count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index == 0) {  // tripped</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean ranAction = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final Runnable command = barrierCommand;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (command != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    command.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ranAction = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 唤醒等待的线程，然后开启新的一代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nextGeneration();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!ranAction)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    breakBarrier();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // loop until tripped, broken, interrupted, or timed out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是最后一个线程调用 await，那么上面就返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!timed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    trip.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else if (nanos &gt; 0L)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    nanos = trip.awaitNanos(nanos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException ie) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (g == generation &amp;&amp; ! g.broken) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 打破栅栏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    breakBarrier();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw ie;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 到这里，说明 g != generation,  说明新的一代已经产生，即最后一个线程 await 执行完成，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 而是之后抛出 BrokenBarrierException 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              // 唤醒后，检查栅栏是否是“破的”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (g.broken)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new BrokenBarrierException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个 for 循环除了异常，就是要从这里退出了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (g != generation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果醒来发现超时了，打破栅栏，抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (timed &amp;&amp; nanos &lt;= 0L) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                breakBarrier();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new TimeoutException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p>
<p>下面开始收尾工作。</p>
<p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public int getNumberWaiting() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return parties - count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean isBroken() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return generation.broken;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>
<ol>
<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>
<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>
<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>
</ol>
<p>最后，我们来看看怎么重置一个栅栏：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void reset() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        breakBarrier();   // break the current generation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nextGeneration(); // start a new generation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会 通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<p>怎么样，CyclicBarrier 源码很简单吧。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="semaphore">Semaphore<a href="#semaphore" class="hash-link" aria-label="Direct link to Semaphore" title="Direct link to Semaphore">​</a></h2>
<p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p>
<p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p>
<p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire 的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
<p>构造方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public Semaphore(int permits) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync = new NonfairSync(permits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Semaphore(int permits, boolean fair) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync = fair ? new FairSync(permits) : new NonfairSync(permits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p>
<p>看 acquire 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void acquire() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireSharedInterruptibly(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void acquireUninterruptibly() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireShared(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void acquire(int permits) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireSharedInterruptibly(permits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void acquireUninterruptibly(int permits) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireShared(permits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p>
<p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void acquireUninterruptibly() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireShared(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquireShared(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tryAcquireShared(arg) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doAcquireShared(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 公平策略：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected int tryAcquireShared(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hasQueuedPredecessors())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int available = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int remaining = available - acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (remaining &lt; 0 ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            compareAndSetState(available, remaining))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return remaining;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 非公平策略：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected int tryAcquireShared(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nonfairTryAcquireShared(acquires);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int nonfairTryAcquireShared(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int available = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int remaining = available - acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (remaining &lt; 0 ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            compareAndSetState(available, remaining))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return remaining;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p>
<p>我们再回到 acquireShared 方 法，</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquireShared(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tryAcquireShared(arg) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doAcquireShared(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void doAcquireShared(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node node = addWaiter(Node.SHARED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean interrupted = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Node p = node.predecessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (p == head) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int r = tryAcquireShared(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (r &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setHeadAndPropagate(node, r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = null; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (interrupted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interrupted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelAcquire(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 任务介绍，释放一个资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void release() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.releaseShared(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean releaseShared(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tryReleaseShared(arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doReleaseShared();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected final boolean tryReleaseShared(int releases) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int current = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int next = current + releases;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 溢出，当然，我们一般也不会用这么大的数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (next &lt; current) // overflow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compareAndSetState(current, next))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void doReleaseShared() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node h = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h != null &amp;&amp; h != tail) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int ws = h.waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ws == Node.SIGNAL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;            // loop to recheck cases</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unparkSuccessor(h);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else if (ws == 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;                // loop on failed CAS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h == head)                   // loop if head changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>写到这里，终于把 AbstractQueuedSynchronizer 基本上说完了，对于 Java 并发，Doug Lea 真的是神一样的存在。日后我们还会接触到很多 Doug Lea 的代码，希望我们大家都可以朝着大神的方向不断打磨自己的技术，少一些高大上的架构，多一些实实在在的优秀代码吧。</p>
<p>（全文完）</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java并发指南：深入理解Java内存模型JMM</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java并发指南：AQS中的公平锁与非公平锁，Condtion</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#countdownlatch" class="table-of-contents__link toc-highlight">CountDownLatch</a><ul><li><a href="#使用例子" class="table-of-contents__link toc-highlight">使用例子</a></li><li><a href="#源码分析" class="table-of-contents__link toc-highlight">源码分析</a></li></ul></li><li><a href="#cyclicbarrier" class="table-of-contents__link toc-highlight">CyclicBarrier</a></li><li><a href="#semaphore" class="table-of-contents__link toc-highlight">Semaphore</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
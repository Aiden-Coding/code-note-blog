<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Java并发指南：AQS中的公平锁与非公平锁，Condtion | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java并发指南：AQS中的公平锁与非公平锁，Condtion | Tommy"><meta data-rh="true" name="description" content="本文转自：http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer"><meta data-rh="true" property="og:description" content="本文转自：http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/basic/抽象类和接口">基础</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/collection/Java集合类总结">集合</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">并发</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发编程学习总结">Java并发编程学习总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发基础与Java多线程">Java并发指南：并发基础与Java多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：并发三大问题与volatile关键字，CAS操作">Java并发指南：并发三大问题与volatile关键字，CAS操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：解读Java阻塞队列BlockingQueue">Java并发指南：解读Java阻塞队列BlockingQueue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深度解读Java线程池设计思想及源码实现">Java并发指南：深度解读Java线程池设计思想及源码实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：深入理解Java内存模型JMM">Java并发指南：深入理解Java内存模型JMM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现">Java并发指南：AQS共享模式与并发工具类的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion">Java并发指南：AQS中的公平锁与非公平锁，Condtion</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：ForkJoin并发框架与工作窃取算法剖析">Java并发指南：ForkJoin并发框架与工作窃取算法剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java读写锁ReentrantReadWriteLock源码分析">Java并发指南：Java读写锁ReentrantReadWriteLock源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java内存模型JMM总结">Java并发指南：Java内存模型JMM总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的锁Lock和synchronized">Java并发指南：Java中的锁Lock和synchronized</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：Java中的HashMap和ConcurrentHashMap全解析">Java并发指南：Java中的HashMap和ConcurrentHashMap全解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JMM中的final关键字解析">Java并发指南：JMM中的final关键字解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC的核心类AQS详解">Java并发指南：JUC的核心类AQS详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/code-note-blog/docs/Java/concurrency/Java并发指南：JUC中常用的Unsafe和Locksupport">Java并发指南：JUC中常用的Unsafe和Locksupport</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/design-parttern/初探Java设计模式：创建型模式（工厂，单例等）">设计模式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/JVM/深入理解JVM虚拟机：垃圾回收器详解">jvm</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/Java/network/Java网络编程与NIO详解：基于NIO的网络编程框架Netty">网络</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">并发</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java并发指南：AQS中的公平锁与非公平锁，Condtion</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java并发指南：AQS中的公平锁与非公平锁，Condtion</h1></header><p>本文转自：<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer" target="_blank" rel="noopener noreferrer">http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer</a></p>
<p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>文章同步发于我的个人博客：</p>
<blockquote>
<p><a href="http://www.how2playlife.com" target="_blank" rel="noopener noreferrer">www.how2playlife.com</a></p>
</blockquote>
<p>本文是微信公众号【Java技术江湖】的《Java并发指南》其中一篇，本文大部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何全面深入地学习Java并发技术，从Java多线程基础，再到并发编程的基础知识，从Java并发包的入门和实战，再到JUC的源码剖析，一步步地学习Java并发编程，并上手进行实战，以便让你更完整地了解整个Java并发编程知识体系，形成自己的知识框架。</p>
<p>为了更好地总结和检验你的学习成果，本系列文章也会提供一些对应的面试题以及参考答案。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<p>文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。</p>
<p>本文关注以下几点内容：</p>
<ol>
<li>深入理解 ReentrantLock 公平锁和非公平锁的区别</li>
<li>深入分析 AbstractQueuedSynchronizer 中的 ConditionObject</li>
<li>深入理解 Java 线程中断和 InterruptedException 异常</li>
</ol>
<p>基本上本文把以上几点都说清楚了，我假设读者看过<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener noreferrer">上一篇文章中对 AbstractQueuedSynchronizer 的介绍</a>，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。</p>
<p>其实这篇文章的信息量很大，初学者估计<strong>至少要 1 小  时</strong>才能看完，希望本文对得起大家的时间。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="公平锁和非公平锁">公平锁和非公平锁<a href="#公平锁和非公平锁" class="hash-link" aria-label="Direct link to 公平锁和非公平锁" title="Direct link to 公平锁和非公平锁">​</a></h2>
<p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public ReentrantLock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 默认非公平锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync = new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ReentrantLock(boolean fair) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync = fair ? new FairSync() : new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>公平锁的 lock 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static final class FairSync extends Sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // AbstractQueuedSynchronizer.acquire(int arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final void acquire(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!tryAcquire(arg) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1\. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!hasQueuedPredecessors() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                compareAndSetState(0, acquires)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (current == getExclusiveOwnerThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nextc = c + acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nextc &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(nextc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>非公平锁的 lock 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static final class NonfairSync extends Sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2\. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compareAndSetState(0, 1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setExclusiveOwnerThread(Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acquire(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // AbstractQueuedSynchronizer.acquire(int arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final void acquire(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!tryAcquire(arg) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final boolean tryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return nonfairTryAcquire(acquires);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * subclasses, but both need nonfair try for trylock method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean nonfairTryAcquire(int acquires) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Thread current = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (c == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里没有对阻塞队列进行判断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compareAndSetState(0, acquires)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setExclusiveOwnerThread(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (current == getExclusiveOwnerThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int nextc = c + acquires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nextc &lt; 0) // overflow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setState(nextc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="condition">Condition<a href="#condition" class="hash-link" aria-label="Direct link to Condition" title="Direct link to Condition">​</a></h2>
<p>Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于<a href="http://hongjiev.github.io/2017/06/16/AbstractQueuedSynchronizer/" target="_blank" rel="noopener noreferrer">AbstractQueuedSynchronizer</a>的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。</p>
<p>我们先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.locks.Condition;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.locks.Lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.concurrent.locks.ReentrantLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class BoundedBuffer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Lock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // condition 依赖于 lock 来产生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Condition notFull = lock.newCondition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Condition notEmpty = lock.newCondition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Object[] items = new Object[100];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int putptr, takeptr, count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 生产</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void put(Object x) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (count == items.length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                notFull.await();  // 队列已满，等待，直到 not full 才能继续生产</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            items[putptr] = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (++putptr == items.length) putptr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ++count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 消费</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object take() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (count == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object x = items[takeptr];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (++takeptr == items.length) takeptr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            --count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。</p>
<p>2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue</p>
</blockquote>
<p>我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《<a href="http://hongjiev.github.io/2017/07/05/Threads-And-Locks-md/" target="_blank" rel="noopener noreferrer">深入分析 java 8 编程语言规范：Threads and Locks</a>》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p>
<p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。</p>
<p>每个 ReentrantLock 实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final ConditionObject newCondition() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实例化一个 ConditionObject</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ConditionObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们首先来看下我们关注的 Condition 的实现类<code>AbstractQueuedSynchronizer</code>类中的<code>ConditionObject</code>。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class ConditionObject implements Condition, java.io.Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final long serialVersionUID = 1173984872572414699L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 条件队列的第一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 不要管这里的关键字 transient，是不参与序列化的意思</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private transient Node firstWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 条件队列的最后一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private transient Node lastWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ......</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p>
<blockquote>
<p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两  个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p>
</blockquote>
<p><img loading="lazy" src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="condition-2" class="img_kGBN"></p>
<blockquote>
<p>这里，我们简单回顾下 Node 的属性：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">volatile int waitStatus; // 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">volatile Node prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">volatile Node next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">volatile Thread thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node nextWaiter;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表</p>
</blockquote>
<p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p>
<ol>
<li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li>
<li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li>
<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用<code>condition1.await()</code>方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>
<li>调用<code>condition1.signal()</code>触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li>
</ol>
<p>上面的 2-&gt;3-&gt;4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。</p>
<p>同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。</p>
<p>这个图看懂后，下面的代码分析就简单了。</p>
<p>接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 首先，这个方法是可被中断的，不可被中断的是另一个方 法 awaitUninterruptibly()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void await() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Thread.interrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加到 condition 的条件队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node node = addConditionWaiter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放锁，返回值是释放锁之前的 state 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int savedState = fullyRelease(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int interruptMode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里退出循环有两种情况，之后再仔细分析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1\. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2\. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!isOnSyncQueue(node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.park(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 被唤醒后，将进入阻塞队列，等待获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interruptMode = REINTERRUPT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node.nextWaiter != null) // clean up if cancelled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlinkCancelledWaiters();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (interruptMode != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reportInterruptAfterWait(interruptMode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="1-将节点加入到条件队列">1. 将节点加入到条件队列<a href="#1-将节点加入到条件队列" class="hash-link" aria-label="Direct link to 1. 将节点加入到条件队列" title="Direct link to 1. 将节点加入到条件队列">​</a></h3>
<p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 将当前线程对应的节点入队，插入队尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Node addConditionWaiter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node t = lastWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果条件队列的最后一个节点取消了，将其清除出去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlinkCancelledWaiters();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t = lastWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // t 此时是 lastWaiter，队尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果队列为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (t == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstWaiter = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.nextWaiter = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastWaiter = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上面的这块代码很简单，就是将当前线程进入到条件队列的队尾。</p>
<p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。</p>
<p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void unlinkCancelledWaiters() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node t = firstWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node trail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (t != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node next = t.nextWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t.waitStatus != Node.CONDITION) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            t.nextWaiter = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (trail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                firstWaiter = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                trail.nextWaiter = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (next == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastWaiter = trail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trail = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="2-完全释放独占锁">2. 完全释放独占锁<a href="#2-完全释放独占锁" class="hash-link" aria-label="Direct link to 2. 完全释放独占锁" title="Direct link to 2. 完全释放独占锁">​</a></h3>
<p>回到 wait 方法，节点入队了以后，会调用<code>int savedState = fullyRelease(node);</code>方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。</p>
<blockquote>
<p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p>
</blockquote>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         相应的，如果 lock 重入了 n 次，savedState == n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果这个方法失败，会将节点设置为&quot;取消&quot;状态，并抛出异常 IllegalMonitorStateException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int fullyRelease(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int savedState = getState();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (release(savedState)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return savedState;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalMonitorStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            node.waitStatus = Node.CANCELLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置<code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="3-等待进入阻塞队列">3. 等待进入阻塞队列<a href="#3-等待进入阻塞队列" class="hash-link" aria-label="Direct link to 3. 等待进入阻塞队列" title="Direct link to 3. 等待进入阻塞队列">​</a></h3>
<p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">int interruptMode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果不在阻塞队列中，注意了，是阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (!isOnSyncQueue(node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 线程挂起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LockSupport.park(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里可以先不用看了，等看到它什么时候被 unpark 再说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean isOnSyncQueue(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node.next != null) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 然后是 CAS 操作将自己设 置为新的 tail，可是这次的 CAS 是可能失败的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return findNodeFromTail(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean findNodeFromTail(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node t = tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t == node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t = t.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到<code>LockSupport.park(this);</code>这里线程挂起。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="4-signal-唤醒线程转移到阻塞队列">4. signal 唤醒线程，转移到阻塞队列<a href="#4-signal-唤醒线程转移到阻塞队列" class="hash-link" aria-label="Direct link to 4. signal 唤醒线程，转移到阻塞队列" title="Direct link to 4. signal 唤醒线程，转移到阻塞队列">​</a></h3>
<p>为了大家理解，这里我们先看唤醒操作，因为刚刚到<code>LockSupport.park(this);</code>把线程挂起了，等待唤醒。</p>
<p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 唤醒等待了最久的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void signal() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用 signal 方法的线程必须持有当前的独占锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!isHeldExclusively())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalMonitorStateException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node first = firstWaiter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (first != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doSignal(first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void doSignal(Node first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ( (firstWaiter = first.nextWaiter) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastWaiter = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        first.nextWaiter = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (!transferForSignal(first) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (first = firstWaiter) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将节点从条件队列转移到阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// true 代表成功转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// false 代表在 signal 之前，节点已经取消了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean transferForSignal(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 否则，将 waitStatus 置为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // enq(node): 自旋进入阻塞队列的队尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node p = enq(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ws = p.waitStatus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果前驱节点取消或者 CAS 失败，会进到这  里唤醒线程，之后的操作看下一节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.unpark(node.thread);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code>这句中，<code>ws &lt;= 0</code>，而且<code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code>会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p>
<p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="5-唤醒后检查中断状态">5. 唤醒后检查中断状态<a href="#5-唤醒后检查中断状态" class="hash-link" aria-label="Direct link to 5. 唤醒后检查中断状态" title="Direct link to 5. 唤醒后检查中断状态">​</a></h3>
<p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p>
<p>等线程从挂起中恢复过来，继续往 下看</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">int interruptMode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (!isOnSyncQueue(node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 线程挂起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LockSupport.park(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>
<ul>
<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置 中断状态</li>
<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>
<li>0 ：说明在 await 期间，没有发生中断</li>
</ul>
<p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p>
<ol>
<li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li>
<li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li>
<li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>
<li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li>
</ol>
<p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 1\. 如果在 signal 之前已经中断，返回 THROW_IE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2\. 如果是 signal 之后中断，返回 REINTERRUPT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3\. 没有发生中断，返回 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private int checkInterruptWhileWaiting(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Thread.interrupted() ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的<code>重新中断（REINTERRUPT）</code>的使用。</p>
</blockquote>
<p>看看怎么判断是 signal 之前还是之后发生的中断：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 只有线程处于中断状态，才会调用此方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 返回 true：如果此线程在 signal 之前被取消，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean transferAfterCancelledWait(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用 CAS 将节点状态设置为 0 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将节点放入阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里我们看到，即使中断了，依然会转移到阻塞队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enq(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!isOnSyncQueue(node))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.yield();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p>
</blockquote>
<p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p>
<p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="6-获取独占锁">6. 获取独占锁<a href="#6-获取独占锁" class="hash-link" aria-label="Direct link to 6. 获取独占锁" title="Direct link to 6. 获取独占锁">​</a></h3>
<p>while 循环出来以后，下面是这段代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interruptMode = REINTERRUPT;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p>
<p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p>
<p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p>
<p>继续往下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">if (node.nextWaiter != null) // clean up if cancelled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unlinkCancelledWaiters();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (interruptMode != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reportInterruptAfterWait(interruptMode);</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>本着一丝不苟的精神，这边说说<code>node.nextWaiter != null</code>怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p>
<p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code>这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p>
<p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="7-处理中断状态">7. 处理中断状态<a href="#7-处理中断状态" class="hash-link" aria-label="Direct link to 7. 处理中断状态" title="Direct link to 7. 处理中断状态">​</a></h3>
<p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p>
<ul>
<li>0：什 么都不做，没有被中断过；</li>
<li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li>
<li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li>
</ul>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void reportInterruptAfterWait(int interruptMode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (interruptMode == THROW_IE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (interruptMode == REINTERRUPT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="-带超时机制的-await">* 带超时机制的 await<a href="#-带超时机制的-await" class="hash-link" aria-label="Direct link to * 带超时机制的 await" title="Direct link to * 带超时机制的 await">​</a></h3>
<p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final long awaitNanos(long nanosTimeout) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean awaitUntil(Date deadline)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean await(long time, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throws InterruptedException</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这三个方法都差不多，我们就挑一个出来看看吧：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final boolean await(long time, TimeUnit unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等待这么多纳秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long nanosTimeout = unit.toNanos(time);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Thread.interrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node node = addConditionWaiter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int savedState = fullyRelease(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前时间 + 等待时长 = 过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final long deadline = System.nanoTime() + nanosTimeout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用于返回 await 是否超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean timedout = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int interruptMode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!isOnSyncQueue(node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 时间到啦</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nanosTimeout &lt;= 0L) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            timedout = transferAfterCancelledWait(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LockSupport.parkNanos(this, nanosTimeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 得到剩余时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nanosTimeout = deadline - System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interruptMode = REINTERRUPT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node.nextWaiter != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlinkCancelledWaiters();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (interruptMode != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reportInterruptAfterWait(interruptMode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return !timedout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="-不抛出-interruptedexception-的-await">* 不抛出 InterruptedException 的 await<a href="#-不抛出-interruptedexception-的-await" class="hash-link" aria-label="Direct link to * 不抛出 InterruptedException 的 await" title="Direct link to * 不抛出 InterruptedException 的 await">​</a></h3>
<p>关于 Condition 最后一小节了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void awaitUninterruptibly() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node node = addConditionWaiter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int savedState = fullyRelease(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean interrupted = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!isOnSyncQueue(node)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.park(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Thread.interrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            interrupted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acquireQueued(node, savedState) || interrupted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>很简单，贴一下代码大家就都懂了，我就不废话了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="abstractqueuedsynchronizer-独占锁的取消排队">AbstractQueuedSynchronizer 独占锁的取消排队<a href="#abstractqueuedsynchronizer-独占锁的取消排队" class="hash-link" aria-label="Direct link to AbstractQueuedSynchronizer 独占锁的取消排队" title="Direct link to AbstractQueuedSynchronizer 独占锁的取消排队">​</a></h2>
<p>这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。</p>
<p>接下来，我想说说怎么取消对锁的竞争？</p>
<p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">final boolean acquireQueued(final Node node, int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean interrupted = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Node p = node.predecessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (p == head &amp;&amp; tryAcquire(arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setHead(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p.next = null; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return interrupted;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interrupted = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelAcquire(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>首先，到这个方法的时候，节点一定是入队成功的。</p>
<p>我把 parkAndCheckInterrupt() 代码贴过来：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private final boolean parkAndCheckInterrupt() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LockSupport.park(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Thread.interrupted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这两段代码联系起来看，是不是就清楚了。</p>
<p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从<code>LockSupport.park(this);</code>中唤醒，然后<code>Thread.interrupted();</code>返回 true。</p>
<p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了<code>interrupted = true</code>然后继续下一次循环。而且，由于<code>Thread.interrupted();</code>会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p>
<p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何  相关事情。</p>
<p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquire(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!tryAcquire(arg) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        selfInterrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void selfInterrupt() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p>
<hr>
<p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p>
<p>我们来看 ReentrantLock 的另一个 lock 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void lockInterruptibly() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireInterruptibly(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>方法上多了个<code>throws InterruptedException</code>，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquireInterruptibly(int arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Thread.interrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!tryAcquire(arg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doAcquireInterruptibly(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>继续往里：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void doAcquireInterruptibly(int arg) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node node = addWaiter(Node.EXCLUSIVE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean failed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Node p = node.predecessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (p == head &amp;&amp; tryAcquire(arg)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                setHead(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p.next = null; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                failed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parkAndCheckInterrupt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里不再只是标记这个方法的返回值代表中断状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (failed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cancelAcquire(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private void cancelAcquire(Node node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Ignore if node doesn&#x27;t exist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node.thread = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Skip cancelled predecessors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node pred = node.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (pred.waitStatus &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.prev = pred = pred.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // predNext is the apparent node to unsplice. CASes below will</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fail if not, in which case, we lost race vs another cancel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or signal, so no further action is necessary.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node predNext = pred.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Can use unconditional write instead of CAS here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // After this atomic step, other Nodes can skip past us.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Before, we are free of interference from other threads.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node.waitStatus = Node.CANCELLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // If we are the tail, remove ourselves.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compareAndSetNext(pred, predNext, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If successor needs signal, try to set pred&#x27;s next-link</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // so it will get one. Otherwise wake it up to propagate.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int ws;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pred != head &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pred.thread != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node next = node.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                compareAndSetNext(pred, predNext, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            unparkSuccessor(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.next = node; // help GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="再说-java-线程中断和-interruptedexception-异常">再说 java 线程中断和 InterruptedException 异常<a href="#再说-java-线程中断和-interruptedexception-异常" class="hash-link" aria-label="Direct link to 再说 java 线程中断和 InterruptedException 异常" title="Direct link to 再说 java 线程中断和 InterruptedException 异常">​</a></h2>
<p>在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="线程中断">线程中断<a href="#线程中断" class="hash-link" aria-label="Direct link to 线程中断" title="Direct link to 线程中断">​</a></h3>
<p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。</p>
<blockquote>
<p>Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p>
</blockquote>
<p>关于中断状态，我们需要重点关注 Thread 类中的以下几个方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean isInterrupted() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static boolean interrupted() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void interrupt() {}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">while (!Thread.interrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   doWork();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   System.out.println(&quot;我做完一件事了，准备做下一件，如果没有其他线程中断我的话&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。</p>
</blockquote>
<p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p>
<p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p>
<ol>
<li>
<p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p>
<p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p>
<blockquote>
<p>这几个方法的相同之处是，方法上都有: throws InterruptedException</p>
<p>如果线程阻塞在这些方法上（我们知道，这些方法会让  当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p>
</blockquote>
</li>
<li>
<p>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p>
<blockquote>
<p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p>
</blockquote>
</li>
<li>
<p>Selector 中的 select 方法，参考下我写的 NIO 的文章</p>
<blockquote>
<p>一旦中断，方法立即返回</p>
</blockquote>
</li>
</ol>
<p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。</p>
<p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="interruptedexception-概述">InterruptedException 概述<a href="#interruptedexception-概述" class="hash-link" aria-label="Direct link to InterruptedException 概述" title="Direct link to InterruptedException 概述">​</a></h3>
<p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有<code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p>
<p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可 控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p>
<p>当我们看到方法上带有<code>throws InterruptedException</code>时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。</p>
<p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能<strong>感知</strong>到线程中断了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="处理中断">处理中断<a href="#处理中断" class="hash-link" aria-label="Direct link to 处理中断" title="Direct link to 处理中断">​</a></h3>
<p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。</p>
<p>我们经常会这么写代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread.sleep(10000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ignore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// go on </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p>
<p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void lockInterruptibly() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync.acquireInterruptibly(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void acquire(int arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!tryAcquire(arg) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        selfInterrupt();// Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>而对于 lockInterruptibly() 方法，因为其方法上面有<code>throws InterruptedException</code>，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。</p>
<p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">void await() throws InterruptedException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void awaitUninterruptibly();</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public final void await() throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Thread.interrupted())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new InterruptedException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...... </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</blockquote>
<p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>这篇文章的信息量真的很大，如果你花了时间，还是没有看懂，那是我的错了。</p>
<p>欢迎大家向我提问，我不一定能每次都及时出现，我出现也不一定能解决大家的问题，欢迎探讨。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Java/concurrency/Java并发指南：AQS中的公平锁与非公平锁，Condtion.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/Java/concurrency/Java并发指南：AQS共享模式与并发工具类的实现"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java并发指南：AQS共享模式与并 发工具类的实现</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/Java/concurrency/Java并发指南：ForkJoin并发框架与工作窃取算法剖析"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java并发指南：ForkJoin并发框架与工作窃取算法剖析</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#公平锁和非公平锁" class="table-of-contents__link toc-highlight">公平锁和非公平锁</a></li><li><a href="#condition" class="table-of-contents__link toc-highlight">Condition</a><ul><li><a href="#1-将节点加入到条件队列" class="table-of-contents__link toc-highlight">1. 将节点加入到条件队列</a></li><li><a href="#2-完全释放独占锁" class="table-of-contents__link toc-highlight">2. 完全释放独占锁</a></li><li><a href="#3-等待进入阻塞队列" class="table-of-contents__link toc-highlight">3. 等待进入阻塞队列</a></li><li><a href="#4-signal-唤醒线程转移到阻塞队列" class="table-of-contents__link toc-highlight">4. signal 唤醒线程，转移到阻塞队列</a></li><li><a href="#5-唤醒后检查中断状态" class="table-of-contents__link toc-highlight">5. 唤醒后检查中断状态</a></li><li><a href="#6-获取独占锁" class="table-of-contents__link toc-highlight">6. 获取独占锁</a></li><li><a href="#7-处理中断状态" class="table-of-contents__link toc-highlight">7. 处理中断状态</a></li><li><a href="#-带超时机制的-await" class="table-of-contents__link toc-highlight">* 带超时机制的 await</a></li><li><a href="#-不抛出-interruptedexception-的-await" class="table-of-contents__link toc-highlight">* 不抛出 InterruptedException 的 await</a></li></ul></li><li><a href="#abstractqueuedsynchronizer-独占锁的取消排队" class="table-of-contents__link toc-highlight">AbstractQueuedSynchronizer 独占锁的取消排队</a></li><li><a href="#再说-java-线程中断和-interruptedexception-异常" class="table-of-contents__link toc-highlight">再说 java 线程中断和 InterruptedException 异常</a><ul><li><a href="#线程中断" class="table-of-contents__link toc-highlight">线程中断</a></li><li><a href="#interruptedexception-概述" class="table-of-contents__link toc-highlight">InterruptedException 概述</a></li><li><a href="#处理中断" class="table-of-contents__link toc-highlight">处理中断</a></li></ul></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
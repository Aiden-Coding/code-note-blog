<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-backend/后端技术杂谈：Lucene基础原理与实践" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">后端技术杂谈：Lucene基础原理与实践 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：Lucene基础原理与实践"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="后端技术杂谈：Lucene基础原理与实践 | Tommy"><meta data-rh="true" name="description" content="Lucene是一个高效的，基于Java的全文检索库。"><meta data-rh="true" property="og:description" content="Lucene是一个高效的，基于Java的全文检索库。"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：Lucene基础原理与实践"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：Lucene基础原理与实践" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：Lucene基础原理与实践" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">后端技术杂谈：白话虚拟化技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：捋一捋大数据研发的基本概念">后端技术杂谈：捋一捋大数据研发的基本概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：十分钟理解Kubernetes核心概念">后端技术杂谈：十分钟理解Kubernetes核心概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：搜索引擎工作原理">后端技术杂谈：搜索引擎工作原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：搜索引擎基础倒排索引">后端技术杂谈：搜索引擎基础倒排索引</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧">后端技术杂谈：先搞懂Docker核心概念吧</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：云计算的前世今生">后端技术杂谈：云计算的前世今生</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：Docker 核心技术与实现原理">后端技术杂谈：Docker 核心技术与实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：Elasticsearch与solr入门实践">后端技术杂谈：Elasticsearch与solr入门实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/code-note-blog/docs/backend/后端技术杂谈：Lucene基础原理与实践">后端技术杂谈：Lucene基础原理与实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：OpenStack的基石KVM">后端技术杂谈：OpenStack的基石KVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：OpenStack架构设计">后端技术杂谈：OpenStack架构设计</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈开篇：云计算，大数据与AI的故事">后端技术杂谈开篇：云计算，大数据与AI的故事</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/Hadoop生态总结">Hadoop生态总结</a></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">后端技术杂谈：Lucene基础原理与实践</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>后端技术杂谈：Lucene基础原理与实践</h1></header><p>Lucene是一个高效的，基  于Java的全文检索库。</p>
<p>所以在了解Lucene之前要费一番工夫了解一下全文检索。</p>
<p>那么什么叫做全文检索呢？这要从我们生活中的数据说起。</p>
<p>我们生活中的数据总体分为两种：结构化数据和非结构化数据。</p>
<ul>
<li>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li>非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。</li>
</ul>
<p>当然有的地方还会提到第三种，半结构化数据，如XML，HTML等，当根据需要可按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。</p>
<p>非结构化数据又一种叫法叫全文数据。</p>
<p>按照数据的分类，搜索也分为两种：</p>
<ul>
<li>对结构化数据的搜索：如对数据库的搜索，用SQL语句。再如对元数据的搜索，如利用windows搜索对文件名，类型，修改时间进行搜索等。</li>
<li>对非结构化数据的搜索：如利用windows的搜索也可以搜索文件内容，Linux下的grep命令，再如用Google和百度可以搜索大量内容数据。</li>
</ul>
<p>对非结构化数据也即对全文数据的搜索主要有两种方法：</p>
<p>一种是顺序扫描法(Serial Scanning)：所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。如果你有一个80G硬盘，如果想在上面找到一个内容包含某字符串的文件，不花他几个小时，怕是做不到。Linux下的grep命令也是这一种方式。大家可能觉得这种方法比较原始，但对于小数据量的文件，这种方法还是最直接，最方便的。但是对于大量的文件，这种方法就很慢了。</p>
<p>有人可能会说，对非结构化数据顺序扫描很慢，对结构化数据的搜索却相对较快（由于结构化数据有一定的结构可以采取一定的搜索算法加快速度），那么把我们的非结构化数据想办法弄得有一定结构不就行了吗？</p>
<p>这种想法很天然，却构成了全文检索的基本思路，也即将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</p>
<p>这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。</p>
<p>这种说法比较抽象，举几个例子就很容易明白，比如字典，字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。</p>
<p>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</p>
<p>下面这幅图来自《Lucene in action》，但却不仅仅描述了Lucene的检索过程，而是描述了全文检索的一般过程。</p>
<p>全文检索大体分两个过程，索引创建(Indexing)和搜索索引(Search)。</p>
<ul>
<li>索引创建：将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。</li>
<li>搜索索引：就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。</li>
</ul>
<p>于是全文检索就存在三个重要问题：</p>
<p>1. 索引里面究竟存些什么？(Index)</p>
<p>2. 如何创建索引？(Indexing)</p>
<p>3. 如何对索引进行搜索？(Search)</p>
<p>下面我们顺序对每个个问题进行研究。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="二索引里面究竟存些什么">二、索引里面究竟存些什么<a href="#二索引里面究竟存些什么" class="hash-link" aria-label="Direct link to 二、索引里面究竟存些什么" title="Direct link to 二、索引里面究竟存些什么">​</a></h2>
<p>索引里面究竟需要存些什么呢？</p>
<p>首先我们来看为什么顺序扫描的速度慢：</p>
<p>其实是由于我们想要搜索的信息和非结构化数据中所存储的信息不一致造成的。</p>
<p>非结构化数据中所存储的信息是每个文件包含哪些字符串，也即已知文件，欲求字符串相对容易，也即是从文件到字符串的映射。而我们想搜索的信息是哪些文件包含此字符串，也即已知字符串，欲求文件，也即从字符串到文件的映射。两者恰恰相反。于是如果索引总能够保存从字符串到文件的映射，则会大大提高搜索速度。</p>
<p>由于从字符串到文件的映射是文件到字符串映射的反向过程，于是保存这种信息的索引称为反向索引。</p>
<p>反向索引的所保存的信息一般如下：</p>
<p>假设我的文档集合里面有100篇文档，为了方便表示，我们为文档编号从1到100，得到下面的结构</p>
<p>左边保存的是一系列字符串，称为词典。</p>
<p>每个字符串都指向包含此字符串的文档(Document)链表，此文档链表称为倒排表(Posting List)。</p>
<p>有了索引，便使保存的信息和要搜索的信息一致，可以大大加快搜索的速度。</p>
<p>比如说，我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档，我们只需要以下几步：</p>
<p>1. 取出包含字符串“lucene”的文档链表。</p>
<p>2. 取出包含字符串“solr”的文档链表。</p>
<p>3. 通过合并链表，找出既包含“lucene”又包含“solr”的文件。</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/v2-c1064a6ada64169f76ec63e44e82f0f5_720w.webp" alt="" class="img_kGBN"></p></figure>
<p>看到这个地方，有人可能会说，全文检索的确加快了搜索的速度，但是多了索引的过程，两者加起来不一定比顺序扫描快多少。的确，加上索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个很大量的数据创建索引也是一个很慢的过程。</p>
<p>然而两者还是有区别的，顺序扫描是每次都要扫描，而创建索引的过程仅仅需要一次，以后便是一劳永逸的了，每次搜索，创建索引的过程不必经过，仅仅搜索创建好的索引就可以了。</p>
<p>这也是全文搜索相对于顺序扫描的优势之一：一次索引，多次使用。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="三如何创建索引">三、如何创建索引<a href="#三如何创建索引" class="hash-link" aria-label="Direct link to 三、如何创建索引" title="Direct link to 三、如何创建索引">​</a></h2>
<p>全文检索的索引创建过程一般有以下几步：</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第一步一些要索引的原文档document">第一步：一些要索引的原文档(Document)。<a href="#第一步一些要索引的原文档document" class="hash-link" aria-label="Direct link to 第一步：一些要索引的原文档(Document)。" title="Direct link to 第一步：一些要索引的原文档(Document)。">​</a></h3>
<p>为了方便说明索引创建过程，这里特意用两个文件为例：</p>
<p>文件一：Students should be allowed to go out with their friends, but not allowed to drink beer.</p>
<p>文件二：My friend Jerry went to school to see his students but found them drunk which is not allowed.</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第二步将原文档传给分次组件tokenizer">第二步：将原文档传给分次组件(Tokenizer)。<a href="#第二步将原文档传给分次组件tokenizer" class="hash-link" aria-label="Direct link to 第二步：将原文档传给分次组件(Tokenizer)。" title="Direct link to 第二步：将原文档传给分次组件(Tokenizer)。">​</a></h3>
<p>分词组件(Tokenizer)会做以下几件事情(此过程称为Tokenize)：</p>
<p>1. 将文档分成一个一个单独的单词。</p>
<p>2. 去除标点符号。</p>
<p>3. 去除停词(Stop word)。</p>
<p>所谓停词(Stop word)就是一种语言中最普通的一些单词，由于没有特别的意义，因而大多数情况下不能成为搜索的关键词，因而创建索引时，这种词会被去掉而减少索引的大小。</p>
<p>英语中挺词(Stop word)如：“the”,“a”，“this”等。</p>
<p>对于每一种语言的分词组件(Tokenizer)，都有一个停词(stop word)集合。</p>
<p>经过分词(Tokenizer)后得到的结果称为词元(Token)。</p>
<p>在我们的例子中，便得到以下词元(Token)：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">“Students”，“allowed”，“go”，“their”，“friends”，“allowed”，“drink”，“beer”，“My”，“friend”，“Jerry”，“went”，“school”，“see”，“his”，“students”，“found”，“them”，“drunk”，“allowed”。</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第三步将得到的词元token传给语言处理组件linguistic-processor">第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。<a href="#第三步将得到的词元token传给语言处理组件linguistic-processor" class="hash-link" aria-label="Direct link to 第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。" title="Direct link to 第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。">​</a></h3>
<p>语言处理组件(linguistic processor)主要是对得到的词元(Token)做一些同语言相关的处理。</p>
<p>对于英语，语言处理组件(Linguistic Processor)一般做以下几点：</p>
<p>1. 变为小写(Lowercase)。</p>
<p>2. 将单词缩减为词根形式，如“cars”到“car”等。这种操作称为：stemming。</p>
<p>3. 将单词转变为词根形式，如“drove”到“drive”等。这种操作称为：lemmatization。</p>
<p>Stemming 和 lemmatization的异同：</p>
<ul>
<li>
<p>相同之处：Stemming和lemmatization都要使词汇成为词根形式。</p>
</li>
<li>
<p>两者的方式不同：</p>
</li>
<li>
<p>Stemming采用的是“缩减”的方式：“cars”到“car”，“driving”到“drive”。</p>
</li>
<li>
<p>Lemmatization采用的是“转变”的方式：“drove”到“drove”，“driving”到“drive”。</p>
</li>
<li>
<p>两者的算法不同：</p>
</li>
<li>
<p>Stemming主要是采取某种固定的算法来做这种缩减，如去除“s”，去除“ing”加“e”，将“ational”变为  “ate”，将“tional”变为“tion”。</p>
</li>
<li>
<p>Lemmatization主要是采用保存某种字典的方式做这种转变。比如字典中有“driving”到“drive”，“drove”到“drive”，“am, is, are”到“be”的映射，做转变时，只要查字典就可以了。</p>
</li>
<li>
<p>Stemming和lemmatization不是互斥关系，是有交集的，有的词利用这两种方式都能达到相同的转换。</p>
</li>
</ul>
<p>语言处理组件(linguistic processor)的结果称为词(Term)。</p>
<p>在我们的例子中，经过语言处理，得到的词(Term)如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">“student”，“allow”，“go”，“their”，“friend”，“allow”，“drink”，“beer”，“my”，“friend”，“jerry”，“go”，“school”，“see”，“his”，“student”，“find”，“them”，“drink”，“allow”。</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>也正是因为有语言处理的步骤，才能使搜索drove，而drive也能被搜索出来。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第四步将得到的词term传给索引组件indexer">第四步：将得到的词(Term)传给索引组件(Indexer)。<a href="#第四步将得到的词term传给索引组件indexer" class="hash-link" aria-label="Direct link to 第四步：将得到的词(Term)传给索引组件(Indexer)。" title="Direct link to 第四步：将得到的词(Term)传给索引组件(Indexer)。">​</a></h3>
<p>索引组件(Indexer)主要做以下几件事情：</p>
<p>1. 利用得到的词(Term)创建一个字典。</p>
<p>在我们的例子中字典如下：</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/v2-b8477ac42cb442585aa090f33c0b34a6_720w.webp" alt="" class="img_kGBN"></p></figure>
<p>2. 对字典按字母顺序进行排序。</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408113241.png" alt="" class="img_kGBN"></p></figure>
<p>3. 合并相同的词(Term)成为文档倒排(Posting List)链表。</p>
<p>在此表中，有几个定义：</p>
<ul>
<li>Document Frequency 即文档频次，表示总共有多少文件包含此词(Term)。</li>
<li>Frequency 即词频率，表示此文件中包含了几个此词(Term)。</li>
</ul>
<p>所以对词(Term) “allow”来讲，总共有两篇文档包含此词(Term)，从而词(Term)后面的文档链表总共有两项，第一项表示包含“allow”的第一篇文档，即1号文档，此文档中，“allow”出现了2次，第二项表示包含“allow”的第二个文档，是2号文档，此文档中，“allow”出现了1次。</p>
<p>到此为止，索引已经创建好了，我们可以通过它很快的找到我们想要的文档。</p>
<p>而且在此过程中，我们惊喜地发现，搜索“drive”，“driving”，“drove”，“driven”也能够被搜到。因为在我们的索引中，“driving”，“drove”，“driven”都会经过语言处理而变成“drive”，在搜索时，如果您输入“driving”，输入的查询语句同样经过我们这里的一到三步，从而变为查询“drive”，从而可以搜索到想要的文档。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="三如何对索引进行搜索">三、如何对索引进行搜索？<a href="#三如何对索引进行搜索" class="hash-link" aria-label="Direct link to 三、如何对索引进行搜索？" title="Direct link to 三、如何对索引进行搜索？">​</a></h2>
<p>到这里似乎我们可以宣布“我们找到想要的文档了”。</p>
<p>然而事情并没有结束，找到了仅仅是全文检索的一个方面。不是吗？如果仅仅只有一个或十个文档包含我们查询的字符串，我们的确找到了。然而如果结果有一千个，甚至成千上万个呢？那个又是您最想要的文件呢？</p>
<p>打开Google吧，比如说您想在微软找份工作，于是您输入“Microsoft job”，您却发现总共有22600000个结果返回。好大的数字呀，突然发现找不到是一个问题，找到的太多也是一个问题。在如此多的结果中，如何将最相关的放在最前面呢？</p>
<p>当然Google做的很不错，您一下就找到了jobs at Microsoft。想象一下，如果前几个全部是“Microsoft does a good job at software industry…”将是多么可怕的事情呀。</p>
<p>如何像Google一样，在成千上万的搜索结果中，找到和查询语句最相关的呢？</p>
<p>如何判断搜索出的文档和查询语句的相关性呢？</p>
<p>这要回到我们第三个问题：如何对索引进行搜索？</p>
<p>搜索主要分为以下几步：</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第一步用户输入查询语句">第一步：用户输入查询语句。<a href="#第一步用户输入查询语句" class="hash-link" aria-label="Direct link to 第一步：用户输入查询语句。" title="Direct link to 第一步：用户输入查询语句。">​</a></h3>
<p>查询语句同我们普通的语言一样，也是有一定语法的。</p>
<p>不同的查询语句有不同的语法，如SQL语句就有一定的语法。</p>
<p>查询语句的语法根据全文检索系统的实现而不同。最基本的有比如：AND, OR, NOT等。</p>
<p>举个例子，用户输入语句：lucene AND learned NOT hadoop。</p>
<p>说明用户想找一个包含lucene和learned然而不包括hadoop的文档。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第二步对查询语句进行词法分析语法分析及语言处理">第二步：对查询语句进行词法分析，语法分析，及语言处理。<a href="#第二步对查询语句进行词法分析语法分析及语言处理" class="hash-link" aria-label="Direct link to 第二步：对查询语句进行词法分析，语法分析，及语言处理。" title="Direct link to 第二步：对查询语句进行词法分析，语法分析，及语言处理。">​</a></h3>
<p>由于查询语句有语法，因而也要进行语法分析，语法分析及语言处理。</p>
<p>1. 词法分析主要用来识别单词和关键字。</p>
<p>如上述例子中，经过词法分析，得到单词有lucene，learned，hadoop, 关键字有AND, NOT。</p>
<p>如果在词法分析中发现不合法的关键字，则会出现错误。如lucene AMD learned，其中由于AND拼错，导致AMD作为一个普通的单词参与查询。</p>
<p>2. 语法分析主要是根据查询语句的语法规则来形成一棵语法树。</p>
<p>如果发现查询语句不满足语法规则，则会报错。如lucene NOT AND learned，则会出错。</p>
<p>如上述例子，lucene AND learned NOT hadoop形成的语法树如下：</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/v2-5acb4fdbd41e04fe83396ea82679bee9_720w.webp" alt="" class="img_kGBN"></p></figure>
<p>3. 语言处理同索引过程中的语言处理几乎相同。</p>
<p>如learned变成learn等。</p>
<p>经过第二步，我们得到一棵经过语言处理的语法树。</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408113252.png" alt="" class="img_kGBN"></p></figure>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第三步搜索索引得到符合语法树的文档">第三步：搜索索引，得到符合语法树的文档。<a href="#第三步搜索索引得到符合语法树的文档" class="hash-link" aria-label="Direct link to 第三步：搜索索引，得到符合语法树的文档。" title="Direct link to 第三步：搜索索引，得到符合语法树的文档。">​</a></h3>
<p>此步骤有分几小步：</p>
<ol>
<li>首先，在反向索引表中，分别找出包含lucene，learn，hadoop的文档链表。</li>
<li>其次，对包含lucene，learn的链表进行合并操作，得到既包含lucene又包含learn的文档链表。</li>
<li>然后，将此链表与hadoop的文档链表进行差操作，去除包含hadoop的文档，从而得到既包含lucene又包含learn而且不包含hadoop的文档链表。</li>
<li>此文档链表就是我们要找的文档。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="第四步根据得到的文档和查询语句的相关性对结果进行排序">第四步：根据得到的文档和查询语句的相关性，对结果进行排序。<a href="#第四步根据得到的文档和查询语句的相关性对结果进行排序" class="hash-link" aria-label="Direct link to 第四步：根据得到的文档和查询语句的相关性，对结果进行排序。" title="Direct link to 第四步：根据得到的文档和查询语句的相关性，对结果进行排序。">​</a></h3>
<p>虽然在上一步，我们得到了想要的文档，然而对于查询结果应该按照与查询语句的相关性进行排序，越相关者越靠前。</p>
<p>如何计算文档和查询语句的相关性呢？</p>
<p>不如我们把查询语句看作一片短小的文档，对文档与文档之间的相关性(relevance)进行打分(scoring)，分数高的相关性好，就应该排在前面。</p>
<p>那么又怎么对文档之间的关系进行打分呢？</p>
<p>这可不是一件容易的事情，首先我们看一看判断人之间的关系吧。</p>
<p>首先看一个人，往往有很多要素，如性格，信仰，爱好，衣着，高矮，胖瘦等等。</p>
<p>其次对于人与人之间的关系，不同的要素重要性不同，性格，信仰，爱好可能重要些，衣着，高矮，胖瘦可能就不那么重要了，所以具有相同或相似性格，信仰，爱好的人比较容易成为好的朋友，然而衣着，高矮，胖瘦不同的人，也可以成为好的朋友。</p>
<p>因而判断人与人之间的关系，首先要找出哪些要素对人与人之间的关系最重要，比如性格，信仰，爱好。其次要判断两个人的这些要素之间的关系，比如一个人性格开朗，另一个人性格外向，一个人信仰佛教，另一个信仰上帝，一个人爱好打篮球，另一个爱好踢足球。我们发现，两个人在性格方面都很积极，信仰方面都很善良，爱好方面都爱运动，因而两个人关系应该会很好。</p>
<p>我们再来看看公司之间的关系吧。</p>
<p>首先看一个公司，有很多人组成，如总经理，经理，首席技术官，普通员工，保安，门卫等。</p>
<p>其次对于公司与公司之间的关系，不同的人重要性不同，总经理，经理，首席技术官可能更重要一些，普通员工，保安，门卫可能较不重要一点。所以如果两个公司总经理，经理，首席技术官之间关系比较好，两个公司容易有比较好的关系。然而一位普通员工就算与另一家公司的一位普通员工有血海深仇，怕也难影响两个公司之间的关系。</p>
<p>因而判断公司与公司之间的关系，首先要找出哪些人对公司与公司之间的关系最重要，比如总经理，经理，首席技术官。其次要判断这些人之间的关系，不如两家公司的总经理曾经是同学，经理是老乡，首席技  术官曾是创业伙伴。我们发现，两家公司无论总经理，经理，首席技术官，关系都很好，因而两家公司关系应该会很好。</p>
<p>分析了两种关系，下面看一下如何判断文档之间的关系了。</p>
<p>首先，一个文档有很多词(Term)组成，如search, lucene, full-text, this, a, what等。</p>
<p>其次对于文档之间的关系，不同的Term重要性不同，比如对于本篇文档，search, Lucene, full-text就相对重要一些，this, a , what可能相对不重要一些。所以如果两篇文档都包含search, Lucene，fulltext，这两篇文档的相关性好一些，然而就算一篇文档包含this, a, what，另一篇文档不包含this, a, what，也不能影响两篇文档的相关性。</p>
<p>因而判断文档之间的关系，首先找出哪些词(Term)对文档之间的关系最重要，如search, Lucene, fulltext。然后判断这些词(Term)之间的关系。</p>
<p>找出词(Term)对文档的重要性的过程称为计算词的权重(Term weight)的过程。</p>
<p>计算词的权重(term weight)有两个参数，第一个是词(Term)，第二个是文档(Document)。</p>
<p>词的权重(Term weight)表示此词(Term)在此文档中的重要程度，越重要的词(Term)有越大的权重(Term weight)，因而在计算文档之间的相关性中将发挥更大的作用。</p>
<p>判断词(Term)之间的关系从而得到文档相关性的过程应用一种叫做向量空间模型的算法(Vector Space Model)。</p>
<p>下面仔细分析一下这两个过程：</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="1-计算权重term-weight的过程">1. 计算权重(Term weight)的过程。<a href="#1-计算权重term-weight的过程" class="hash-link" aria-label="Direct link to 1. 计算权重(Term weight)的过程。" title="Direct link to 1. 计算权重(Term weight)的过程。">​</a></h3>
<p>影响一个词(Term)在一篇文档中的重要性主要有两个因素：</p>
<ul>
<li>Term Frequency (tf)：即此Term在此文档 中出现了多少次。tf 越大说明越重要。</li>
<li>Document Frequency (df)：即有多少文档包含次Term。df 越大说明越不重要。</li>
</ul>
<p>容易理解吗？词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“搜索”这个词，在本文档中出现的次数很多，说明本文档主要就是讲这方面的事的。然而在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，这是由第二个因素进行调整，第二个因素说明，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。</p>
<p>这也如我们程序员所学的技术，对于程序员本身来说，这项技术掌握越深越好（掌握越深说明花时间看的越多，tf越大），找工作时越有竞争力。然而对于所有程序员来说，这项技术懂得的人越少越好（懂得的人少df小），找工作越有竞争力。人的价值在于不可替代性就是这个道理。</p>
<p>道理明白了，我们来看看公式：</p>
<p>这仅仅只term weight计算公式的简单典型实现。实现全文检索系统的人会有自己的实现，Lucene就与此稍有不同。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="2-判断term之间的关系从而得到文档相关性的过程也即向量空间模型的算法vsm">2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。<a href="#2-判断term之间的关系从而得到文档相关性的过程也即向量空间模型的算法vsm" class="hash-link" aria-label="Direct link to 2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。" title="Direct link to 2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。">​</a></h3>
<p>我们把文档看作一系列词(Term)，每一个词(Term)都有一个权重(Term weight)，不同的词(Term)根  据自己在文档中的权重来影响文档相关性的打分计算。</p>
<p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量。</p>
<p><code>Document = {term1, term2, …… ,term N}</code></p>
<p><code>Document Vector = {weight1, weight2, …… ,weight N}</code></p>
<p>同样我们把查询语句看作一个简单的文档，也用向量来表示。</p>
<p><code>Query = {term1, term 2, …… , term N}</code></p>
<p><code>Query Vector = {weight1, weight2, …… , weight N}</code></p>
<p>我们把所有搜索出的文档向量及查询向量放到一个N维空间中，每个词(term)是一维。</p>
<p>我们认为两个向量之间的夹角越小，相关性越大。</p>
<p>所以我们计算夹角的余弦值作为相关性的打分，夹角越小，余弦值越大，打分越高，相关性越大。</p>
<p>有人可能会问，查询语句一般是很短的，包含的词(Term)是很少的，因而查询向量的维数很小，而文档很长，包含词(Term)很多，文档向量维数很大。你的图中两者维数怎么都是N呢？</p>
<p>在这里，既然要放到相同的向量空间，自然维数是相同的，不同时，取二者的并集，如果不含某个词(Term)时，则权重(Term Weight)为0。</p>
<p>相关性打分公式如下：</p>
<p>举个例子，查询语句有11个Term，共有三篇文档搜索出来。其中各自的权重(Term weight)，如下表格。</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408113310.png" alt="" class="img_kGBN"></p></figure>
<p>于是计算，三篇文档同查询语句的相关性打分分别为：</p>
<p>于是文档二相关性最高，先返回，其次是文档一，最后是文档三。</p>
<p>到此为止，我们可以找到我们最想要的文档了。</p>
<p>说了这么多，其实还没有进入到Lucene，而仅仅是信息检索技术(Information retrieval)中的基本理论，然而当我们看过Lucene后我们会发现，Lucene是对这种基本理论的一种基本的的实践。所以在以后分析Lucene的文章中，会常常看到以上理论在Lucene中的应用。</p>
<p>在进入Lucene之前，对上述索引创建和搜索过程所一个总结，如图：</p>
<figure data-size="normal"><p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408113319.png" alt="" class="img_kGBN"></p></figure>
<p>1. 索引过程：</p>
<ol>
<li>
<p>有一系列被索引文件</p>
</li>
<li>
<p>被索引文件经过语法分析和语言处理形成一系列词(Term)。</p>
</li>
<li>
<p>经过索引创建形成词典和反向索引表。</p>
</li>
<li>
<p>通过索引存储将索引写入硬盘。</p>
</li>
</ol>
<p>2. 搜索过程：</p>
<p>a) 用户输入查询语句。</p>
<p>b) 对查询语句经过语法分析和语言分析得到一系列词(Term)。</p>
<p>c) 通过语法分析得到一个查询树。</p>
<p>d) 通过索引存储将索引读入到内存。</p>
<p>e) 利用查询树搜索索引，从而得到每个词(Term)的文档链表，对文档链表进行交，差，并得到结果文档。</p>
<p>f) 将搜索到的结果文档对查询的相关性进行排序。</p>
<p>g) 返回查询结果给用户。</p>
<p>下面我们可以进入Lucene的世界了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="spring-boot-中使用-java-api-调用-lucene">Spring Boot 中使用 Java API 调用 lucene<a href="#spring-boot-中使用-java-api-调用-lucene" class="hash-link" aria-label="Direct link to Spring Boot 中使用 Java API 调用 lucene" title="Direct link to Spring Boot 中使用 Java API 调用 lucene">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="github-代码">Github 代码<a href="#github-代码" class="hash-link" aria-label="Direct link to Github 代码" title="Direct link to Github 代码">​</a></h2>
<p>代码我已放到 Github ，导入<code>spring-boot-lucene-demo</code> 项目</p>
<p>github <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsouyunku%2Fspring-boot-examples%2Ftree%2Fmaster%2Fspring-boot-lucene-demo" target="_blank" rel="noopener noreferrer">spring-boot-lucene-demo</a></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="添加依赖">添加依赖<a href="#添加依赖" class="hash-link" aria-label="Direct link to 添加依赖" title="Direct link to 添加依赖">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">      21  &lt;!--对分词索引查询解析--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;7.1.0&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;!--高亮 --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;7.1.0&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;!--smartcn 中文分词器 SmartChineseAnalyzer  smartcn分词器 需要lucene依赖 且和lucene版本同步--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;7.1.0&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;!--ik-analyzer 中文分词器--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;cn.bestwu&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;ik-analyzers&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;5.1.0&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt; &lt;!--MMSeg4j 分词器--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;com.chenlb.mmseg4j&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;mmseg4j-solr&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;2.4.0&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;exclusions&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;exclusion&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &lt;artifactId&gt;solr-core&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;/exclusion&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;/exclusions&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="配置-lucene">配置 lucene<a href="#配置-lucene" class="hash-link" aria-label="Direct link to 配置 lucene" title="Direct link to 配置 lucene">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">private Directory directory; private IndexReader indexReader; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private IndexSearcher indexSearcher; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Beforepublic void setUp() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//索引存放的位置，设置在当前目录中    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">directory = FSDirectory.open(Paths.get(&quot;indexDir/&quot;));     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引的读取器    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexReader = DirectoryReader.open(directory);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建一个索引的查找器，来检索索引库    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexSearcher = new IndexSearcher(indexReader);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Afterpublic void tearDown() throws Exception {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexReader.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">** * 执行查询，并打印查询到的记录数 * * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@param query * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void executeQuery(Query query) throws IOException {     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TopDocs topDocs = indexSearcher.search(query, 100);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//打印查询到的记录数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;总共查询到&quot; + topDocs.totalHits + &quot;个文档&quot;);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (ScoreDoc scoreDoc : topDocs.scoreDocs) {         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//取得对应的文档对象        Document document = indexSearcher.doc(scoreDoc.doc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;id：&quot; + document.get(&quot;id&quot;));        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;title：&quot; + document.get(&quot;title&quot;));        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;content：&quot; + document.get(&quot;content&quot;));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/** * 分词打印 * * @param analyzer * @param text * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void printAnalyzerDoc(Analyzer analyzer, String text) throws IOException {     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TokenStream tokenStream = analyzer.tokenStream(&quot;content&quot;, new StringReader(text));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tokenStream.reset();        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (tokenStream.incrementToken()) {            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(charTermAttribute.toString());        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tokenStream.end();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} finally {        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tokenStream.close();        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">analyzer.close();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="创建索引">创建索引<a href="#创建索引" class="hash-link" aria-label="Direct link to 创建索引" title="Direct link to 创建索引">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void indexWriterTest() throws IOException {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long start = System.currentTimeMillis();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//索引存放的位置，设置在当前目录中   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Directory directory = FSDirectory.open(Paths.get(&quot;indexDir/&quot;));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//在 6.6 以上版本中 version 不再是必要的，并且，存在无参构造方法，可以直接使用默认的 StandardAnalyzer 分词器。    Version version = Version.LUCENE_7_1_0;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new StandardAnalyzer(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new ComplexAnalyzer();//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new IKAnalyzer();//中文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引写入配置    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IndexWriterConfig indexWriterConfig = new IndexWriterConfig(analyzer);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引写入对象    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建Document对象，存储索引     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Document doc = new Document();     int id = 1;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//将字段加入到doc中    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new IntPoint(&quot;id&quot;, id));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new StringField(&quot;title&quot;, &quot;Spark&quot;, Field.Store.YES));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new TextField(&quot;content&quot;, &quot;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎&quot;, Field.Store.YES));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new StoredField(&quot;id&quot;, id));     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//将doc对象保存到索引库中    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexWriter.addDocument(doc);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexWriter.commit();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//关闭流    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexWriter.close();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long end = System.currentTimeMillis();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;索引花费了&quot; + (end - start) + &quot; 毫秒&quot;);}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>17:58:14.655 [main] DEBUG org.wltea.analyzer.dic.Dictionary - 加载扩展词典：ext.dic17:58:14.660 [main] DEBUG org.wltea.analyzer.dic.Dictionary - 加载扩展停止词典：stopword.dic索引花费了879 毫秒</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="删除文档">删除文档<a href="#删除文档" class="hash-link" aria-label="Direct link to 删除文档" title="Direct link to 删除文档">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Testpublic void deleteDocumentsTest() throws IOException </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中 文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引写入配置    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IndexWriterConfig indexWriterConfig = new IndexWriterConfig(analyzer);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引写入对象    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 删除title中含有关键词“Spark”的文档    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long count = indexWriter.deleteDocuments(new Term(&quot;title&quot;, &quot;Spark&quot;));     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  除此之外IndexWriter还提供了以下方法：   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DeleteDocuments(Query query):根据Query条件来删除单个或多个Document    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DeleteDocuments(Query[] queries):根据Query条件来删除单个或多个Document    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DeleteDocuments(Term term):根据Term来删除单个或多个Document    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DeleteDocuments(Term[] terms):根据Term来删除单个或多个Document    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DeleteAll():删除所有的Document     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//使用IndexWriter进行Document删除操作  时，文档并不会立即被删除，而是把这个删除动作缓存起来，当IndexWriter.Commit()或IndexWriter.Close()时，删除操作才会被真正执行。     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexWriter.commit();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexWriter.close();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;删除完成:&quot; + count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>删除完成:1</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="更新文档">更新文档<a href="#更新文档" class="hash-link" aria-label="Direct link to 更新文档" title="Direct link to 更新文档">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 测试更新 * 实际上就是删除后新增一条 * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void updateDocumentTest() throws IOException {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new StandardAnalyzer(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引写入配置    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IndexWriterConfig indexWriterConfig = new IndexWriterConfig(analyzer);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建索引写入对象    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Document doc = new Document();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int id = 1;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new IntPoint(&quot;id&quot;, id));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new StringField(&quot;title&quot;, &quot;Spark&quot;, Field.Store.YES));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new TextField(&quot;content&quot;, &quot;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎&quot;, Field.Store.YES));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">doc.add(new StoredField(&quot;id&quot;, id));     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long count = indexWriter.updateDocument(new Term(&quot;id&quot;, &quot;1&quot;), doc);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;更新文档:&quot; + count);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">indexWriter.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>更新文档:1</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="按词条搜索">按词条搜索<a href="#按词条搜索" class="hash-link" aria-label="Direct link to 按词条搜索" title="Direct link to 按词条搜索">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 按词条搜索 * &lt;p&gt; * TermQuery是最简单、也是最常用的Query。TermQuery可以理解成为“词条搜索”， * 在搜索引擎中最基本的搜索就是在索引中搜索某一词条，而TermQuery就是用来完成这项工作的。 * 在Lucene中词条是最基本的搜索单位，从本质上来讲一个词条其实就是一个名/值对。 * 只不过这个“名”是字段名，而“值”则表示字段中所包含的某个关键字。 * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void termQueryTest() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     String searchField = &quot;title&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //这是一个条件查询的api，用于添加条件    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     TermQuery query = new TermQuery(new Term(searchField, &quot;Spark&quot;));     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //执行查询，并打印查询到的记录数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     executeQuery(query);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="多条件查询">多条件查询<a href="#多条件查询" class="hash-link" aria-label="Direct link to 多条件查询" title="Direct link to 多条件查询">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 多条件查询 * * BooleanQuery也是实际开发过程中经常使用的一种Query。 * 它其实是一个组合的Query，在使用时可以把各种Query对象添加进去并标明它们之间的逻辑关系。 * BooleanQuery本身来讲是一个布尔子句的容器，它提供了专门的API方法往其中添加子句， * 并标明它们之间的关系，以下代码为BooleanQuery提供的用于添加子句的API接口： * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Testpublic void BooleanQueryTest() throws IOException { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String searchField1 = &quot;title&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String searchField2 = &quot;content&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Query query1 = new TermQuery(new Term(searchField1, &quot;Spark&quot;));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Query query2 = new TermQuery(new Term(searchField2, &quot;Apache&quot;));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BooleanQuery.Builder builder = new BooleanQuery.Builder();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BooleanClause用于表示布尔查询子句关系的类，    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 包 括：    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BooleanClause.Occur.MUST，    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BooleanClause.Occur.MUST_NOT，    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BooleanClause.Occur.SHOULD。    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 必须包含,不能包含,可以包含三种.有以下6种组合：    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1．MUST和MUST：取得连个查询子句的交集。    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2．MUST和MUST_NOT：表示查询结果中不能包含MUST_NOT所对应得查询子句的检索结果。    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3．SHOULD与MUST_NOT：连用时，功能同MUST和MUST_NOT。    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 4．SHOULD与MUST连用时，结果为MUST子句的检索结果,但是SHOULD可影响排序。    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 5．SHOULD与SHOULD：表示“或”关系，最终检索结果为所有检索子句的并集。    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 6．MUST_NOT和MUST_NOT：无意义，检索无结果。     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    builder.add(query1, BooleanClause.Occur.SHOULD);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    builder.add(query2, BooleanClause.Occur.SHOULD);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BooleanQuery query = builder.build();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //执行查询，并打印查询到的记录数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executeQuery(query);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="匹配前缀">匹配前缀<a href="#匹配前缀" class="hash-link" aria-label="Direct link to 匹配前缀" title="Direct link to 匹配前缀">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 匹配前缀 * &lt;p&gt; * PrefixQuery用于匹配其索引开始以指定的字符串的文档。就是文档中存在xxx% * &lt;p&gt; * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Testpublic void prefixQueryTest() throws IOException {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String searchField = &quot;title&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Term term = new Term(searchField, &quot;Spar&quot;);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Query query = new PrefixQuery(term);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//执行查询，并打印查询到的记录数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executeQuery(query);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="短语搜索">短语搜索<a href="#短语搜索" class="hash-link" aria-label="Direct link to 短语搜索" title="Direct link to 短语搜索">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 短语搜索 * &lt;p&gt; * 所谓PhraseQuery，就是通过短语来检索，比如我想查“big car”这个短语， * 那么如果待匹配的document的指定项里包含了&quot;big car&quot;这个短语， * 这个document就算匹配成功。可如果待匹配的句子里包含的是“big black car”， * 那么就无法匹配成功了，如果也想让这个匹配，就需要设定slop， * 先给出slop的概念：slop是指两个项的位置之间允许的最大间隔距离 * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Testpublic void phraseQueryTest() throws IOException {     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String searchField = &quot;content&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String query1 = &quot;apache&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String query2 = &quot;spark&quot;;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PhraseQuery.Builder builder = new PhraseQuery.Builder();    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">builder.add(new Term(searchField, query1));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">builder.add(new Term(searchField, query2));    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">builder.setSlop(0);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PhraseQuery phraseQuery = builder.build();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//执行查询，并打印查询到的记录数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executeQuery(phraseQuery);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查 询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="相近词语搜索">相近词语搜索<a href="#相近词语搜索" class="hash-link" aria-label="Direct link to 相近词语搜索" title="Direct link to 相近词语搜索">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 相近词语搜索 * &lt;p&gt; * FuzzyQuery是一种模糊查询，它可以简单地识别两个相近的词语。 * * @throws IOException */@Testpublic void fuzzyQueryTest() throws IOException { String searchField = &quot;content&quot;; Term t = new Term(searchField, &quot;大规模&quot;); Query query = new FuzzyQuery(t); //执行查询，并打印查询到的记录数 executeQuery(query);}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="通配符搜索">通配符搜索<a href="#通配符搜索" class="hash-link" aria-label="Direct link to 通配符搜索" title="Direct link to 通配符搜索">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 通配符搜索 * &lt;p&gt; * Lucene也提供了通配符的查询，这就是WildcardQuery。 * 通配符“?”代表1个字符，而“*”则代表0至多个字符。 * * @throws IOException */@Testpublic void wildcardQueryTest() throws IOException { String searchField = &quot;content&quot;; Term term = new Term(searchField, &quot;大*规模&quot;); Query query = new WildcardQuery(term); //执行查询，并打印查询到的记录数 executeQuery(query);}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="分词查询">分词查询<a href="#分词查询" class="hash-link" aria-label="Direct link to 分词查询" title="Direct link to 分词查询">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 分词查询 * * @throws IOException * @throws ParseException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void queryParserTest() throws IOException, ParseException {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new StandardAnalyzer(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    //Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     String searchField = &quot;content&quot;;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//指定搜索字段和分析器    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">QueryParser parser = new QueryParser(searchField, analyzer);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//用户输入内容    Query query = parser.parse(&quot;计算引擎&quot;);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//执行查询，并打印查询到的记录数    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executeQuery(query);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="多个-field-分词查询">多个 Field 分词查询<a href="#多个-field-分词查询" class="hash-link" aria-label="Direct link to 多个 Field 分词查询" title="Direct link to 多个 Field 分词查询">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 多个 Field 分词查询 * * @throws IOException * @throws ParseException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Testpublic void multiFieldQueryParserTest() throws IOException, ParseException {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new StandardAnalyzer(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     String[] filedStr = new String[]{&quot;title&quot;, &quot;content&quot;};     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//指定搜索字段和分析器    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">QueryParser queryParser = new MultiFieldQueryParser(filedStr, analyzer);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//用户输入内容    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Query query = queryParser.parse(&quot;Spark&quot;);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//执行查询，并打印查询到的记录数    executeQuery(query);}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>总共查询到1个文档id：1title：Sparkcontent：Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="中文分词器">中文分词器<a href="#中文分词器" class="hash-link" aria-label="Direct link to 中文分词器" title="Direct link to 中文分词器">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * IKAnalyzer  中文分词器 * SmartChineseAnalyzer  smartcn分词器 需要lucene依赖 且和lucene版本同步 * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void AnalyzerTest() throws IOException { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new StandardAnalyzer(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    //Analyzer analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    //Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Analyzer analyzer = null;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String text = &quot;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">analyzer = new IKAnalyzer();//IKAnalyzer 中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">printAnalyzerDoc(analyzer, text);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//MMSeg4j 中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">printAnalyzerDoc(analyzer, text);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println();     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">analyzer = new SmartChineseAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Lucene 中文分词器    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">printAnalyzerDoc(analyzer, text);}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>三种分词响应</p>
<p>apachespark专为大规模规模模数数据处理数据处理而设设计快速通用计算引擎</p>
<p>apachespark是专为大规模数据处理而设计的快速通用的计算引擎</p>
<p>apachspark是专为大规模数据处理而设计的快速通用的计算引擎</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="高亮处理">高亮处理<a href="#高亮处理" class="hash-link" aria-label="Direct link to 高亮处理" title="Direct link to 高亮处理">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/** * 高亮处理 * * @throws IOException */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void HighlighterTest() throws IOException, ParseException, InvalidTokenOffsetsException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new StandardAnalyzer(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准分词器，适用于英文   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new SmartChineseAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new ComplexAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     Analyzer analyzer = new IKAnalyzer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//中文分词     String searchField = &quot;content&quot;;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String text = &quot;Apache Spark 大规模数据处理&quot;;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//指定搜索字段和分析器    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">QueryParser parser = new QueryParser(searchField, analyzer);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//用户输入内容    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Query query = parser.parse(text);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TopDocs topDocs = indexSearcher.search(query, 100);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 关键字高亮显示的html标签，需要导入lucene-highlighter-xxx.jar    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(&quot;&quot;, &quot;&quot;);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Highlighter highlighter = new Highlighter(simpleHTMLFormatter, new QueryScorer(query));     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (ScoreDoc scoreDoc : topDocs.scoreDocs) {         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//取得对应的文档对象        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Document document = indexSearcher.doc(scoreDoc.doc);         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 内容增加高亮显示        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TokenStream tokenStream = analyzer.tokenStream(&quot;content&quot;, new StringReader(document.get(&quot;content&quot;)));        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String content = highlighter.getBestFragment(tokenStream, document.get(&quot;content&quot;));         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(content);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>响应</p>
<p>Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎!</p>
<p>代码我已放到 Github ，导入<code>spring-boot-lucene-demo</code> 项目</p>
<p><a href="https://docs.qq.com/doc/DWVNPQXRvcWhMTktC" target="_blank" rel="noopener noreferrer">github spring-boot-lucene-demo</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/backend/后端技术杂谈：Lucene基础原理与实践.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/backend/后端技术杂谈：Elasticsearch与solr入门实践"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">后端技术杂谈：Elasticsearch与solr入门实践</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/backend/后端技术杂谈：OpenStack的基石KVM"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">后端技术杂谈：OpenStack的基石KVM</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#二索引里面究竟存些什么" class="table-of-contents__link toc-highlight">二、索引里面究竟存些什么</a></li><li><a href="#三如何创建索引" class="table-of-contents__link toc-highlight">三、如何创建索引</a><ul><li><a href="#第一步一些要索引的原文档document" class="table-of-contents__link toc-highlight">第一步：一些要索引的原文档(Document)。</a></li><li><a href="#第二步将原文档传给分次组件tokenizer" class="table-of-contents__link toc-highlight">第二步：将原文档传给分次组件(Tokenizer)。</a></li><li><a href="#第三步将得到的词元token传给语言处理组件linguistic-processor" class="table-of-contents__link toc-highlight">第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。</a></li><li><a href="#第四步将得到的词term传给索引组件indexer" class="table-of-contents__link toc-highlight">第四步：将得到的词(Term)传给索引组件(Indexer)。</a></li></ul></li><li><a href="#三如何对索引进行搜索" class="table-of-contents__link toc-highlight">三、如何对索引进行搜索？</a><ul><li><a href="#第一步用户输入查询语句" class="table-of-contents__link toc-highlight">第一步：用户输入查询语句。</a></li><li><a href="#第二步对查询语句进行词法分析语法分析及语言处理" class="table-of-contents__link toc-highlight">第二步：对查询语句进行词法分析，语法分析，及语言处理。</a></li><li><a href="#第三步搜索索引得到符合语法树的文档" class="table-of-contents__link toc-highlight">第三步：搜索索引，得到符合语法树的文档。</a></li><li><a href="#第四步根据得到的文档和查询语句的相关性对结果进行排序" class="table-of-contents__link toc-highlight">第四步：根据得到的文档和查询语句的相关性，对结果进行排序。</a></li><li><a href="#1-计算权重term-weight的过程" class="table-of-contents__link toc-highlight">1. 计算权重(Term weight)的过程。</a></li><li><a href="#2-判断term之间的关系从而得到文档相关性的过程也即向量空间模型的算法vsm" class="table-of-contents__link toc-highlight">2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。</a></li></ul></li><li><a href="#spring-boot-中使用-java-api-调用-lucene" class="table-of-contents__link toc-highlight">Spring Boot 中使用 Java API 调用 lucene</a></li><li><a href="#github-代码" class="table-of-contents__link toc-highlight">Github 代码</a></li><li><a href="#添加依赖" class="table-of-contents__link toc-highlight">添加依赖</a></li><li><a href="#配置-lucene" class="table-of-contents__link toc-highlight">配置 lucene</a></li><li><a href="#创建索引" class="table-of-contents__link toc-highlight">创建索引</a></li><li><a href="#删除文档" class="table-of-contents__link toc-highlight">删除文档</a></li><li><a href="#更新文档" class="table-of-contents__link toc-highlight">更新文档</a></li><li><a href="#按词条搜索" class="table-of-contents__link toc-highlight">按词条搜索</a></li><li><a href="#多条件查询" class="table-of-contents__link toc-highlight">多条件查询</a></li><li><a href="#匹配前缀" class="table-of-contents__link toc-highlight">匹配前缀</a></li><li><a href="#短语搜索" class="table-of-contents__link toc-highlight">短语搜索</a></li><li><a href="#相近词语搜索" class="table-of-contents__link toc-highlight">相近词语搜索</a></li><li><a href="#通配符搜索" class="table-of-contents__link toc-highlight">通配符搜索</a></li><li><a href="#分词查询" class="table-of-contents__link toc-highlight">分词查询</a></li><li><a href="#多个-field-分词查询" class="table-of-contents__link toc-highlight">多个 Field 分词查询</a></li><li><a href="#中文分词器" class="table-of-contents__link toc-highlight">中文分词器</a></li><li><a href="#高亮处理" class="table-of-contents__link toc-highlight">高亮处理</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-backend/后端技术杂谈：先搞懂Docker核心概念吧" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">后端技术杂谈：先搞懂Docker核心概念吧 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="后端技术杂谈：先搞懂Docker核心概念吧 | Tommy"><meta data-rh="true" name="description" content="一、简介"><meta data-rh="true" property="og:description" content="一、简介"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">后端技术杂谈：白话虚拟化技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：捋一捋大数据研发的基本概念">后端技术杂谈：捋一捋大数据研发的基本概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：十分钟理解Kubernetes核心概念">后端技术杂谈：十分钟理解Kubernetes核心概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：搜索引擎工作原理">后端技术杂谈：搜索引擎工作原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：搜索引擎基础倒排索引">后端技术杂谈：搜索引擎基础倒排索引</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/code-note-blog/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧">后端技术杂谈：先搞懂Docker核心概念吧</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：云计算的前世今生">后端技术杂谈：云计算的前世今生</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：Docker 核心技术与实现原理">后端技术杂谈：Docker 核心技术与实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：Elasticsearch与solr入门实践">后端技术杂谈：Elasticsearch与solr入门实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：Lucene基础原理与实践">后端技术杂谈：Lucene基础原理与实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：OpenStack的基石KVM">后端技术杂谈：OpenStack的基石KVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈：OpenStack架构设计">后端技术杂谈：OpenStack架构设计</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/后端技术杂谈开篇：云计算，大数据与AI的故事">后端技术杂谈开篇：云计算，大数据与AI的故事</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/backend/Hadoop生态总结">Hadoop生态总结</a></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">后端技术杂谈：先搞懂Docker核心概念吧</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>后端技术杂谈：先搞懂Docker核心概念吧</h1></header><p><strong>一、简介</strong></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="1了解docker的前生lxc">1、了解Docker的前生LXC<a href="#1了解docker的前生lxc" class="hash-link" aria-label="Direct link to 1、了解Docker的前生LXC" title="Direct link to 1、了解Docker的前生LXC">​</a></h2>
<p>LXC为Linux Container的简写。可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。相当于C++中的NameSpace。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。</p>
<p>与传统虚拟化技术相比，它的优势在于：  （1）与宿主机使用同一个内核，性能损耗小；  （2）不需要指令级模拟；  （3）不需要即时(Just-in-time)编译；  （4）容器可以在CPU核心的本地运行指令，不需要任何专门的解释机制；（5）避免了准虚拟化和系统调用替换中的复杂性；  （6）轻量级隔离，在隔离的同时还提供共享机制，以实现容器与宿主机的资源共享。</p>
<p>总结：Linux Container是一种轻量级的虚拟化的手段。  Linux Container提供了在单一可控主机节点上支持多个相互隔离的server container同时执行的机制。Linux Container有点像chroot，提供了一个拥有自己进程和网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="2lxc与docker什么关系">2、LXC与docker什么关系？<a href="#2lxc与docker什么关系" class="hash-link" aria-label="Direct link to 2、LXC与docker什么关系？" title="Direct link to 2、LXC与docker什么关系？">​</a></h2>
<p>docker并不是LXC替代品，docker底层使用了LXC来实现，LXC将linux进程沙盒化，使得进程之间相互隔离，并且能对各进程资源合理分配。  在LXC的基础之上，docker提供了一系列更强大的功能。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="3什么是docker">3、什么是docker<a href="#3什么是docker" class="hash-link" aria-label="Direct link to 3、什么是docker" title="Direct link to 3、什么是docker">​</a></h2>
<p>docker是一个开源的应用容器引擎，基于go语言开发并遵循了apache2.0协议开源。  docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux服务器，也可以实现虚拟化。  容器是完全使用沙箱机制，相互之间不会有任何接口（类iphone的app），并且容器开销极其低。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="4docker官方文档">4、docker官方文档<a href="#4docker官方文档" class="hash-link" aria-label="Direct link to 4、docker官方文档" title="Direct link to 4、docker官方文档">​</a></h2>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="5为什么docker越来越受欢迎">5、为什么docker越来越受欢迎<a href="#5为什么docker越来越受欢迎" class="hash-link" aria-label="Direct link to 5、为什么docker越来越受欢迎" title="Direct link to 5、为什么docker越来越受欢迎">​</a></h2>
<p>官方话语：</p>
<ul>
<li>
<p>容器化越来越受欢迎，因为容器是：</p>
</li>
<li>
<p>灵活：即使是最复杂的应用也可以集装箱化。</p>
</li>
<li>
<p>轻量级：容器利用并共享主机内核。</p>
</li>
<li>
<p>可互换：您可以即时部署更新和升级。</p>
</li>
<li>
<p>便携式：您可以在本地构建，部署到云，并在任何地方运行。</p>
</li>
<li>
<p>可扩展：您可以增加并自动分发容器副本。</p>
</li>
<li>
<p>可堆叠：您可以垂直和即时堆叠服务。</p>
</li>
<li>
<p>镜像和容器（contalners）</p>
</li>
</ul>
<p>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码，运行时间，库、环境变量 、和配置文件。  容器是镜像的运行实例，当被运行时有镜像状态和用户进程，可以使用docker ps 查看。</p>
<ul>
<li>容器和虚拟机</li>
</ul>
<p>容器是在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。  虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120435.png" alt="" class="img_kGBN"></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="6docker版本">6、docker版本<a href="#6docker版本" class="hash-link" aria-label="Direct link to 6、docker版本" title="Direct link to 6、docker版本">​</a></h2>
<p>Docker Community Edition（CE）社区版  Enterprise Edition(EE) 商业版</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="7docker和openstack的几项对比">7、docker和openstack的几项对比<a href="#7docker和openstack的几项对比" class="hash-link" aria-label="Direct link to 7、docker和openstack的几项对比" title="Direct link to 7、docker和openstack的几项对比">​</a></h2>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120450.png" alt="" class="img_kGBN"></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="8容器在内核中支持2种重要技术">8、容器在内核中支持2种重要技术<a href="#8容器在内核中支持2种重要技术" class="hash-link" aria-label="Direct link to 8、容器在内核中支持2种重要技术" title="Direct link to 8、容器在内核中支持2种重要技术">​</a></h2>
<p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）</p>
<p>1）namespaces 名称空间</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120519.png" alt="" class="img_kGBN"></p>
<p>2）control Group 控制组cgroup的特点是：</p>
<ul>
<li>
<p>cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理</p>
</li>
<li>
<p>cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源的分配和再利用</p>
</li>
<li>
<p>所有资源管理的功能都以子系统的方式实现，接口统一子任务创建之初与其父任务处于同一个cgroup的控制组</p>
</li>
</ul>
<p>四大功能：</p>
<ul>
<li>
<p>资源限制：可以对任务使用的资源总额进行限制</p>
</li>
<li>
<p>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级</p>
</li>
<li>
<p>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等</p>
</li>
<li>
<p>任务控制：cgroup可以对任务执行挂起、恢复等操作</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="9了解docker三个重要概念">9、了解docker三个重要概念<a href="#9了解docker三个重要概念" class="hash-link" aria-label="Direct link to 9、了解docker三个重要概念" title="Direct link to 9、了解docker三个重要概念">​</a></h2>
<p>1）image镜像  docker镜像就是一个只读模板，比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器，另外docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下一个已经做好的镜像来直接使用</p>
<p>2）container容器  docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动，开始、停止、删除、每个容器都是互相隔离的，保证  安全的平台，可以把容器看做是要给简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序</p>
<p>3）repostory仓库  仓库是集中存储镜像文件的沧桑，registry是仓库主从服务器，实际上参考注册服务器上存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）  仓库分为两种，公有参考，和私有仓库，最大的公开仓库是docker Hub，存放了数量庞大的镜像供用户下载，国内的docker pool，这里仓库的概念与Git类似，registry可以理解为github这样的托管服务。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="10docker的主要用途">10、docker的主要用途<a href="#10docker的主要用途" class="hash-link" aria-label="Direct link to 10、docker的主要用途" title="Direct link to 10、docker的主要用途">​</a></h2>
<p>官方就是Bulid 、ship、run any app/any where，编译、装载、运行、任何app/在任意地方都能运行。就是实现了应用的封装、部署、运行的生命周期管理只要在glibc的环境下，都可以运行。运维生成环境中：docker化。</p>
<ul>
<li>
<p>发布服务不用担心服务器的运行环境，所有的服务器都是自动分配docker，自动部署，自动安装，自动运行</p>
</li>
<li>
<p>再不用担心其他服务引擎的磁盘问题，cpu问题，系统问题了</p>
</li>
<li>
<p>资源利用更出色</p>
</li>
<li>
<p>自动迁移，可以制作镜像，迁移使用自定义的镜像即可迁移，不会出现什么问题</p>
</li>
<li>
<p>管理更加方便了</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="11docker改变了什么">11、docker改变了什么<a href="#11docker改变了什么" class="hash-link" aria-label="Direct link to 11、docker改变了什么" title="Direct link to 11、docker改变了什么">​</a></h2>
<ul>
<li>
<p>面向产品：产品交付</p>
</li>
<li>
<p>面向开 发：简化环境配置</p>
</li>
<li>
<p>面向测试：多版本测试</p>
</li>
<li>
<p>面向运维：环境一致性</p>
</li>
<li>
<p>面向架构：自动化扩容（微服务）</p>
</li>
</ul>
<p><strong>二、docker架构</strong></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="1总体架构">1、总体架构<a href="#1总体架构" class="hash-link" aria-label="Direct link to 1、总体架构" title="Direct link to 1、总体架构">​</a></h2>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120534.png" alt="" class="img_kGBN"></p>
<ul>
<li>
<p>distribution 负责与docker registry交互，上传洗澡镜像以及v2 registry 有关的源数据</p>
</li>
<li>
<p>registry负责docker registry有关的身份认证、镜像查找、镜像验证以及管理registry mirror等交互操作</p>
</li>
<li>
<p>image 负责与镜像源数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出操作</p>
</li>
<li>
<p>reference负责存储本地所有镜像的repository和tag名，并维护与镜像id之间的映射关系</p>
</li>
<li>
<p>layer模块负责与镜像层和容器层源数据有关的增删改查，并负责将镜像层的增删改查映射到实际存储镜像层文件的graphdriver模块</p>
</li>
<li>
<p>graghdriver是所有与容器镜像相关操作的执行者</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="2docker架构2">2、docker架构2<a href="#2docker架构2" class="hash-link" aria-label="Direct link to 2、docker架构2" title="Direct link to 2、docker架构2">​</a></h2>
<p>如果觉得上面架构图比较乱可以看这个架构：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120545.png" alt="" class="img_kGBN"></p>
<p>从上图不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</p>
<p>而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以 接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</p>
<p>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</p>
<p>而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="3docker架构3">3、docker架构3<a href="#3docker架构3" class="hash-link" aria-label="Direct link to 3、docker架构3" title="Direct link to 3、docker架构3">​</a></h2>
<p>再来看看另外一个架构，这个个架构就简单清晰指明了server/client交互，容器和镜像、数据之间的一些联系。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120558.png" alt="" class="img_kGBN"></p>
<p>这个架构图更加清晰了架构</p>
<p>docker daemon就是docker的守护进程即server端，可以是远程的，也可以是本地的，这个不是C/S架构吗，客户端Docker client 是通过rest api进行通信。</p>
<p>docker cli 用来管理容器和镜像，客户端提供一个只读镜像，然后通过镜像可以创建多个容器，这些容器可以只是一个RFS（Root file system根文件系统），也可以ishi一个包含了用户应用的RFS，容器在docker client中只是要给进程，两个进程之间互不可见。</p>
<p>用户不能与server直接交互，但可以通过与容器这个桥梁来交互，由于是操作系统 级别的虚拟技术，中间的损耗几乎可以不计。</p>
<p><strong>三、docker架构2各个模块的功能（待完善）</strong></p>
<p>主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="1docker-client">1、docker client<a href="#1docker-client" class="hash-link" aria-label="Direct link to 1、docker client" title="Direct link to 1、docker client">​</a></h2>
<p>docker client 是docker架构中用户用来和docker daemon建立通信的客户端，用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。</p>
<p>docker client可以通过一下三宗方式和docker daemon建立通信：docker client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。</p>
<p>docker client发送容器管理请求后，由docker daemon接受并处理请求，当docker client 接收到返回的请求相应并简单处理后，docker client 一次完整的生命周期就结束了，当需要继续发送容器管理请求时，用户必须再次通过docker可以执行文件创建docker client。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="2docker-daemon">2、docker daemon<a href="#2docker-daemon" class="hash-link" aria-label="Direct link to 2、docker daemon" title="Direct link to 2、docker daemon">​</a></h2>
<p>docker daemon 是docker架构中一个常驻在后台的系统进程，功能是：接收处理docker client发送的请求。该守护进程在后台启动一个server，server负载接受docker client发送的请求；接受请求后，server通过路由与分发调度，找到相应的handler来执行请求。</p>
<p>docker daemon启动所使用的可执行文件也为docker，与docker client启动所使用的可执行文件docker相同，在docker命令执行时，通过传入的参数来判别docker daemon与docker client。</p>
<p>docker daemon的架构可以分为：docker server、engine、job。daemon</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="3docker-server">3、docker server<a href="#3docker-server" class="hash-link" aria-label="Direct link to 3、docker server" title="Direct link to 3、docker server">​</a></h2>
<p>docker server在docker架构中时专门服务于docker client的server，该server的功能是：接受并调度分发docker client发送的请求，架构图如下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120607.png" alt="" class="img_kGBN"></p>
<p>在Docker的启动过程中，通过包gorilla/mux（golang的类库解析），创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</p>
<p>若Docker Client通过HTTP的形式访问Docker Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server<!-- -->，最终执行httpSrv.Serve()为请求服务。</p>
<p>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</p>
<p>需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="4engine">4、engine<a href="#4engine" class="hash-link" aria-label="Direct link to 4、engine" title="Direct link to 4、engine">​</a></h2>
<p>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</p>
<p>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：<code>{“create”: daemon.ContainerCreate,}</code>，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="5job">5、job<a href="#5job" class="hash-link" aria-label="Direct link to 5、job" title="Direct link to 5、job">​</a></h2>
<p>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。</p>
<p>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="6docker-registry">6、docker registry<a href="#6docker-registry" class="hash-link" aria-label="Direct link to 6、docker registry" title="Direct link to 6、docker registry">​</a></h2>
<p>Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。</p>
<p>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</p>
<p>其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="7graph">7、Graph<a href="#7graph" class="hash-link" aria-label="Direct link to 7、Graph" title="Direct link to 7、Graph">​</a></h2>
<p>Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120623.png" alt="" class="img_kGBN"></p>
<p>其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</p>
<p>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="8driver">8、driver<a href="#8driver" class="hash-link" aria-label="Direct link to 8、driver" title="Direct link to 8、driver">​</a></h2>
<p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。</p>
<p>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</p>
<p>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</p>
<p>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</p>
<p>graphdriver的架构如下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120634.png" alt="" class="img_kGBN"></p>
<p>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120642.png" alt="" class="img_kGBN"></p>
<p>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或 者说Docker实现跨平台的一个先兆。execdriver架构如下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120652.png" alt="" class="img_kGBN"></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="9libcontainer">9、libcontainer<a href="#9libcontainer" class="hash-link" aria-label="Direct link to 9、libcontainer" title="Direct link to 9、libcontainer">​</a></h2>
<p>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</p>
<p>正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如下：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120659.png" alt="" class="img_kGBN"></p>
<p>另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。</p>
<p>暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="10docker-container">10、docker container<a href="#10docker-container" class="hash-link" aria-label="Direct link to 10、docker container" title="Direct link to 10、docker container">​</a></h2>
<p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。Docker按照用户的需求与指令，订制相应的Docker容器：</p>
<ul>
<li>
<p>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</p>
</li>
<li>
<p>用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</p>
</li>
<li>
<p>用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</p>
</li>
<li>
<p>用户通过指定运行的命令，使得Docker容器执行指定的工作。</p>
</li>
</ul>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230408120710.png" alt="" class="img_kGBN"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/backend/后端技术杂谈：先搞懂Docker核心概念吧.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/backend/后端技术杂谈：搜索引擎基础倒排索引"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">后端技术杂谈：搜索引擎基础倒排索引</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/backend/后端技术杂谈：云计算的前世今生"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">后端技术杂谈： 云计算的前世今生</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1了解docker的前生lxc" class="table-of-contents__link toc-highlight">1、了解Docker的前生LXC</a></li><li><a href="#2lxc与docker什么关系" class="table-of-contents__link toc-highlight">2、LXC与docker什么关系？</a></li><li><a href="#3什么是docker" class="table-of-contents__link toc-highlight">3、什么是docker</a></li><li><a href="#4docker官方文档" class="table-of-contents__link toc-highlight">4、docker官方文档</a></li><li><a href="#5为什么docker越来越受欢迎" class="table-of-contents__link toc-highlight">5、为什么docker越来越受欢迎</a></li><li><a href="#6docker版本" class="table-of-contents__link toc-highlight">6、docker版本</a></li><li><a href="#7docker和openstack的几项对比" class="table-of-contents__link toc-highlight">7、docker和openstack的几项对比</a></li><li><a href="#8容器在内核中支持2种重要技术" class="table-of-contents__link toc-highlight">8、容器在内核中支持2种重要技术</a></li><li><a href="#9了解docker三个重要概念" class="table-of-contents__link toc-highlight">9、了解docker三个重要概念</a></li><li><a href="#10docker的主要用途" class="table-of-contents__link toc-highlight">10、docker的主要用途</a></li><li><a href="#11docker改变了什么" class="table-of-contents__link toc-highlight">11、docker改变了什么</a></li><li><a href="#1总体架构" class="table-of-contents__link toc-highlight">1、总体架构</a></li><li><a href="#2docker架构2" class="table-of-contents__link toc-highlight">2、docker架构2</a></li><li><a href="#3docker架构3" class="table-of-contents__link toc-highlight">3、docker架构3</a></li><li><a href="#1docker-client" class="table-of-contents__link toc-highlight">1、docker client</a></li><li><a href="#2docker-daemon" class="table-of-contents__link toc-highlight">2、docker daemon</a></li><li><a href="#3docker-server" class="table-of-contents__link toc-highlight">3、docker server</a></li><li><a href="#4engine" class="table-of-contents__link toc-highlight">4、engine</a></li><li><a href="#5job" class="table-of-contents__link toc-highlight">5、job</a></li><li><a href="#6docker-registry" class="table-of-contents__link toc-highlight">6、docker registry</a></li><li><a href="#7graph" class="table-of-contents__link toc-highlight">7、Graph</a></li><li><a href="#8driver" class="table-of-contents__link toc-highlight">8、driver</a></li><li><a href="#9libcontainer" class="table-of-contents__link toc-highlight">9、libcontainer</a></li><li><a href="#10docker-container" class="table-of-contents__link toc-highlight">10、docker container</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
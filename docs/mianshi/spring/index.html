<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-mianshi/spring" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Spring | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/mianshi/spring"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Spring | Tommy"><meta data-rh="true" name="description" content="Spring面试题，35道Spring八股文（1.3万字63张手绘图），面渣逆袭必看👍"><meta data-rh="true" property="og:description" content="Spring面试题，35道Spring八股文（1.3万字63张手绘图），面渣逆袭必看👍"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/mianshi/spring"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/mianshi/spring" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/mianshi/spring" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/collection">Java集合框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/fenbushi">分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/javabasic">Java 基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/javase">Java SE</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/javathread">Java并发编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/jvm">JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/mybatis">MyBatis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/mysql">MySQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/network">计算机网络</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/nixi">面渣逆袭</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/os">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/redis">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/rocketmq">RocketMQ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/code-note-blog/docs/mianshi/spring">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/mianshi/weifuwu">微服务</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/code-note-blog/docs/test/b">b</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Spring</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Spring</h1></header><p>1.3 万字 63 张手绘图，详解 35 道 Spring 面试高频题（让天下没有难背的八股），面渣背会这些 Spring 八股文，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳<a href="https://mp.weixin.qq.com/s/EQge6DmgIqYITM3mAxkatg" target="_blank" rel="noopener noreferrer">转载链接</a>，作者：三分恶，戳<a href="https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ" target="_blank" rel="noopener noreferrer">原文链接</a>。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="基础">基础<a href="#基础" class="hash-link" aria-label="Direct link to 基础" title="Direct link to 基础">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="1spring-是什么特性  有哪些模块">1.Spring 是什么？特性？有哪些模块？<a href="#1spring-是什么特性有哪些模块" class="hash-link" aria-label="Direct link to 1.Spring 是什么？特性？有哪些模块？" title="Direct link to 1.Spring 是什么？特性？有哪些模块？">​</a></h3>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-301-55cfaad2b2ba4e586a19810c5f498893.png" width="1200" height="600" class="img_kGBN"></p>
<p>一句话概括：<strong>Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。</strong></p>
<p>2003 年，一个音乐家 Rod Johnson 决定发展一个轻量级的 Java 开发框架，<code>Spring</code>作为 Java 战场的龙骑兵渐渐崛起，并淘汰了<code>EJB</code>这个传统的重装骑兵。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-302-ee740efb06f603032af7f083f613bd3c.png" width="893" height="242" class="img_kGBN"></p>
<p>到了现在，企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p>
<blockquote>
<p>Spring 有哪些特性呢？</p>
</blockquote>
<p>Spring 有很多优点：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-303-872435c23d17bbef1748fafb9d489f6a.png" width="702" height="578" class="img_kGBN"></p>
<ol>
<li><strong>IOC</strong> 和 <strong>DI</strong> 的支持</li>
</ol>
<p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现<strong>高内聚低耦合</strong>的设计理念。</p>
<ol start="2">
<li>AOP 编程的支持</li>
</ol>
<p>Spring 提供了<strong>面向切面编程</strong>，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p>
<ol start="3">
<li>声明式事务的支持</li>
</ol>
<p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方  式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p>
<ol start="4">
<li>快捷测试的支持</li>
</ol>
<p>Spring 对 Junit 提供支持，可以通过<strong>注解</strong>快捷地测试 Spring 程序。</p>
<ol start="5">
<li>快速集成功能</li>
</ol>
<p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p>
<ol start="6">
<li>复杂 API 模板封装</li>
</ol>
<p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="2spring-有哪些模块呢">2.Spring 有哪些模块呢？<a href="#2spring-有哪些模块呢" class="hash-link" aria-label="Direct link to 2.Spring 有哪些模块呢？" title="Direct link to 2.Spring 有哪些模块呢？">​</a></h3>
<p>Spring 框架是分模块存在，除了最核心的<code>Spring Core Container</code>是必要模块之外，其他模块都是<code>可选</code>，大约有 20 多个模块。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-304-de5da574938c4142242fae2a4f464909.png" width="694" height="508" class="img_kGBN"></p>
<p>最主要的七大模块：</p>
<ol>
<li><strong>Spring Core</strong>：Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。</li>
<li><strong>Spring Context</strong>：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li>
<li><strong>Spring Web</strong>：它提供 Web 应用开发的支持。</li>
<li><strong>Spring MVC</strong>：它针对 Web 应用中 MVC 思想的实现。</li>
<li><strong>Spring DAO</strong>：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li>
<li><strong>Spring ORM</strong>：它支持用于流行的 ORM 框架 的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</li>
<li><strong>Spring AOP</strong>：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="3spring-有哪些常用注解呢">3.Spring 有哪些常用注解呢？<a href="#3spring-有哪些常用注解呢" class="hash-link" aria-label="Direct link to 3.Spring 有哪些常用注解呢？" title="Direct link to 3.Spring 有哪些常用注解呢？">​</a></h3>
<p>Spring 有很多模块，甚至广义的 SpringBoot、SpringCloud 也算是 Spring 的一部分，我们来分模块，按功能来看一下一些常用的注解：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-305-18f664c768129ec5457522a691f333f0.png" width="1026" height="1347" class="img_kGBN"></p>
<p><strong>Web</strong>:</p>
<ul>
<li>@Controller：组合注解（组合了@Component 注解），应用在 MVC 层（控制层）。</li>
<li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li>
<li>@RequestMapping：用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：<!-- -->
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
</ul>
</li>
<li>@ResponseBody：支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</li>
<li>@RequestBody：允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</li>
<li>@PathVariable：用于接收路径参数，比如 <code>@RequestMapping(“/hello/{name}”)</code>申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</li>
<li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li>
</ul>
<p><strong>容器</strong>:</p>
<ul>
<li>@Component：表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</li>
<li>@Service：组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</li>
<li>@Repository：组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</li>
<li>@Autowired：Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li>
<li>@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</li>
<li>@Configuration：声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</li>
<li>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 <code>#{} 跟 \${}</code> 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</li>
<li>@Bean：注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在<code>@Bean(initMethod=”init”,destroyMethod=”destroy”)</code>定义，在构造之后执行 init，在销毁之前执行 destroy。</li>
<li>@Scope:定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</li>
</ul>
<p><strong>AOP</strong>:</p>
<ul>
<li>@Aspect:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。<!-- -->
<ul>
<li><code>@After</code> ：在方法执行之后执行（方法上）。</li>
<li><code>@Before</code>： 在方法执行之前执行（方法上）。</li>
<li><code>@Around</code>： 在方法执行之前与之后执行（方法上）。</li>
<li><code>@PointCut</code>： 声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</li>
</ul>
</li>
</ul>
<p><strong>事务：</strong></p>
<ul>
<li>@Transactional：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="4spring-中应用了哪些设计模式呢">4.Spring 中应用了哪些设计模式呢？<a href="#4spring-中应用了哪些设计模式呢" class="hash-link" aria-label="Direct link to 4.Spring 中应用了哪些设计模式呢？" title="Direct link to 4.Spring 中应用了哪些设计模式呢？">​</a></h3>
<p>Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-306-09006e26b928378199335306e2f891f6.png" width="795" height="667" class="img_kGBN"></p>
<ol>
<li><strong>工厂模式</strong> : Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>
<li><strong>代理模式</strong> : Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li>
<li><strong>单例模式</strong> : Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</li>
<li><strong>模板模式</strong> : Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</li>
<li><strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> <!-- -->:Spring<!-- --> AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li>
<li><strong>策略模式</strong>：Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="ioc">IOC<a href="#ioc" class="hash-link" aria-label="Direct link to IOC" title="Direct link to IOC">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="5说一说什么是-ioc什么是-di">5.说一说什么是 IOC？什么是 DI?<a href="#5说一说什么是-ioc什么是-di" class="hash-link" aria-label="Direct link to 5.说一说什么是 IOC？什么是 DI?" title="Direct link to 5.说一说什么是 IOC？什么是 DI?">​</a></h3>
<p>Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。</p>
<p>所谓的<strong>IOC</strong>（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-307-078f954108fa0549c0be743a37d85bc7.png" width="1330" height="569" class="img_kGBN"></p>
<p>也就是说，控制对象生命周期的不再是引用它的对象，而是容器。对具体对象，以前是它控制其它对象，现在所有对象都被容器控制，所以这就叫<strong>控制反转</strong>。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-308-88967a441de35c2163965ab17b034be0.png" width="655" height="357" class="img_kGBN"></p>
<p><strong>DI（依赖注入）</strong>：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法 IOC 和 DI 是一回事，有的说法是 IOC 是思想，DI 是 IOC 的实现。</p>
<blockquote>
<p><strong>为什么要使用 IOC 呢？</strong></p>
</blockquote>
<p>最主要的是两个字<strong>解耦</strong>，硬编码会造成对象间的过度耦合，使用 IOC 之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="6能简单说一下-spring-ioc-的实现机制吗">6.能简单说一下 Spring IOC 的实现机制吗？<a href="#6能简单说一下-spring-ioc-的实现机制吗" class="hash-link" aria-label="Direct link to 6.能简单说一下 Spring IOC 的实现机制吗？" title="Direct link to 6.能简单说一下 Spring IOC 的实现机制吗？">​</a></h3>
<p>PS:这道题老三在面试中被问到过，问法是“<strong>你有自己实现过简单的 Spring 吗？</strong>”</p>
<p>Spring 的 IOC 本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-309-c7d791d719afcae3124012b2015108d5.png" width="710" height="509" class="img_kGBN"></p>
<ul>
<li>
<p><strong>生产产品</strong>：一个工厂最核心的功能就是生产产品。在 Spring 里，不用 Bean 自己来实例化，而是交给 Spring，应该怎么实现呢？——答案毫无疑问，<strong>反射</strong>。</p>
<p>那么这个厂子的生产管理是怎么做的？你应该也知道——<strong>工厂模式</strong>。</p>
</li>
<li>
<p><strong>库存产品</strong>：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring 我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p>
</li>
<li>
<p><strong>订单处理</strong>：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。</p>
<p>在 Spring 里，也有这样的订单，它就是我们 bean 的定义和依赖关系，可以是 xml 形式，也可以是我们最熟悉的注解形式。</p>
</li>
</ul>
<p>我们简单地实现一个 mini 版的 Spring IOC：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-310-9c340ee4fbe7094d411d4dcfdfc90e3d.png" width="1061" height="299" class="img_kGBN"></p>
<p><strong>Bean 定义：</strong></p>
<p>Bean 通过一个配置文件定义，把它解析成一个类型。</p>
<ul>
<li>
<p>beans.properties</p>
<p>偷懒，这里直接用了最方便解析的 properties，这里直接用一个<code>&lt;key,value&gt;</code>类型的配置来代表 Bean 的定义，其中 key 是 beanName，value 是 class</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">userDao:cn.fighter3.bean.UserDao</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>BeanDefinition.java</p>
<p>bean 定义类，配置文件中 bean 定义对应的实体</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class BeanDefinition {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String beanName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Class beanClass;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //省略getter、setter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>ResourceLoader.java</p>
<p>资源加载器，用来完成配置文件中配置的加载</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class ResourceLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Map&lt;String, BeanDefinition&gt; getResource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;&gt;(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Properties properties = new Properties();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            InputStream inputStream = ResourceLoader.class.getResourceAsStream(&quot;/beans.properties&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.load(inputStream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator&lt;String&gt; it = properties.stringPropertyNames().iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (it.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String key = it.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String className = properties.getProperty(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                BeanDefinition beanDefinition = new BeanDefinition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                beanDefinition.setBeanName(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Class clazz = Class.forName(className);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                beanDefinition.setBeanClass(clazz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                beanDefinitionMap.put(key, beanDefinition);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException | ClassNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return beanDefinitionMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>BeanRegister.java</p>
<p>对象注册器，这里用于单例 bean 的缓存，我们大幅简化，默认所有 bean 都是单例的。可以看到所谓单例注册，也很简单，不过是往 HashMap 里存对象。</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class BeanRegister {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //单例Bean缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Map&lt;String, Object&gt; singletonMap = new HashMap&lt;&gt;(32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取单例Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param beanName bean名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getSingletonBean(String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return singletonMap.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 注册单例bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param beanName</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void registerSingletonBean(String beanName, Object bean) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (singletonMap.containsKey(beanName)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        singletonMap.put(beanName, bean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><strong>BeanFactory.java</strong></p>
</li>
</ul>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-311-072b3665c85eef2009ec525eb139f8ae.png" width="432" height="270" class="img_kGBN"></p>
<ul>
<li>
<p>对象工厂，我们最<strong>核心</strong>的一个类，在它初始化的时候，创建了 bean 注册器，完成了资源的加载。</p>
</li>
<li>
<p>获取 bean 的时候，先从单例缓存中取，如果没有取到，就创建并注册一个 bean</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class BeanFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BeanRegister beanRegister;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BeanFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建bean注册器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        beanRegister = new BeanRegister();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //加载资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.beanDefinitionMap = new ResourceLoader().getResource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param beanName bean名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getBean(String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //从bean缓存中取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object bean = beanRegister.getSingletonBean(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据bean定义，创建bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return createBean(beanDefinitionMap.get(beanName));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param beanDefinition bean定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object createBean(BeanDefinition beanDefinition) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object bean = beanDefinition.getBeanClass().newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //缓存bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InstantiationException | IllegalAccessException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>测试</p>
<ul>
<li>
<p>UserDao.java</p>
<p>我们的 Bean 类，很简单</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class UserDao {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void queryUserInfo(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;A good man.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>单元测试</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class ApiTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test_BeanFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BeanFactory beanFactory = new BeanFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //2.第一次获取bean（通过反射创建bean，缓存bean）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserDao userDao1 = (UserDao) beanFactory.getBean(&quot;userDao&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        userDao1.queryUserInfo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //3.第二次获取bean（从缓存中获取bean）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserDao userDao2 = (UserDao) beanFactory.getBean(&quot;userDao&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        userDao2.queryUserInfo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>运行结果</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">A good man.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">A good man.</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
</li>
</ul>
<p>至此，我们一个乞丐+破船版的 Spring 就完成了，代码也比较完整，有条件的可以跑一下。</p>
<p>PS:因为时间+篇幅的限制，这个 demo 比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足，感兴趣可以学习参考[15]。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="7说说-beanfactory-和-applicantcontext">7.说说 BeanFactory 和 ApplicantContext?<a href="#7说说-beanfactory-和-applicantcontext" class="hash-link" aria-label="Direct link to 7.说说 BeanFactory 和 ApplicantContext?" title="Direct link to 7.说说 BeanFactory 和 ApplicantContext?">​</a></h3>
<p>可以这么形容，BeanFactory 是 Spring 的“心脏”，ApplicantContext 是完整的“身躯”。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-312-ff9883d79712b6802558f2c8f63d2c92.png" width="330" height="454" class="img_kGBN"></p>
<ul>
<li>BeanFactory（Bean 工厂）是 Spring 框架的基础设施，面向 Spring 本身。</li>
<li>ApplicantContext（应用上下文）建立在 BeanFactoty 基础上，面向使用 Spring 框架的开发者。</li>
</ul>
<h6 class="anchor anchorWithStickyNavbar_HWLp" id="beanfactory-接口">BeanFactory 接口<a href="#beanfactory-接口" class="hash-link" aria-label="Direct link to BeanFactory 接口" title="Direct link to BeanFactory 接口">​</a></h6>
<p>BeanFactory 是类的通用工厂，可以创建并管理各种类的对象。</p>
<p>Spring 为 BeanFactory 提供了很多种实现，最常用的是 XmlBeanFactory，但在 Spring 3.2 中已被废弃，建议使用 XmlBeanDefinitionReader、DefaultListableBeanFactory。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-313-3e82ec1aff99af824097db12c3d5ebc7.png" width="1227" height="816" class="img_kGBN"></p>
<p>BeanFactory 接口位于类结构树的顶端，它最主要的方法就是 getBean(String var1)，这个方法从容器中返回特定名称的 Bean。</p>
<p>BeanFactory 的功能通过其它的接口得到了不断的扩展，比如 AbstractAutowireCapableBeanFactory 定义了将容器中的 Bean 按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。</p>
<p>这里看一个 XMLBeanFactory（已过期） 获取 bean 的例子：</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorldApp{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      BeanFactory factory = new XmlBeanFactory (new ClassPathResource(&quot;beans.xml&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      HelloWorld obj = (HelloWorld) factory.getBean(&quot;helloWorld&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      obj.getMessage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h6 class="anchor anchorWithStickyNavbar_HWLp" id="applicationcontext-接口">ApplicationContext 接口<a href="#applicationcontext-接口" class="hash-link" aria-label="Direct link to ApplicationContext 接口" title="Direct link to ApplicationContext 接口">​</a></h6>
<p>ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。可以这么说，使用 BeanFactory 就是手动档，使用 ApplicationContext 就是自动档。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-314-4aee845ab798f1b58638b0e281986d92.png" width="1140" height="792" class="img_kGBN"></p>
<p>ApplicationContext 继承了 HierachicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过其他的接口扩展了 BeanFactory 的功能，包括：</p>
<ul>
<li>
<p>Bean instantiation/wiring</p>
</li>
<li>
<p>Bean 的实例化/串联</p>
</li>
<li>
<p>自动的 BeanPostProcessor 注册</p>
</li>
<li>
<p>自动的 BeanFactoryPostProcessor 注册</p>
</li>
<li>
<p>方便的 MessageSource 访问（i18n）</p>
</li>
<li>
<p>ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化</p>
</li>
</ul>
<p>这是 ApplicationContext 的使用例子：</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorldApp{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ApplicationContext context=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      obj.getMessage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="8你知道-spring-容器启动阶段会干什么吗">8.你知道 Spring 容器启动阶段会干什么吗？<a href="#8你知道-spring-容器启动阶段会干什么吗" class="hash-link" aria-label="Direct link to 8.你知道 Spring 容器启动阶段会干什么吗？" title="Direct link to 8.你知道 Spring 容器启动阶段会干什么吗？">​</a></h3>
<p>PS：这道题老三面试被问到过</p>
<p>Spring 的 IOC 容器工作的过程，其实可以划分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean 实例化阶段</strong>。</p>
<p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的 Bean 定义中。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-315-8c7441a951c883fa3cd7f8c5946b23e2.png" width="755" height="368" class="img_kGBN"></p>
<p>容器启动开始，首先会通过某种途径加载 Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的 Congiguration MetaData 进行解析和分析，并将分析后的信息组为相应的 BeanDefinition。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-316-76927d3b40d1502d9d9f96fbcdfb2a83.png" width="801" height="423" class="img_kGBN"></p>
<p>最后把这些保存了 Bean 定义必要信息的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器启动就完成了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="9能说一下-spring-bean-生命周期吗">9.能说一下 Spring Bean 生命周期吗？<a href="#9能说一下-spring-bean-生命周期吗" class="hash-link" aria-label="Direct link to 9.能说一下 Spring Bean 生命周期吗？" title="Direct link to 9.能说一下 Spring Bean 生命周期吗？">​</a></h3>
<p>可以看看：<a href="https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw" target="_blank" rel="noopener noreferrer">Spring Bean 生命周期，好像人的一生。。</a></p>
<p>在 Spring 中，基本容器 BeanFactory 和扩展容器 ApplicationContext 的实例化时机不太一样，BeanFactory 采用的是延迟初始化的方式，也就是只有在第一次 getBean()的时候，才会实例化 Bean；ApplicationContext 启动之后会实例化所有的 Bean 定义。</p>
<p>Spring IOC 中 Bean 的生命周期大致分为四个阶段：<strong>实例化</strong>（Instantiation）、<strong>属性赋值</strong>（Populate）、<strong>初始化</strong>（Initialization）、<strong>销毁</strong>（Destruction）。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-317-3811da8c71bf259436fa0188ec4ebed8.png" width="1000" height="507" class="img_kGBN"></p>
<p>我们再来看一个稍微详细一些的过程：</p>
<ul>
<li><strong>实例化</strong>：第 1 步，实例化一个 Bean 对象</li>
<li><strong>属性赋值</strong>：第 2 步，为 Bean 设置相关属性和依赖</li>
<li><strong>初始化</strong>：初始化的阶段的步骤比较多，5、6 步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean 就可以被使用了</li>
<li><strong>销毁</strong>：第 8~10 步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第 9、10 步真正销毁 Bean 时再执行相应的方法</li>
</ul>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-318-c57f74afc63f438e3cad1a5aeb21c74e.png" width="1364" height="1062" class="img_kGBN"></p>
<p>简单总结一下，Bean 生命周期里初始化的过程相对步骤会多一些，比如前置、后置的处理。</p>
<p>最后通过一个实例来看一下具体的细节：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-319-b175e46a678ee0da74ad4c38c4c40d85.png" width="712" height="1824" class="img_kGBN"></p>
<ul>
<li>定义一个<code>PersonBean</code>类，实现<code>DisposableBean</code>,<code>InitializingBean</code>, <code>BeanFactoryAware</code>, <code>BeanNameAware</code>这 4 个接口，同时还有自定义的<code>init-method</code>和<code>destroy-method</code>。</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class PersonBean implements InitializingBean, BeanFactoryAware, BeanNameAware, DisposableBean {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 身份证号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Integer no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 姓名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public PersonBean() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;1.调用构造方法：我出生了！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Integer getNo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setNo(Integer no) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.no = no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setName(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;2.设置属性：我的名字叫&quot;+name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setBeanName(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学校了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void afterPropertiesSet() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;6.InitializingBean#afterPropertiesSet方法：入学登记&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;7.自定义init方法：努力上学ing&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void destroy() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void destroyMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void work(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>定义一个<code>MyBeanPostProcessor</code>实现<code>BeanPostProcessor</code>接口。</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyBeanPostProcessor implements BeanPostProcessor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;5.BeanPostProcessor.postProcessBeforeInitialization方法：到学校报名啦&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>配置文件，指定<code>init-method</code>和<code>destroy-method</code>属性</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;bean name=&quot;myBeanPostProcessor&quot; class=&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot; /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;bean name=&quot;personBean&quot; class=&quot;cn.fighter3.spring.life.PersonBean&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          init-method=&quot;init&quot; destroy-method=&quot;destroyMethod&quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;property name=&quot;idNo&quot; value= &quot;80669865&quot;/&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;property name=&quot;name&quot; value=&quot;张铁钢&quot; /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/bean&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/beans&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>测试</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PersonBean personBean = (PersonBean) context.getBean(&quot;personBean&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        personBean.work();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ((ClassPathXmlApplicationContext) context).destroy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>运行结果：</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">1.调用构造方法：我出生了！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.设置属性：我的名字叫张铁钢</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.调用BeanFactoryAware#setBeanFactory方法：选好学校了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5.BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6.InitializingBean#afterPropertiesSet方法：入学登记</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7.自定义init方法：努力上学ing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bean使用中：工作，只有对社会没有用的人才放假。。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9.DisposableBean#destroy方法：平淡的一生落幕了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10.自定义destroy方法:睡了，别想叫醒我</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>关于源码，Bean 创建过程可以查看<code>AbstractBeanFactory#doGetBean</code>方法，在这个方法里可以看到 Bean 的实例化，赋值、初始化的过程，至于最终的销毁，可以看看<code>ConfigurableApplicationContext#close()</code>。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-320-4c8b8d7c545d46e723451f0f7c6d679d.png" width="1338" height="814" class="img_kGBN"></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="10bean-定义和依赖定义有哪些方式">10.Bean 定义和依赖定义有哪些方式？<a href="#10bean-定义和依赖定义有哪些方式" class="hash-link" aria-label="Direct link to 10.Bean 定义和依赖定义有哪些方式？" title="Direct link to 10.Bean 定义和依赖定义有哪些方式？">​</a></h3>
<p>有三种方式：<strong>直接编码方式</strong>、<strong>配置文件方式</strong>、<strong>注解方式</strong>。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-321-2be974f988b263e727d2eb95c93bae3e.png" width="720" height="345" class="img_kGBN"></p>
<ul>
<li>直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</li>
<li>配置文件方式：通过 xml、propreties 类型的配置文件，配置相应的依赖关系，Spring 读取配置文件，完成依赖关系的注入。</li>
<li>注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring 会扫描注解，完成  依赖关系的注入。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="11有哪些依赖注入的方法">11.有哪些依赖注入的方法？<a href="#11有哪些依赖注入的方法" class="hash-link" aria-label="Direct link to 11.有哪些依赖注入的方法？" title="Direct link to 11.有哪些依赖注入的方法？">​</a></h3>
<p>Spring 支持<strong>构造方法注入</strong>、<strong>属性注入</strong>、<strong>工厂方法注入</strong>,其中工厂方法注入，又可以分为<strong>静态工厂方法注入</strong>和<strong>非静态工厂方法注入</strong>。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-322-2847978e36905aa32ebc4f35f132c794.png" width="1564" height="582" class="img_kGBN"></p>
<ul>
<li>
<p><strong>构造方法注入</strong></p>
<p>通过调用类的构造方法，将接口实现类通过构造方法变量传入</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> public CatDaoImpl(String message){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   this. message = message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;bean id=&quot;CatDaoImpl&quot; class=&quot;com.CatDaoImpl&quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;constructor-arg value=&quot; message &quot;&gt;&lt;/constructor-arg&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/bean&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><strong>属性注入</strong></p>
<p>通过 Setter 方法完成调用类所需依赖的注入</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> public class Id {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getId() { return id; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setId(int id) { this.id = id; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;bean id=&quot;id&quot; class=&quot;com.id &quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;property name=&quot;id&quot; value=&quot;123&quot;&gt;&lt;/property&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/bean&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><strong>工厂方法注入</strong></p>
<ul>
<li>
<p><strong>静态工厂注入</strong></p>
<p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 Spring 管理所有对象，我们不能直接通过&quot;工程类.静态方法()&quot;来获取对象，而是依然通过 Spring 注入的形式获取：</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class DaoFactory { //静态工厂</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public static final FactoryDao getStaticFactoryDaoImpl(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new StaticFacotryDaoImpl();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SpringAction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> //注入对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> private FactoryDao staticFactoryDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> //注入对象的 set 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> public void setStaticFactoryDao(FactoryDao staticFactoryDao) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     this.staticFactoryDao = staticFactoryDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;bean name=&quot;springAction&quot; class=&quot; SpringAction&quot; &gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;/bean&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;bean name=&quot;staticFactoryDao&quot; class=&quot;DaoFactory&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><strong>非静态工厂注入</strong></p>
<p>非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">//非静态工厂</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DaoFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public FactoryDao getFactoryDaoImpl(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return new FactoryDaoImpl();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SpringAction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //注入对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private FactoryDao factoryDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setFactoryDao(FactoryDao factoryDao) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.factoryDao = factoryDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;bean name=&quot;springAction&quot; class=&quot;SpringAction&quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;/bean&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;bean name=&quot;daoFactory&quot; class=&quot;com.DaoFactory&quot;&gt;&lt;/bean&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="12spring-有哪些自动装配的方式">12.Spring 有哪些自动装配的方式？<a href="#12spring-有哪些自动装配的方式" class="hash-link" aria-label="Direct link to 12.Spring 有哪些自动装配的方式？" title="Direct link to 12.Spring 有哪些自动装配的方式？">​</a></h3>
<blockquote>
<p><strong>什么是自动装配？</strong></p>
</blockquote>
<p>Spring IOC 容器知道所有 Bean 的配置信息，此外，通过 Java 反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有 Bean 的这些信息后，Spring IOC 容器就可以按照某种规则对容器中的 Bean 进行自动装配，而无须通过显式的方式进行依赖配置。</p>
<p>Spring 提供的这种方式，可以按照某些规则进行 Bean 的自动装配，<code>&lt;bean&gt;</code>元素提供了一个指定自动装配类型的属性：<code>autowire=&quot;&lt;自动装配类型&gt;&quot;</code></p>
<blockquote>
<p><strong>Spring 提供了哪几种自动装配类型？</strong></p>
</blockquote>
<p>Spring 提供了 4 种自动装配类型：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-323-7008412abbed2f69bf97d8e49261db5f.png" width="1092" height="646" class="img_kGBN"></p>
<ul>
<li><strong>byName</strong>：根据名称进行自动匹配，假设 Boss 又一个名为 car 的属性，如果容器中刚好有一个名为 car 的 bean，Spring 就会自动将其装配给 Boss 的 car 属性</li>
<li><strong>byType</strong>：根据类型进行自动匹配，假设 Boss 有一个 Car 类型的属性，如果容器中刚好有一个 Car 类型的 Bean，Spring 就会自动将其装配给 Boss 这个属性</li>
<li><strong>constructor</strong>：与 byType 类似， 只不过它是针对构造函数注入而言的。如果 Boss 有一个构造函数，构造函数包含一个 Car 类型的入参，如果容器中有一个 Car 类型的 Bean，则 Spring 将自动把这个 Bean 作为 Boss 构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的 Bean，则 Spring 将抛出异常。</li>
<li><strong>autodetect</strong>：根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 Bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="13spring-中的-bean-的作用域有哪些">13.Spring 中的 Bean 的作用域有哪些?<a href="#13spring-中的-bean-的作  用域有哪些" class="hash-link" aria-label="Direct link to 13.Spring 中的 Bean 的作用域有哪些?" title="Direct link to 13.Spring 中的 Bean 的作用域有哪些?">​</a></h3>
<p>Spring 的 Bean 主要支持五种作用域：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-324-2620bb73eae83ed58929d1526b4c3711.png" width="761" height="499" class="img_kGBN"></p>
<ul>
<li><strong>singleton</strong> : 在 Spring 容器仅存在一个 Bean 实例，Bean 以单实例的方式存在，是 Bean 默认的作用域。</li>
<li><strong>prototype</strong> : 每次从容器重调用 Bean 时，都会返回一个新的实例。</li>
</ul>
<p>以下三个作用域于只在 Web 应用中适用：</p>
<ul>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP Request 内有效。</li>
<li><strong>session</strong> : 同一个 HTTP Session 共享一个 Bean，不同的 HTTP Session 使用不同的 Bean。</li>
<li><strong>globalSession</strong>：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经不存在了。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="14spring-中的单例-bean-会存在线程安全问题吗">14.Spring 中的单例 Bean 会存在线程安全问题吗？<a href="#14spring-中的单例-bean-会存在线程安全问题吗" class="hash-link" aria-label="Direct link to 14.Spring 中的单例 Bean 会存在线程安全问题吗？" title="Direct link to 14.Spring 中的单例 Bean 会存在线程安全问题吗？">​</a></h3>
<p>首先结论在这：Spring 中的单例 Bean<strong>不是线程安全的</strong>。</p>
<p>因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行<strong>查询</strong>以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这 些 Bean 大多是无状态的，只关注于方法本身。</p>
<p>假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-325-b78cc192254f8c36c59eece7fdbc4e37.png" width="562" height="373" class="img_kGBN"></p>
<blockquote>
<p><strong>单例 Bean 线程安全问题怎么解决呢？</strong></p>
</blockquote>
<p>常见的有这么些解决办法：</p>
<ol>
<li>
<p>将 Bean 定义为多例</p>
<p>这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。</p>
</li>
<li>
<p>在 Bean 对象中尽量避免定义可变的成员变量</p>
<p>削足适履了属于是，也不能这么干。</p>
</li>
<li>
<p>将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐</p>
<p>我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式。</p>
</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="15说说循环依赖">15.说说循环依赖?<a href="#15说说循环依赖" class="hash-link" aria-label="Direct link to 15.说说循环依赖?" title="Direct link to 15.说说循环依赖?">​</a></h3>
<blockquote>
<p><strong>什么是循环依赖？</strong></p>
</blockquote>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-326-c5b90db0ce70a7a72397745853c2485a.png" width="678" height="695" class="img_kGBN"></p>
<p>Spring 循环依赖：简单说就是自己依赖自己，或者和别的 Bean 相互依赖。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-327-7025745704c31080a578f3f4c80094f2.png" width="1046" height="359" class="img_kGBN"></p>
<p>只有单例的 Bean 才存在循环依赖的情况，<strong>原型</strong>(Prototype)情况下，Spring 会直接抛出异常。原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃，直接把系统干垮。</p>
<blockquote>
<p><strong>Spring 可以解决哪些情况的循环依赖？</strong></p>
</blockquote>
<p>Spring 不支持基于构造器注入的循环依赖，但是假如 AB 循环依赖，如果一个是构造器注入，一个是 setter 注入呢？</p>
<p>看看几种情形：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-328-5c34bff56ad17a82cd06383efb33ae29.png" width="865" height="517" class="img_kGBN"></p>
<p>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p>
<p>所以简单总结，当循环依赖的实例都采用 setter 方法注入的时候，Spring 可以支持，都采用构造器注入的时候，不支持，构造器注入和 setter 注入同时存在的时候，看天。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="16那-spring-怎么解决循环依赖的呢">16.那 Spring 怎么解决循环依赖的呢？<a href="#16那-spring-怎么解决循环依赖的呢" class="hash-link" aria-label="Direct link to 16.那 Spring 怎么解决循环依赖的呢？" title="Direct link to 16.那 Spring 怎么解决循环依赖的呢？">​</a></h3>
<blockquote>
<p>PS：其实正确答案是开发人员做好设计，别让 Bean 循环依赖，但是没办法，面试官不想听这个。</p>
</blockquote>
<p>我们都知道，单例 Bean 初始化完成，要经历三步：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-329-7d33a610adca79a5103085b4baa4fefa.png" width="555" height="202" class="img_kGBN"></p>
<p>注入就发生在第二步，<strong>属性赋值</strong>，结合这个过程，Spring 通过<strong>三级缓存</strong>解决了循环依赖：</p>
<ol>
<li>一级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>singletonObjects</strong>，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例</li>
<li>二级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>earlySingletonObjects</strong>，早期曝光对象，用于保存实例化完成的 bean 实例</li>
<li>三级缓存 : <code>Map&lt;String,ObjectFactory&lt;?&gt;&gt;</code> <strong>singletonFactories</strong>，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</li>
</ol>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-330-1be2be9ac2d046b095a93808108dd203.png" width="1157" height="415" class="img_kGBN"></p>
<p>我们来看一下三级缓存解决循环依赖的过程：</p>
<p>当 A、B 两个类发生循环依赖时：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-331-b6ec8629040f7a27cb397286de34b371.png" width="435" height="227" class="img_kGBN"></p>
<p>A 实例的初始化过程：</p>
<ol>
<li>创建 A 实例，实例化的时候把 A 对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</li>
</ol>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-332-57071bfed09f9b357b485fc11d6c793b.png" width="939" height="438" class="img_kGBN"></p>
<ol start="2">
<li>
<p>A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B</p>
</li>
<li>
<p>同样，B 注⼊属性时发现依赖 A，它就会从缓存里找 A 对象。依次从⼀级到三级缓存查询 A，从三级缓存通过对象⼯⼚拿到 A，发现 A 虽然不太完善，但是存在，把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入⼀级缓存。</p>
</li>
</ol>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-334-6e821ffda0c62db825e3ab11c1e07730.png" width="877" height="421" class="img_kGBN"></p>
<ol start="4">
<li>
<p>接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</p>
</li>
<li>
<p>最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象</p>
</li>
</ol>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-333-0ba413ccea594b24c7f0da6d01d4036a.png" width="817" height="472" class="img_kGBN"></p>
<p>所以，我们就知道为什么 Spring 能解决 setter 注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="17为什么要三级缓存级不吗">17.为什么要三级缓存？⼆级不⾏吗？<a href="#17为什么要三级缓存级不吗" class="hash-link" aria-label="Direct link to 17.为什么要三级缓存？⼆级不⾏吗？" title="Direct link to 17.为什么要三级缓存？⼆级不⾏吗？">​</a></h3>
<p>不行，主要是为了<strong>⽣成代理对象</strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。</p>
<p>因为三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。</p>
<p>假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-335-1cb61108a027e1ecd9d28e5ada34c797.png" width="1009" height="129" class="img_kGBN"></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="18autowired-的实现原理">18.@Autowired 的实现原理？<a href="#18autowired-的实现原理" class="hash-link" aria-label="Direct link to 18.@Autowired 的实现原理？" title="Direct link to 18.@Autowired 的实现原理？">​</a></h3>
<p>实现@Autowired 的关键是：<strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>在 Bean 的初始化阶段，会通过 Bean 后置处理器来进行一些前置和后置的处理。</p>
<p>实现@Autowired 的功能，也是通过后置处理器来完成的。这个后置处理器就是 AutowiredAnnotationBeanPostProcessor。</p>
<ul>
<li>
<p>Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。</p>
</li>
<li>
<p>在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues()方法，在该方法中就会进行@Autowired 注解的解析，然后实现自动装配。</p>
</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 属性赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //…………</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (hasInstAwareBpps) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              if (pvs == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  pvs = mbd.getPropertyValues();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              PropertyValues pvsToUse;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  if (pvsToUse == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      if (filteredPds == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      //执行后处理器，填充属性，完成自动装配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      //调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      if (pvsToUse == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         //…………</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">  public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //@Autowired注解、@Inject和@Value注解的属性和方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //属性填充</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          metadata.inject(bean, beanName, pvs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return pvs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } catch (BeanCreationException var6) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          throw var6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } catch (Throwable var7) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, var7);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="aop">AOP<a href="#aop" class="hash-link" aria-label="Direct link to AOP" title="Direct link to AOP">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="19说说什么是-aop">19.说说什么是 AOP？<a href="#19说说什么是-aop" class="hash-link" aria-label="Direct link to 19.说说什么是 AOP？" title="Direct link to 19.说说什么是 AOP？">​</a></h3>
<p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-336-df631f34cf8e5c29fd7f8fbbf7a47083.png" width="729" height="459" class="img_kGBN"></p>
<p>具体来说，假如我现在要 crud 写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？</p>
<p>我们可以把<code>日志记录</code>和<code>数据校验</code>可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-337-e5e4785cd04fbd8a445ec8c84a1eede5.png" width="306" height="330" class="img_kGBN"></p>
<p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p>
<p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-338-accd1d12f4b8b412b99d05fd8e78a4d1.png" width="747" height="320" class="img_kGBN"></p>
<p>AOP 的核心其实就是<strong>动态代理</strong>，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p>
<blockquote>
<p><strong>AOP 有哪些核心概念？</strong></p>
</blockquote>
<ul>
<li>
<p><strong>切面</strong>（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
</li>
<li>
<p><strong>连接点</strong>（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
</li>
<li>
<p><strong>切点</strong>（Pointcut）：对连接点进行拦截的定位</p>
</li>
<li>
<p><strong>通知</strong>（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作<strong>增强</strong></p>
</li>
<li>
<p><strong>目标对象</strong> （Target）：代理的目标对象</p>
</li>
<li>
<p><strong>织入</strong>（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</p>
<ul>
<li>
<p>编译期织入：切面在目标类编译时被织入</p>
</li>
<li>
<p>类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p>
</li>
<li>
<p>运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。SpringAOP 就是以这种方式织入切面。</p>
<p>Spring 采用运行期织入，而 AspectJ 采用编译期织入和类加载器织入。</p>
</li>
</ul>
</li>
<li>
<p><strong>引介</strong>（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p>
</li>
</ul>
<blockquote>
<p><strong>AOP 有哪些环绕方式？</strong></p>
</blockquote>
<p>AOP 一般有 <strong>5 种</strong>环绕方式：</p>
<ul>
<li>前置通知 (@Before)</li>
<li>返回通知 (@AfterReturning)</li>
<li>异常通知 (@AfterThrowing)</li>
<li>后置通知 (@After)</li>
<li>环绕通知 (@Around)</li>
</ul>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-339-1ce0060fd7a28f39821332f8b1f22dbb.png" width="751" height="435" class="img_kGBN"></p>
<p>多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="20说说你平时有用到-aop-吗">20.说说你平时有用到 AOP 吗？<a href="#20说说你平时有用到-aop-吗" class="hash-link" aria-label="Direct link to 20.说说你平时有用到 AOP 吗？" title="Direct link to 20.说说你平时有用到 AOP 吗？">​</a></h3>
<p>PS：这道题老三的同事面试候选人的时候问到了，候选人说了一堆 AOP 原理，同事就势来一句，你能现场写一下 AOP 的应用吗？结果——场面一度很尴尬。虽然我对面试写这种百度就能出来的东西持保留意见，但是还是加上了这一问，毕竟招人最后都是要撸代码的。</p>
<p>这里给出一个小例子，SpringBoot 项目中，利用 AOP 打印接口的入参和出参日志，以及执行时间，还是比较快捷的。</p>
<ul>
<li>
<p>引入依赖：引入 AOP 依赖</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>自定义注解：自定义一个注解作为切点</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target({ElementType.METHOD})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface WebLog {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>配置 AOP 切面：</p>
<ul>
<li>
<p>@Aspect：标识切面</p>
</li>
<li>
<p>@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。</p>
</li>
<li>
<p>@Before：在切点之前织入，打印了一些入参信息</p>
</li>
<li>
<p>@Around：环绕切点，打印返回参数和接口执行时间</p>
</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Aspect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebLogAspect {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final static Logger logger         = LoggerFactory.getLogger(WebLogAspect.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 以自定义 @WebLog 注解为切点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     **/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void webLog() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在切点之前织入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Before(&quot;webLog()&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doBefore(JoinPoint joinPoint) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开始打印请求日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HttpServletRequest request = attributes.getRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印请求相关参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;========================================== Start ==========================================&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印请求 url</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;URL            : {}&quot;, request.getRequestURL().toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印 Http method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;HTTP Method    : {}&quot;, request.getMethod());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印调用 controller 的全路径以及执行方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Class Method   : {}.{}&quot;, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印请求的 IP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;IP             : {}&quot;, request.getRemoteAddr());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印请求入参</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Request Args   : {}&quot;,new ObjectMapper().writeValueAsString(joinPoint.getArgs()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在切点之后织入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Throwable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @After(&quot;webLog()&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doAfter() throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 结束后打个分隔线，方便查看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;=========================================== End ===========================================&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 环绕</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Around(&quot;webLog()&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //开始时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long startTime = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object result = proceedingJoinPoint.proceed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印出参</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Response Args  : {}&quot;, new ObjectMapper().writeValueAsString(result));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行耗时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;Time-Consuming : {} ms&quot;, System.currentTimeMillis() - startTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>使用：只需要在接口上加上自定义注解</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @GetMapping(&quot;/hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @WebLog(desc = &quot;这是一个欢迎接口&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String hello(String name){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;Hello &quot;+name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<ul>
<li>执行结果：可以看到日志打印了入参、出参和执行时间</li>
</ul>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-340-ced36c5b0c014a60b3d8d7a15bb1c803.png" width="1749" height="248" class="img_kGBN"></p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="21说说-jdk-动态代理和-cglib-代理-">21.说说 JDK 动态代理和 CGLIB 代理 ？<a href="#21说说-jdk-动态代理和-cglib-代理-" class="hash-link" aria-label="Direct link to 21.说说 JDK 动态代理和 CGLIB 代理 ？" title="Direct link to 21.说说 JDK 动态代理和 CGLIB 代理 ？">​</a></h3>
<p>Spring 的 AOP 是通过<a href="https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg" target="_blank" rel="noopener noreferrer">动态代理</a>来实现的，动态代理主要有两种方式 JDK 动态代理和 Cglib 动态代理，这两种动态代理的使用和原理有些不同。</p>
<p><strong>JDK 动态代理</strong></p>
<ol>
<li><strong>Interface</strong>：对于 JDK 动态代理，目标类需要实现一个 Interface。</li>
<li><strong>InvocationHandler</strong>：InvocationHandler 是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。</li>
<li><strong>Proxy</strong>：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</li>
</ol>
<p><strong>CgLib 动态代理</strong></p>
<ol>
<li>使用 JDK 创建代理有一大限制，它只能为接口创建代理实例，而 CgLib 动态代理就没有这个限制。</li>
<li>CgLib 动态代理是使用字节码处理框架 <strong>ASM</strong>，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</li>
<li><strong>CgLib</strong> 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</li>
</ol>
<p>我们来看一个常见的小场景，客服中转，解决用户问题：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-341-110a4282852473e7263076870a852e0a.png" width="1550" height="858" class="img_kGBN"></p>
<p><strong>JDK 动态代理实现：</strong></p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-342-4f2a99bc3fabe662ba3adfcb4086f599.png" width="1126" height="604" class="img_kGBN"></p>
<ul>
<li>
<p>接口</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ISolver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void solve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>目标类:需要实现对应接口</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Solver implements ISolver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void solve() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;疯狂掉头发解决问题……&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>态代理工厂<!-- -->:ProxyFactory<!-- -->，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写 InvocationHandler 方法，实现接口重写也差不多</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class ProxyFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 维护一个目标对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ProxyFactory(Object target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.target = target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为目标对象生成代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getProxyInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvocationHandler() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;请问有什么可以帮到您？&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 调用目标对象方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Object returnValue = method.invoke(target, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;问题已经解决啦！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //目标对象:程序员</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ISolver developer = new Solver();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //代理：客服小姐姐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ISolver csProxy = (ISolver) new ProxyFactory(developer).getProxyInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //目标方法：解决问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        csProxy.solve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<p><strong>Cglib 动态代理实现：</strong></p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-343-5d58e7d2605ddd75cee9bd6ca2c905c0.png" width="1128" height="522" class="img_kGBN"></p>
<ul>
<li>
<p>目标类：Solver，这里目标类不用再实现接口。</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Solver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void solve() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;疯狂掉头发解决问题……&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>动态代理工厂：</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class ProxyFactory implements MethodInterceptor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   //维护一个目标对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ProxyFactory(Object target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.target = target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //为目标对象生成代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getProxyInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //工具类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Enhancer en = new Enhancer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //设置父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        en.setSuperclass(target.getClass());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //设置回调函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        en.setCallback(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建子类对象代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return en.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;请问有什么可以帮到您？&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行目标对象的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object returnValue = method.invoke(target, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;问题已经解决啦！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>客户端：Client</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //目标对象:程序员</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Solver developer = new Solver();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //代理：客服小姐姐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Solver csProxy = (Solver) new ProxyFactory(developer).getProxyInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //目标方法：解决问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        csProxy.solve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="22说说-spring-aop-和-aspectj-aop-区别">22.说说 Spring AOP 和 AspectJ AOP 区别?<a href="#22说说-spring-aop-和-aspectj-aop-区别" class="hash-link" aria-label="Direct link to 22.说说 Spring AOP 和 AspectJ AOP 区别?" title="Direct link to 22.说说 Spring AOP 和 AspectJ AOP 区别?">​</a></h3>
<p><strong>Spring AOP</strong></p>
<p>Spring AOP 属于<code>运行时增强</code>，主要具有如下特点：</p>
<ol>
<li>
<p>基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</p>
</li>
<li>
<p>Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</p>
</li>
<li>
<p>在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</p>
</li>
<li>
<p>Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p>
</li>
</ol>
<p><strong>AspectJ</strong></p>
<p>AspectJ 是一个易用的功能强大的 AOP 框架，属于<code>编译时增强</code>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p>
<p>AspectJ 属于<strong>静态织入</strong>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p>
<ol>
<li>
<p>编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p>
</li>
<li>
<p>编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p>
</li>
<li>
<p>类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p>
</li>
</ol>
<p>整体对比如下：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-344-caadaf22620ef704d0401198d4b10589.png" width="930" height="565" class="img_kGBN"></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="事务">事务<a href="#事务" class="hash-link" aria-label="Direct link to 事务" title="Direct link to 事务">​</a></h2>
<p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="23spring-事务的种类">23.Spring 事务的种类？<a href="#23spring-事务的种类" class="hash-link" aria-label="Direct link to 23.Spring 事务的种类？" title="Direct link to 23.Spring 事务的种类？">​</a></h3>
<p>Spring 支持<code>编程式事务</code>管理和<code>声明式</code>事务管理两种方式：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-345-895430493e16f12aa3e97f57979760f9.png" width="567" height="229" class="img_kGBN"></p>
<ol>
<li>编程式事务</li>
</ol>
<p>编程式事务管理使用 TransactionTemplate，需要显式执行事务。</p>
<ol start="2">
<li>
<p>声明式事务</p>
</li>
<li>
<p>声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</p>
</li>
<li>
<p>优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="24spring-的事务隔离级别">24.Spring 的事务隔离级别？<a href="#24spring-的事务隔离级别" class="hash-link" aria-label="Direct link to 24.Spring 的事务隔离级别？" title="Direct link to 24.Spring 的事务隔离级别？">​</a></h3>
<p>Spring 的接口 TransactionDefinition 中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</p>
<ol>
<li>ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</li>
<li>ISOLATION_READ_UNCOMMITTED：读未提交</li>
<li>ISOLATION_READ_COMMITTED：读已提交</li>
<li>ISOLATION_REPEATABLE_READ：可重复读</li>
<li>ISOLATION_SERIALIZABLE：串行化</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="25spring-的事务传播机制">25.Spring 的事务传播机制？<a href="#25spring-的事务传播机制" class="hash-link" aria-label="Direct link to 25.Spring 的事务传播机制？" title="Direct link to 25.Spring 的事务传播机制？">​</a></h3>
<p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p>
<p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-346-e75be4dc1d2d21caf9cf957f896dc7ec.png" width="1568" height="908" class="img_kGBN"></p>
<p>Spring 默认的事务传播行为是 PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个 ServiceX#methodX()都工作在事务环境下（均被 Spring 事务增强），且程序中存在调用链 <code>Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()</code>，那么这 3 个服务类的三个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="26声明式事务实现原理了解吗">26.声明式事务实现原理了解吗？<a href="#26声明式事务实现原理了解吗" class="hash-link" aria-label="Direct link to 26.声明式事务实现原理了解吗？" title="Direct link to 26.声明式事务实现原理了解吗？">​</a></h3>
<p>就是通过 AOP/动态代理。</p>
<ul>
<li>
<p><strong>在 Bean 初始化阶段创建代理对象</strong>：Spring 容器在初始化每个单例 bean 的时候，会遍历容器中的所有 BeanPostProcessor 实现类，并执行其 postProcessAfterInitialization 方法，在执行 AbstractAutoProxyCreator 类的 postProcessAfterInitialization 方法时会遍历容器中所有的切面，查找与当前实例化 bean 匹配的切面，这里会获取事务属性切面，查找@Transactional 注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用 JDK 动态代理创建代理，如果目标类是接口，则使用 JDK 动态代理，否则使用 Cglib。</p>
</li>
<li>
<p><strong>在执行目标方法时进行事务增强操作</strong>：当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p>
</li>
</ul>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-347-44b9355a1a46cb2e2bd33d9791c7e801.png" width="720" height="283" class="img_kGBN"></p>
<p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，包括开启事务、事务提交、异常回滚。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="27声明式事务在哪些情况下会失效">27.声明式事务在哪些情况下会失效？<a href="#27声明式事务在哪些情况下会失效" class="hash-link" aria-label="Direct link to 27.声明式事务在哪些情况下会失效？" title="Direct link to 27.声明式事 务在哪些情况下会失效？">​</a></h3>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-348-2f6fed56da43fcdd2e7259fef0cc4e4b.png" width="769" height="362" class="img_kGBN"></p>
<p><strong>1、@Transactional 应用在非 public 修饰的方法上</strong></p>
<p>如果 Transactional 注解应用在非 public 修饰的方法上，Transactional 将会失效。</p>
<p>是因为在 Spring AOP 代理时，TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法 或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource 的 <strong>computeTransactionAttribute</strong>方法，获取 Transactional 注解的事务配置信息。</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">protected TransactionAttribute computeTransactionAttribute(Method method,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; targetClass) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Don&#x27;t allow no-public methods as required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此方法会检查目标方法的修饰符是否为 public，不是 public 则不会获取@Transactional 的属性配置信息。</p>
<p><strong>2、@Transactional 注解属性 propagation 设置错误</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>3、@Transactional 注解属性 rollbackFor 设置错误</strong></p>
<p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring 默认抛出了未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常不会触发回滚事务。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-349-6eacb26dde1c40127dfcfd3c80de0ab3.png" width="1251" height="696" class="img_kGBN"></p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">// 希望自定义的异常可以进行回滚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p>
<p><strong>4、同一个类中方法调用，导致@Transactional 失效</strong></p>
<p>开发中避免不了会对同一个类里面的方法调用，比如有一个类 Test，它的一个方法 A，A 再调用本类的方法 B（不论方法 B 是用 public 还是 private 修饰），但方法 A 没有声明注解事务，而 B 方法有。则外部调用方法 A 之后，方法 B 的事务是不会起作用的。这也是经常犯错误的一个地方。</p>
<p>那为啥会出现这种情况？其实这还是由于使用 Spring AOP 代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由 Spring 生成的代理对象来管理。</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain"> //@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @GetMapping(&quot;/test&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     private Integer A() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         CityInfoDict cityInfoDict = new CityInfoDict();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         cityInfoDict.setCityName(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          * B 插入字段为 3的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         this.insertB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * A 插入字段为 2的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int insert = cityInfoDictMapper.insert(cityInfoDict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return insert;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Integer insertB() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CityInfoDict cityInfoDict = new CityInfoDict();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cityInfoDict.setCityName(&quot;3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cityInfoDict.setParentCityId(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return cityInfoDictMapper.insert(cityInfoDict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这种情况是最常见的一种@Transactional 注解失效场景</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Integer A() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int insert = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CityInfoDict cityInfoDict = new CityInfoDict();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cityInfoDict.setCityName(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cityInfoDict.setParentCityId(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * A 插入字段为 2的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * B 插入字段为 3的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b.insertB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果 B 方法内部抛了异常，而 A 方法此时 try catch 了 B 方法的异常，那这个事务就不能正常回滚了，会抛出异常：</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="mvc">MVC<a href="#mvc" class="hash-link" aria-label="Direct link to MVC" title="Direct link to MVC">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="28spring-mvc-的核心组件">28.Spring MVC 的核心组件？<a href="#28spring-mvc-的核心组件" class="hash-link" aria-label="Direct link to 28.Spring MVC 的核心组件？" title="Direct link to 28.Spring MVC 的核心组件？">​</a></h3>
<ol>
<li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li>
<li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li>
<li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li>
<li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li>
<li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>
<li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>
<li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>
<li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="29spring-mvc-的工作流程">29.Spring MVC 的工作流程？<a href="#29spring-mvc-的工作流程" class="hash-link" aria-label="Direct link to 29.Spring MVC 的工作流程？" title="Direct link to 29.Spring MVC 的工作流程？">​</a></h3>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-350-d6832631293199de8216366877ac1bad.png" width="1100" height="589" class="img_kGBN"></p>
<ol>
<li>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet(也叫中央控制器)。</li>
<li>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理（并未调用 Controller，只是得知）</li>
<li>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</li>
<li>HandlerAdapter 处理器适配器去执行 Controller 并得到 ModelAndView(数据和视图)，并层层返回给 DispatcherServlet</li>
<li>DispatcherServlet 将 ModelAndView 交给 ViewReslover 视图解析器解析，然后返回真正的视图。</li>
<li>DispatcherServlet 将模型数据填充到视图中</li>
<li>DispatcherServlet 将结果响应给客户端</li>
</ol>
<p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 <strong>Handler（Controller）</strong> 、<strong>View</strong> 、<strong>Model</strong>。</p>
<p>当然我们现在大部分的开发都是前后端分离，Restful 风格接口，后端只需要返回 Json 数据就行了。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="30springmvc-restful-风格的接口的流程是什么样的呢">30.SpringMVC Restful 风格  的接口的流程是什么样的呢？<a href="#30springmvc-restful-风格的接口的流程是什么样的呢" class="hash-link" aria-label="Direct link to 30.SpringMVC Restful 风格的接口的流程是什么样的呢？" title="Direct link to 30.SpringMVC Restful 风格的接口的流程是什么样的呢？">​</a></h3>
<p>PS:这是一道全新的八股，毕竟 ModelAndView 这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。</p>
<p>我们都知道 Restful 接口，响应格式是 json，这就用到了一个常用注解：<strong>@ResponseBody</strong></p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    @GetMapping(&quot;/user&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ResponseBody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public User user(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new User(1,&quot;张三&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>加入了这个注解后，整体的流程上和使用 ModelAndView 大体上相同，但是细节上有一些不同：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-351-120c72f2dd37dadb0fca567cee0d4869.png" width="3990" height="1671" class="img_kGBN"></p>
<ol>
<li>
<p>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet</p>
</li>
<li>
<p>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理</p>
</li>
<li>
<p>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</p>
</li>
<li>
<p>Controller 被封装成了 ServletInvocableHandlerMethod，HandlerAdapter 处理器适配器去执行 invokeAndHandle 方法，完成对 Controller 的请求处理</p>
</li>
<li>
<p>HandlerAdapter 执行完对 Controller 的请求，会调用 HandlerMethodReturnValueHandler 去处理返回值，主要的过程：</p>
<p>5.1. 调用 RequestResponseBodyMethodProcessor，创建 ServletServerHttpResponse（Spring 对原生 ServerHttpResponse 的封装）实例</p>
<p>5.2.使用 HttpMessageConverter 的 write 方法，将返回值写入 ServletServerHttpResponse 的 OutputStream 输出流中</p>
<p>5.3.在写入的过程中，会使用 JsonGenerator（默认使用 Jackson 框架）对返回值进行 Json 序列化</p>
</li>
<li>
<p>执行完请求后，返回的 ModealAndView 为 null，ServletServerHttpResponse 里也已经写入了响应，所以不用关心 View 的处理</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="spring-boot">Spring Boot<a href="#spring-boot" class="hash-link" aria-label="Direct link to Spring Boot" title="Direct link to Spring Boot">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="31介绍一下-springboot有哪些优点">31.介绍一下 SpringBoot，有哪些优  点？<a href="#31介绍一下-springboot有哪些优点" class="hash-link" aria-label="Direct link to 31.介绍一下 SpringBoot，有哪些优点？" title="Direct link to 31.介绍一下 SpringBoot，有哪些优点？">​</a></h3>
<p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-352-15e59575197c87376c9531bc9bb95ccf.png" width="280" height="259" class="img_kGBN"></p>
<p>Spring Boot 以<code>约定大于配置</code>核心思想开展工作，相比 Spring 具有如下优势：</p>
<ol>
<li>Spring Boot 可以快速创建独立的 Spring 应用程序。</li>
<li>Spring Boot 内嵌了如 Tomcat，Jetty 和 Undertow 这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</li>
<li>Spring Boot 无需再像 Spring 一样使用一堆繁琐的 xml 文件配置。</li>
<li>Spring Boot 可以自动配置(核心)Spring。SpringBoot 将原有的 XML 配置改为 Java 配置，将 bean 注入改为使用注解注入的方式(@Autowire)，并将多个 xml、properties 配置浓缩在一个 appliaction.yml 配置文件中。</li>
<li>Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。</li>
<li>Spring Boot 可以快速整合常用依赖（开发库，例如 spring-webmvc、jackson-json、validation-api 和 tomcat 等），提供的 POM 可以简化 Maven 的配置。当我们引入核心依赖时，SpringBoot 会自引入其他依赖。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="32springboot-自动配置原理了解吗">32.SpringBoot 自动配置原理了解吗？<a href="#32springboot-自动配置原理了解吗" class="hash-link" aria-label="Direct link to 32.SpringBoot 自动配置原理了解吗？" title="Direct link to 32.SpringBoot 自动配置原理了解吗？">​</a></h3>
<p>SpringBoot 开启自动配置的注解是<code>@EnableAutoConfiguration</code> ，启动类上的注解<code>@SpringBootApplication</code>是一个复合注解，包含了@EnableAutoConfiguration：</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-353-76de2542f7ff1276afdac2ba69da5609.png" width="1175" height="395" class="img_kGBN"></p>
<ul>
<li>
<p><code>EnableAutoConfiguration</code> 只是一个简单的注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@AutoConfigurationPackage //将main同级的包下的所有组件注册到容器中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Import({AutoConfigurationImportSelector.class}) //加载自动装配类 xxxAutoconfiguration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface EnableAutoConfiguration {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt;[] exclude() default {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String[] excludeName() default {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p><code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，这个接口的作用就是收集需要导入的配置类，配合<code>@Import(）</code>就可以将相应的类导入到 Spring 容器中</p>
</li>
<li>
<p>获取注入类的方法是 selectImports()，它实际调用的是<code>getAutoConfigurationEntry</code>，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p>
<ol>
<li>获取注解的属性，用于后面的排除</li>
<li><strong>获取所有需要自动装配的配置类的路径</strong>：这一步是最关键的，从 META-INF/spring.factories 获取自动配置类的路径</li>
<li>去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</li>
</ol>
</li>
</ul>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!this.isEnabled(annotationMetadata)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return EMPTY_ENTRY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //1.获取到注解的属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //3.1.移除重复的配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            configurations = this.removeDuplicates(configurations);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //3.2.处理需要排除的配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.checkExcludedClasses(configurations, exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            configurations.removeAll(exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            configurations = this.getConfigurationClassFilter().filter(configurations);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="33如何自定义一个-springboot-srarter">33.如何自定义一个 SpringBoot Srarter?<a href="#33如何自定义一个-springboot-srarter" class="hash-link" aria-label="Direct link to 33.如何自定义一个 SpringBoot Srarter?" title="Direct link to 33.如何自定义一个 SpringBoot Srarter?">​</a></h3>
<p>知道了自动配置原理，创建一个自定义 SpringBoot Starter 也很简单。</p>
<ol>
<li>创建一个项目，命名为 demo-spring-boot-starter，引入 SpringBoot 相关依赖</li>
</ol>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;optional&gt;true&lt;/optional&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ol start="2">
<li>
<p>编写配置文件</p>
<p>这里定义了属性配置的前缀</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@ConfigurationProperties(prefix = &quot;hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloProperties {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略getter、setter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>自 动装配</p>
<p>创建自动配置类 HelloPropertiesConfigure</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@EnableConfigurationProperties(HelloProperties.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloPropertiesConfigure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>配置自动类</p>
<p>在<code>/resources/META-INF/spring.factories</code>文件中添加自动配置类路径</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cn.fighter3.demo.starter.configure.HelloPropertiesConfigure</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>测试</p>
<ul>
<li>
<p>创建一个工程，引入自定义 starter 依赖</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;groupId&gt;cn.fighter3&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;artifactId&gt;demo-spring-boot-starter&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/dependency&gt;</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>在配置文件里添加配置</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">hello.name=张三</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
<li>
<p>测试类</p>
<div class="language-java codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-java codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">@RunWith(SpringRunner.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SpringBootTest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HelloProperties helloProperties;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void hello(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;你好，&quot;+helloProperties.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
</li>
</ol>
<ul>
<li>运行结果</li>
</ul>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-354-dee2e2c6ede9c4e6d7808f8e3df3df4f.png" width="410" height="151" class="img_kGBN"></p>
<p>至此，随手写的一个自定义 SpringBoot-Starter 就完成了，虽然比较简单，但是完成了主要的自动装配的能力。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="34springboot-启动原理">34.Springboot 启动原理？<a href="#34springboot-启动原理" class="hash-link" aria-label="Direct link to 34.Springboot 启动原理？" title="Direct link to 34.Springboot 启动原理？">​</a></h3>
<p>SpringApplication 这个类主要做了以下四件事情：</p>
<ol>
<li>推断应用的类型是普通的项目还是 Web 项目</li>
<li>查找并加载所有可用初始化器 ， 设置到 initializers 属性中</li>
<li>找出所有的应用程序监听器，设置到 listeners 属性中</li>
<li>推断并设置 main 方法的定义类，找到运行的主类</li>
</ol>
<p>SpringBoot 启动大致流程如下 ：
(assets/image-355.png)</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="spring-cloud">Spring Cloud<a href="#spring-cloud" class="hash-link" aria-label="Direct link to Spring Cloud" title="Direct link to Spring Cloud">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="35对-springcloud-了解多少">35.对 SpringCloud 了解多少？<a href="#35对-springcloud-了解多少" class="hash-link" aria-label="Direct link to 35.对 SpringCloud 了解多少？" title="Direct link to 35.对 SpringCloud 了解多少？">​</a></h3>
<p>SpringCloud 是 Spring 官方推出的微服务治理框架。</p>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-356-e3601097079e38931fca3fc799333de0.png" width="1080" height="594" class="img_kGBN"></p>
<blockquote>
<p><strong>什么是微服务？</strong></p>
</blockquote>
<ol>
<li>2014 年 <strong>Martin Fowler</strong> 提出的一种新的架构形式。微服务架构是一种<strong>架构模式</strong>，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如 HTTP 或 Dubbo)互相协作，每个服务都围绕着具体的业务  进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如 Maven)对其进行构建。</li>
<li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li>
</ol>
<blockquote>
<p><strong>微服务架构主要要解决哪些问题？</strong></p>
</blockquote>
<ol>
<li>服务很多，客户端怎么访问，如何提供对外网关?</li>
<li>这么多服务，服务之间如何通信? HTTP 还是 RPC?</li>
<li>这么多服务，如何治理? 服务的注册和发现。</li>
<li>服务挂了怎么办？熔断机制。</li>
</ol>
<blockquote>
<p><strong>有哪些主流微服务框架？</strong></p>
</blockquote>
<ol>
<li>Spring Cloud Netflix</li>
<li>Spring Cloud Alibaba</li>
<li>SpringBoot + Dubbo + ZooKeeper</li>
</ol>
<blockquote>
<p><strong>SpringCloud 有哪些核心组件？</strong></p>
</blockquote>
<p><img loading="lazy" alt="Alt text" src="/code-note-blog/assets/images/image-357-751eb8acae18951c6880350065363c50.png" width="2776" height="3368" class="img_kGBN"></p>
<p>PS:微服务后面有机会再扩展，其实面试一般都是结合项目去问。</p>
<hr>
<p><em>没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟</em>。</p>
<p><strong>系列内容</strong>：</p>
<hr>
<p><em>没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟</em>。</p>
<p><strong>系列内容</strong>：</p>
<ul>
<li><a href="/code-note-blog/docs/mianshi/javase">面渣逆袭 Java SE 篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/javathread">面渣逆袭 Java 集合框架篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/collection">面渣逆袭 Java 并发编程篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/jvm">面渣逆袭 JVM 篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/spring">面渣逆袭 Spring 篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/redis">面渣逆袭 Redis 篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/mybatis">面渣逆袭 MyBatis 篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/mysql">面渣逆袭 MySQL 篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/os">面渣逆袭操作系统篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/network">面渣逆袭计算机网络篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/rocketmq">面渣逆袭RocketMQ篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/fenbushi">面渣逆袭分布式篇👍</a></li>
<li><a href="/code-note-blog/docs/mianshi/weifuwu">面渣逆袭微服务篇👍</a></li>
</ul>
<hr>
<blockquote>
<p>图文详解 35 道Spring面试高频题，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳<a href="https://mp.weixin.qq.com/s/EQge6DmgIqYITM3mAxkatg" target="_blank" rel="noopener noreferrer">转载链接</a>，作者：三分恶，戳<a href="https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ" target="_blank" rel="noopener noreferrer">原文链接</a>。</p>
</blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/mianshi/spring.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/mianshi/rocketmq"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">RocketMQ</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/mianshi/weifuwu"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">微服务</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础" class="table-of-contents__link toc-highlight">基础</a><ul><li><a href="#1spring-是什么特性有哪些模块" class="table-of-contents__link toc-highlight">1.Spring 是什么？特性？有哪些模块？</a></li><li><a href="#2spring-有哪些模块呢" class="table-of-contents__link toc-highlight">2.Spring 有哪些模块呢？</a></li><li><a href="#3spring-有哪些常用注解呢" class="table-of-contents__link toc-highlight">3.Spring 有哪些常用注解呢？</a></li><li><a href="#4spring-中应用了哪些设计模式呢" class="table-of-contents__link toc-highlight">4.Spring 中应用了哪些设计模式呢？</a></li></ul></li><li><a href="#ioc" class="table-of-contents__link toc-highlight">IOC</a><ul><li><a href="#5说一说什么是-ioc什么是-di" class="table-of-contents__link toc-highlight">5.说一说什么是 IOC？什么是 DI?</a></li><li><a href="#6能简单说一下-spring-ioc-的实现机制吗" class="table-of-contents__link toc-highlight">6.能简单说一下 Spring IOC 的实现机制吗？</a></li><li><a href="#7说说-beanfactory-和-applicantcontext" class="table-of-contents__link toc-highlight">7.说说 BeanFactory 和 ApplicantContext?</a></li><li><a href="#8你知道-spring-容器  启动阶段会干什么吗" class="table-of-contents__link toc-highlight">8.你知道 Spring 容器启动阶段会干什么吗？</a></li><li><a href="#9能说一下-spring-bean-生命周期吗" class="table-of-contents__link toc-highlight">9.能说一下 Spring Bean 生命周期吗？</a></li><li><a href="#10bean-定义和依赖定义有哪些方式" class="table-of-contents__link toc-highlight">10.Bean 定义和依赖定义有哪些方式？</a></li><li><a href="#11有哪些依赖注入的方法" class="table-of-contents__link toc-highlight">11.有哪些依赖注入的方法？</a></li><li><a href="#12spring-有哪些自动装配的方式" class="table-of-contents__link toc-highlight">12.Spring 有哪些自动装配的方式？</a></li><li><a href="#13spring-中的-bean-的作用域有哪些" class="table-of-contents__link toc-highlight">13.Spring 中的 Bean 的作用域有哪些?</a></li><li><a href="#14spring-中的单例-bean-会存在线程安全问题吗" class="table-of-contents__link toc-highlight">14.Spring 中的单例 Bean 会存在线程安全问题吗？</a></li><li><a href="#15说说循环依赖" class="table-of-contents__link toc-highlight">15.说说循环依赖?</a></li><li><a href="#16那-spring-怎么解决循环依赖的呢" class="table-of-contents__link toc-highlight">16.那 Spring 怎么解决循环依赖的呢？</a></li><li><a href="#17为什么要三级缓存级不吗" class="table-of-contents__link toc-highlight">17.为什么要三级缓存？⼆级不⾏吗？</a></li><li><a href="#18autowired-的实现原理" class="table-of-contents__link toc-highlight">18.@Autowired 的实现原理？</a></li></ul></li><li><a href="#aop" class="table-of-contents__link toc-highlight">AOP</a><ul><li><a href="#19说说什么是-aop" class="table-of-contents__link toc-highlight">19.说说什么是 AOP？</a></li><li><a href="#20说说你平时有用到-aop-吗" class="table-of-contents__link toc-highlight">20.说说你平时有用到 AOP 吗？</a></li><li><a href="#21说说-jdk-动态代理和-cglib-代理-" class="table-of-contents__link toc-highlight">21.说说 JDK 动态代理和 CGLIB 代理 ？</a></li><li><a href="#22说说-spring-aop-和-aspectj-aop-区别" class="table-of-contents__link toc-highlight">22.说说 Spring AOP 和 AspectJ AOP 区别?</a></li></ul></li><li><a href="#事务" class="table-of-contents__link toc-highlight">事务</a><ul><li><a href="#23spring-事务的种类" class="table-of-contents__link toc-highlight">23.Spring 事务的种类？</a></li><li><a href="#24spring-的事务隔离级别" class="table-of-contents__link toc-highlight">24.Spring 的事务隔离级别？</a></li><li><a href="#25spring-的事务传播机制" class="table-of-contents__link toc-highlight">25.Spring 的事务传播机制？</a></li><li><a href="#26声明式事务实现原理了解吗" class="table-of-contents__link toc-highlight">26.声明式事务实现原理了解吗？</a></li><li><a href="#27声明式事务在哪些情况下会失效" class="table-of-contents__link toc-highlight">27.声明式事务在哪些情况下会失效？</a></li></ul></li><li><a href="#mvc" class="table-of-contents__link toc-highlight">MVC</a><ul><li><a href="#28spring-mvc-的核心组件" class="table-of-contents__link toc-highlight">28.Spring MVC 的核心组件？</a></li><li><a href="#29spring-mvc-的工作流程" class="table-of-contents__link toc-highlight">29.Spring MVC 的工作流程？</a></li><li><a href="#30springmvc-restful-风格的接口的流程是什么样的呢" class="table-of-contents__link toc-highlight">30.SpringMVC Restful 风格的接口的流程是什么样的呢？</a></li></ul></li><li><a href="#spring-boot" class="table-of-contents__link toc-highlight">Spring Boot</a><ul><li><a href="#31介绍一下-springboot有哪些优点" class="table-of-contents__link toc-highlight">31.介绍一下 SpringBoot，有哪些优点？</a></li><li><a href="#32springboot-自动配置原理了解吗" class="table-of-contents__link toc-highlight">32.SpringBoot 自动配置原理了解吗？</a></li><li><a href="#33如 何自定义一个-springboot-srarter" class="table-of-contents__link toc-highlight">33.如何自定义一个 SpringBoot Srarter?</a></li><li><a href="#34springboot-启动原理" class="table-of-contents__link toc-highlight">34.Springboot 启动原理？</a></li></ul></li><li><a href="#spring-cloud" class="table-of-contents__link toc-highlight">Spring Cloud</a><ul><li><a href="#35对-springcloud-了解多少" class="table-of-contents__link toc-highlight">35.对 SpringCloud 了解多少？</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
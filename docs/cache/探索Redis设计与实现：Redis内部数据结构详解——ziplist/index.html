<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">探索Redis设计与实现：Redis内部数据结构详解——ziplist | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="探索Redis设计与实现：Redis内部数据结构详解——ziplist | Tommy"><meta data-rh="true" name="description" content="本文转自互联网"><meta data-rh="true" property="og:description" content="本文转自互联网"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">探索Redis设计与实现：连接底层与表面的数据结构robj</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：浅析Redis主从复制">探索Redis设计与实现：浅析Redis主从复制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：使用快照和AOF将Redis数据持久化到硬盘中">探索Redis设计与实现：使用快照和AOF将Redis数据持久化到硬盘中</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：数据库redisDb与键过期删除策略">探索Redis设计与实现：数据库redisDb与键过期删除策略</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis 的基础数据结构概览">探索Redis设计与实现：Redis 的基础数据结构概览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis的事件驱动模型与命令执行过程">探索Redis设计与实现：Redis的事件驱动模型与命令执行过程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis分布式锁进化史">探索Redis设计与实现：Redis分布式锁进化史</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例">探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict">探索Redis设计与实现：Redis内部数据结构详解——dict</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——intset">探索Redis设计与实现：Redis内部数据结构详解——intset</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——quicklist">探索Redis设计与实现：Redis内部数据结构详解——quicklist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——sds">探索Redis设计与实现：Redis内部数据结构详解——sds</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——skiplist">探索Redis设计与实现：Redis内部数据结构详解——skiplist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist">探索Redis设计与实现：Redis内部数据结构详解——ziplist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis事务浅析与ACID特性介绍">探索Redis设计与实现：Redis事务浅析与ACID特性介绍</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现开篇：什么是Redis">探索Redis设计与实现开篇：什么是Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/Redis原理与实践总结">Redis原理与实践总结</a></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">探索Redis设计与实现：Redis内部数据结构详解——ziplist</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>探索Redis设计与实现：Redis内部数据结构详解——ziplist</h1></header><p>本文转自互联网</p>
<p>本文将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何从入门到进阶，Redis基本的使用方法，Redis的基本数据结构，以及一些进阶的使用方法 ，同时也需要进一步了解Redis的底层数据结构，再接着，还会带来Redis主从复制、集群、分布式锁等方面的相关内容，以及作为缓存的一些使用方法和注意事项，以便让你更完整地了解整个Redis相关的技术体系，形成自己的知识框架。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<p>本文是《<a href="http://zhangtielei.com/posts/blog-redis-dict.html" target="_blank" rel="noopener noreferrer">Redis内部数据结构详解</a>》系列的第四篇。在本文中，我们首先介绍一个新的Redis内部数据结构——ziplist，然后在文章后半部分我们会讨论一下在robj, dict和ziplist的基础上，Redis对外暴露的hash结构是怎样构建起来的。</p>
<p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">hash-max-ziplist-entries 512  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hash-max-ziplist-value 64  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>本文的后半部分会对这两个配置做详细的解释。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="什么是ziplist">什么是ziplist<a href="#什么是ziplist" class="hash-link" aria-label="Direct link to 什么是ziplist" title="Direct link to 什么是ziplist">​</a></h2>
<p>Redis官方对于ziplist的定义是（出自ziplist.c的文件头部注释）：</p>
<blockquote>
<p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time.</p>
</blockquote>
<p>翻译一下就是说：ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供<code>push</code>和<code>pop</code>操作。</p>
<p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p>
<p>另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存  储。我们接下来很快就会讨论到这些实现细节。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="ziplist的数据结构定义">ziplist的数据结构定义<a href="#ziplist的数据结构定义" class="hash-link" aria-label="Direct link to ziplist的数据结构定义" title="Direct link to ziplist的数据结构定义">​</a></h2>
<p>ziplist的数据结构组成是本文要讨论的重点。实际上，ziplist还是稍微有点复杂的，它复杂的地方就在于它的数据结构定义。一旦理解了数据结构，它的一些操作也就比较容易理解了。</p>
<p>我们接下来先从总体上介绍一下ziplist的数据结构定义，然后举一个实际的例子，通过例子来解释ziplist的构成。如果你看懂了这一部分，本文的任务就算完成了一大半了。</p>
<p>从宏观上看，ziplist的内存结构如下：</p>
<p><code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</code></p>
<p>各个部分在内存上是前后相邻的，它们分别的含义如下：</p>
<ul>
<li><code>&lt;zlbytes&gt;</code>: 32bit，表示ziplist占用的字节总数（也包括<code>&lt;zlbytes&gt;</code>本身占用的4个字节）。</li>
<li><code>&lt;zltail&gt;</code>: 32bit，表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。<code>&lt;zltail&gt;</code>的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</li>
<li><code>&lt;zllen&gt;</code>: 16bit， 表示ziplist中数据项（entry）的个数。zllen字段因为只有16bit，所以可以表达的最大值为2^16-1。这里需要特别注意的是，如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以来表示。那怎么表示呢？这里做了这样的规定：如果<code>&lt;zllen&gt;</code>小于等于2^16-2（也就是不等于2^16-1），那么<code>&lt;zllen&gt;</code>就表示ziplist中数据项的个数；  否则，也就是<code>&lt;zllen&gt;</code>等于16bit全为1的情况，那么<code>&lt;zllen&gt;</code>就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</li>
<li><code>&lt;entry&gt;</code>: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。</li>
<li><code>&lt;zlend&gt;</code>: ziplist最后1个字节，是一个结束标记，值固定等于255。</li>
</ul>
<p>上面的定义中还值得注意的一点是：<code>&lt;zlbytes&gt;</code>,<code>&lt;zltail&gt;</code>,<code>&lt;zllen&gt;</code>既然占据多个字节，那么在存储的时候就有大端（big endian）和小端（little endian）的区别。ziplist采取的是小端模式来存储，这在下面我们介绍具体例子的时候还会再详细解释。</p>
<p>我们再来看一下每一个数据项<code>&lt;entry&gt;</code>的构成：</p>
<p><code>&lt;prevrawlen&gt;&lt;len&gt;&lt;data&gt;</code></p>
<p>我们看到在真正的数据（<code>&lt;data&gt;</code>）前面，还有两个字段：</p>
<ul>
<li><code>&lt;prevrawlen&gt;</code>: 表示前一个数据项占用的总字节数。这个字段的用处是为了让ziplist能够从后向前遍历（从后一项的位置，只需向前偏移prevrawlen个字节，就找到了前一项）。这个字段采用变长编码。</li>
<li><code>&lt;len&gt;</code>: 表示当前数据项的数据长度（即<code>&lt;data&gt;</code>部分的长度）。也采用变长编码。</li>
</ul>
<p>那么<code>&lt;prevrawlen&gt;</code>和<code>&lt;len&gt;</code>是怎么进行变长编码的呢？各位读者打起精神了，我们终于讲到了ziplist的定义中最繁琐的地方了。</p>
<p>先说<code>&lt;prevrawlen&gt;</code>。它有两种可能，或者是1个字节，或者是5个字节：</p>
<ol>
<li>如果前一个数据项占用字节数小于254，那么<code>&lt;prevrawlen&gt;</code>就只用一个 字节来表示，这个字节的值就是前一个数据项的占用字节数。</li>
<li>如果前一个数据项占用字节数大于等于254，那么<code>&lt;prevrawlen&gt;</code>就用5个字节来表示，其中第1个字节的值是254（作为这种情况的一个标记），而后面4个字节组成一个整型值，来真正存储前一个数据项的占用字节数。</li>
</ol>
<p>有人会问了，为什么没有255的情况呢？</p>
<p>这是因为：255已经定义为ziplist结束标记<code>&lt;zlend&gt;</code>的值了。在ziplist的很多操作的实现中，都会根据数据项的第1个字节是不是255来判断当前是不是到达ziplist的结尾了，因此一个正常的数据的第1个字节（也就是<code>&lt;prevrawlen&gt;</code>的第1个字节）是不能够取255这个值的，否则就冲突了。</p>
<p>而<code>&lt;len&gt;</code>字段就更加复杂了，它根据第1个字节的不同，总共分为9种情况（下面的表示法是按二进制表示）：</p>
<ol>
<li>|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么<code>&lt;len&gt;</code>字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。</li>
<li>|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么<code>&lt;len&gt;</code>字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。</li>
<li>|10<strong>__</strong>|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。需要注意的是：在前三种情况下，<code>&lt;data&gt;</code>都是按字符串来存储的；从下面第4种情况开始，<code>&lt;data&gt;</code>开始变为按整数来存储了。</li>
<li>|11000000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xC0，后面的数据<code>&lt;data&gt;</code>存储为2个字节的int16_t类型。</li>
<li>|11010000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xD0，后面的数据<code>&lt;data&gt;</code>存储为4个字节的int32_t类型。</li>
<li>|11100000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xE0，后面的数据<code>&lt;data&gt;</code>存储为8个字节的int64_t类型。</li>
<li>|11110000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xF0，后面的数据<code>&lt;data&gt;</code>存储为3个字节长的整数。</li>
<li>|11111110| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xFE，后面的数据<code>&lt;data&gt;</code>存储为1个字节的整数。</li>
<li>|1111xxxx| - - (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的<code>&lt;data&gt;</code>字段来表示真正的数据了，而是<code>&lt;len&gt;</code>和<code>&lt;data&gt;</code>合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。</li>
</ol>
<p>好了，ziplist的数据结构定义，我们介绍完了，现在我们看一个具体的例子。</p>
<p>[<img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/redis_ziplist_sample.png" alt="Redis Ziplist Sample" class="img_kGBN"></p>
<p>上图是一份真实的ziplist数据。我们逐项解读一下：</p>
<ul>
<li>这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</li>
<li>头4个字节（0x21000000）是按小端（little endian）模式存储的<code>&lt;zlbytes&gt;</code>字段。什么是小  端呢？就是指数据的低字节保存在内存的低地址中（参见维基百科词条<a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener noreferrer">Endianness</a>）。因此，这里<code>&lt;zlbytes&gt;</code>的值应该解析成0x00000021，用十进制表示正好就是33。</li>
<li>接下来4个字节（byte[4..7]）是<code>&lt;zltail&gt;</code>，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</li>
<li>再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</li>
<li>接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为”name”。</li>
<li>接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串”tielei”。</li>
<li>接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串”age”。</li>
<li>接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</li>
<li>最后1个字节（byte[32]）表示<code>&lt;zlend&gt;</code>，是固定的值255（0xFF）。</li>
</ul>
<p>总结一下，这个ziplist里存了4个数据项，分别为：</p>
<ul>
<li>字符串: “name”</li>
<li>字符串: “tielei”</li>
<li>字符串: “age”</li>
<li>整数: 20</li>
</ul>
<p>（好吧，被你发现了~~tielei实际上当然不是20岁，他哪有那么年轻啊……）</p>
<p>实际上，这个ziplist  是通过两个<code>hset</code>命令创建出来的。这个我们后半部分会再提到。</p>
<p>好了，既然你已经阅读到这里了，说明你还是很有耐心的（其实我写到这里也已经累得不行了）。可以先把本文收藏，休息一下，回头再看后半部分。</p>
<p>接下来我要贴一些代码了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="ziplist的接口">ziplist的接口<a href="#ziplist的接口" class="hash-link" aria-label="Direct link to ziplist的接口" title="Direct link to ziplist的接口">​</a></h2>
<p>我们先不着急看实现，先来挑几个ziplist的重要的接口，看看它们长什么样子：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistNew(void);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistIndex(unsigned char *zl, int index);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int ziplistLen(unsigned char *zl);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们从这些接口的名字就可以粗略猜出它们的功能，下面简单解释一下：</p>
<ul>
<li>ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。</li>
<li>ziplistNew: 创建一个空的ziplist（只包含<code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code>）。</li>
<li>ziplistMerge: 将两个ziplist合并成一个新的ziplist。</li>
<li>ziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一 个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。</li>
<li>ziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。</li>
<li>ziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。</li>
<li>ziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。</li>
<li>ziplistDelete: 删除指定的数据项。</li>
<li>ziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。</li>
<li>ziplistLen: 计算ziplist的长度（即包含数据项的个数）。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="ziplist的插入逻辑解析">ziplist的插入逻辑解析<a href="#ziplist的插入逻辑解析" class="hash-link" aria-label="Direct link to ziplist的插入逻辑解析" title="Direct link to ziplist的插入逻辑解析">​</a></h2>
<p>ziplist的相关接口的具体实现，还是有些复杂的，限于篇幅的原因，我们这里只结合代码来讲解插入的逻辑。插入是很有代表性的操作，通过这部分来一窥ziplist内部的实现，其  它部分的实现我们也就会很容易理解了。</p>
<p>ziplistPush和ziplistInsert都是插入，只是对于插入位置的限定不同。它们在内部实现都依赖一个名为__ziplistInsert的内部函数，其代码如下（出自ziplist.c）:</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;    unsigned int prevlensize, prevlen = 0;    size_t offset;    int nextdiff = 0;    unsigned char encoding = 0;    long long value = 123456789; /* initialized to avoid warning. Using a value                                    that is easy to see if for some reason                                    we use it uninitialized. */    zlentry tail;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Find out prevlen for the entry that is inserted. */    if (p[0] != ZIP_END) {        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);    } else {        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);        if (ptail[0] != ZIP_END) {            prevlen = zipRawEntryLength(ptail);        }    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* See if the entry can be encoded */    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {        /* &#x27;encoding&#x27; is set to the appropriate integer encoding */        reqlen = zipIntSize(encoding);    } else {        /* &#x27;encoding&#x27; is untouched, however zipEncodeLength will use the         * string length to figure out how to encode it. */        reqlen = slen;    }    /* We need space for both the length of the previous entry and     * the length of the payload. */    reqlen += zipPrevEncodeLength(NULL,prevlen);    reqlen += zipEncodeLength(NULL,encoding,slen);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* When the insert position is not equal to the tail, we need to     * make sure that the next entry can hold this entry&#x27;s length in     * its prevlen field. */    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Store offset because a realloc may change the address of zl. */    offset = p-zl;    zl = ziplistResize(zl,curlen+reqlen+nextdiff);    p = zl+offset;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Apply memory move when necessary and update tail offset. */    if (p[0] != ZIP_END) {        /* Subtract one because of the ZIP_END bytes */        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Encode this entry&#x27;s raw length in the next entry. */        zipPrevEncodeLength(p+reqlen,reqlen);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Update offset for tail */        ZIPLIST_TAIL_OFFSET(zl) =            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* When the tail contains more than one entry, we need to take         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */        zipEntry(p+reqlen, &amp;tail);        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {            ZIPLIST_TAIL_OFFSET(zl) =                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);        }    } else {        /* This element will be the new tail. */        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* When nextdiff != 0, the raw length of the next entry has changed, so     * we need to cascade the update throughout the ziplist */    if (nextdiff != 0) {        offset = p-zl;        zl = __ziplistCascadeUpdate(zl,p+reqlen);        p = zl+offset;    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Write the entry */    p += zipPrevEncodeLength(p,prevlen);    p += zipEncodeLength(p,encoding,slen);    if (ZIP_IS_STR(encoding)) {        memcpy(p,s,slen);    } else {        zipSaveInteger(p,value,encoding);    }    ZIPLIST_INCR_LENGTH(zl,1);    return zl;}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们来简单解析一下这段代码：</p>
<ul>
<li>这个函数是在指定的位置p插入一段新的数据，待插入数据的地址指针是s，长度为slen。插入后形成一个新的数据项，占据原来p的配置，原来位于p位置的数据项以及后面的所有数据项，需要统一向后移动，给新插入的数据项留出空间。参数p指向的是ziplist中某一个数据项的起始位置，或者在向尾端插入的时候，它指向ziplist的结束标记<code>&lt;zlend&gt;</code>。</li>
<li>函数开始先计算出待插入位置前一个数据项的长度<code>prevlen</code>。这个长度要存入新插入的数据项的<code>&lt;prevrawlen&gt;</code>字段。</li>
<li>然后计算当前数据项占用的总字节数<code>reqlen</code>，它包含三部分：<code>&lt;prevrawlen&gt;</code>,<code>&lt;len&gt;</code>和真正的数据。其中的数据部分会通过调用<code>zipTryEncoding</code>先来尝试转成整数。</li>
<li>由于插入导致的ziplist对于内存的新增需求，除了待插入数据项占用的<code>reqlen</code>之外，还要考虑原来p位置的数据项（现在要排在待插入数据项之后）的<code>&lt;prevrawlen&gt;</code>字段的变化。本来它保存的是前一项的总长度，现在变成了保存当前插入的数据项的总长度。这样它的<code>&lt;prevrawlen&gt;</code>字段本身需要的存储空间也可能发生变化，这个变化可能是变大也可能是变小。这个变化了多少的值<code>nextdiff</code>，是调用<code>zipPrevLenByteDiff</code>计算出来的。如果变大了，<code>nextdiff</code>是正值，否则是负值。</li>
<li>现在很容易算出来插入后新的ziplist需要多少字节了，然后调用<code>ziplistResize</code>来重新调整大小。ziplistResize的实现里会调用allocator的<code>zrealloc</code>，它有可能会造成数据拷贝。</li>
<li>现在额外的空间有了，接下来就是将原来p位置的数据项以及后面的所有数据都向后挪动，并为它设置新的<code>&lt;prevrawlen&gt;</code>字段。此外，还可能需要调整ziplist的<code>&lt;zltail&gt;</code>字段。</li>
<li>最后，组装新的待插入数据项，放在位置p。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="hash与ziplist">hash与ziplist<a href="#hash与ziplist" class="hash-link" aria-label="Direct link to hash与ziplist" title="Direct link to hash与ziplist">​</a></h2>
<p>hash是Redis中可以用来存储一个对象结构的比较理想的数据类型。一个对象的各个属性，正好对应一个hash结构的各个field。</p>
<p>我们在网上很容易找到这样一些技术文章，它们会说存储一个对象，使用hash比string要节省内存。实际上这么说是有前提的，具体取决于对象怎么来存储。如果你把对象的多个属性存储到多个key上（各个属性值存成string），当然占的内存要多。但如果你采用一些序列化方法，比如<a href="https://github.com/google/protobuf" target="_blank" rel="noopener noreferrer">Protocol Buffers</a>，或者<a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer">Apache Thrift</a>，先把对象序列化为字节数组，然后再存入到Redis的string中，那么跟hash相比，哪一种更省内存，就不一定了。</p>
<p>当然，hash比序列化后再存入string的方式，在支持的操作命令上，还是有优势的：它既支持多个field同时存取（<code>hmset</code>/<code>hmget</code>），也支持按照某个特定的field单独存取（<code>hset</code>/<code>hget</code>）。</p>
<p>实际上，hash随着数据的增大，其底层数据结构的实现是会发生变化的，当然存储效率也就不同。在field比较少，各个value值也比较小的时候，hash采用ziplist来实现；而随着field增多和value值增大，hash可能会变成dict来实现。当hash底层变成dict来实现的时候，它的存储效率就没法跟那些序列化方式相比了。</p>
<p>当我们为某个key第一次执行<code>hset key field value</code>命令的时候，Redis会创建一个hash结构，这个新创建的hash底层就是一个ziplist。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">robj *createHashObject(void) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned char *zl = ziplistNew();    robj *o = createObject(OBJ_HASH, zl);    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;    return o;}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上面的<code>createHashObject</code>函数，出自object.c，它负责的任务就是创建一个新的hash结构。可以看出，它创建了一个<code>type = OBJ_HASH</code>但<code>encoding = OBJ_ENCODING_ZIPLIST</code>的robj对象。</p>
<p>实际上，本文前面给出的那个ziplist实例，就是由如下两个命令构建出来的。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">hset user:100 name tielei  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hset user:100 age 20  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>每执行一次<code>hset</code>命令，插入的field和value分别作为一个新的数据项插入到ziplist中（即每次<code>hset</code>产生两个数据项）。</p>
<p>当随着数据的插入，hash底层的这个ziplist就可能会转成dict。那么到底插入多少才会转呢？</p>
<p>还记得本文开头提到的两个Redis配置吗？</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">hash-max-ziplist-entries 512  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hash-max-ziplist-value 64  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成dict：</p>
<ul>
<li>当hash中的数据项（即field-value对）的数目超过512的时候，也就是ziplist数据项超过1024的时候（请参考t_hash.c中的<code>hashTypeSet</code>函数）。</li>
<li>当hash中插入的任意一个value的长度超过了64的时候（请参考t_hash.c中的<code>hashTypeTryConversion</code>函数）。</li>
</ul>
<p>Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p>
<ul>
<li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能。</li>
<li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li>
<li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>总之，ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——skiplist"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">探索Redis设计与实现：Redis内部数据结构详解——skiplist</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis事务浅析与ACID特性介绍"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">探索Redis设计与实现：Redis事务浅析与ACID特性介绍</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是ziplist" class="table-of-contents__link toc-highlight">什么是ziplist</a></li><li><a href="#ziplist的数据结构定义" class="table-of-contents__link toc-highlight">ziplist的数据结构定义</a></li><li><a href="#ziplist的接口" class="table-of-contents__link toc-highlight">ziplist的接口</a></li><li><a href="#ziplist的插入逻辑解析" class="table-of-contents__link toc-highlight">ziplist的插入逻辑解析</a></li><li><a href="#hash与ziplist" class="table-of-contents__link toc-highlight">hash与ziplist</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-cache/探索Redis设计与实现：Redis内部数据结构详解——dict" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">探索Redis设计与实现：Redis内部数据结构详解——dict | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="探索Redis设计与实现：Redis内部数据结构详解——dict | Tommy"><meta data-rh="true" name="description" content="本文转自互联网"><meta data-rh="true" property="og:description" content="本文转自互联网"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">探索Redis设计与实现：连接底层与表面的数据结构robj</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：浅析Redis主从复制">探索Redis设计与实现：浅析Redis主从复制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：使用快照和AOF将Redis数据持久化到硬盘中">探索Redis设计与实现：使用快照和AOF将Redis数据持久化到硬盘中</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：数据库redisDb与键过期删除策略">探索Redis设计与实现：数据库redisDb与键过期删除策略</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis 的基础数据结构概览">探索Redis设计与实现：Redis 的基础数据结构概览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis的事件驱动模型与命令执行过程">探索Redis设计与实现：Redis的事件驱动模型与命令执行过程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis分布式锁进化史">探索Redis设计与实现：Redis分布式锁进化史</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例">探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict">探索Redis设计与实现：Redis内部数据结构详解——dict</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——intset">探索Redis设计与实现：Redis内部数据结构详解——intset</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——quicklist">探索Redis设计与实现：Redis内部数据结构详解——quicklist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——sds">探索Redis设计与实现：Redis内部数据结构详解——sds</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——skiplist">探索Redis设计与实现：Redis内部数据结构详解——skiplist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist">探索Redis设计与实现：Redis内部数据结构详解——ziplist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis事务浅析与ACID特性介绍">探索Redis设计与实现：Redis事务浅析与ACID特性介绍</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现开篇：什么是Redis">探索Redis设计与实现开篇：什么是Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/Redis原理与实践总结">Redis原理与实践总结</a></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">探索Redis设计与实现：Redis内部数据结构详解——dict</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>探索Redis设计与实现：Redis内部数据结构详解——dict</h1></header><p>本文转自互联网</p>
<p>本文将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p>
<blockquote>
<p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener noreferrer">https://github.com/h2pl/Java-Tutorial</a></p>
</blockquote>
<p>喜欢的话麻烦点下Star哈</p>
<p>本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p>
<p>该系列博文会告诉你如何从入门到进阶，Redis基本的使用方法，Redis的基本数据结构，以及一些进阶的使用方法，同 时也需要进一步了解Redis的底层数据结构，再接着，还会带来Redis主从复制、集群、分布式锁等方面的相关内容，以及作为缓存的一些使用方法和注意事项，以便让你更完整地了解整个Redis相关的技术体系，形成自己的知识框架。</p>
<p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p>
<p>如果你使用过Redis，一定会像我一样对它的内部实现产生兴趣。《Redis内部数据结构详解》是我准备写的一个系列，也是我个人对于之前研究Redis的一个阶段性总结，着重讲解Redis在内存中的数据结构实现（暂不涉及持久化的话题）。Redis本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p>
<p>当我们在本文中提到Redis的“数据结构”，可能是在两个不同的层面来讨论它。</p>
<p>第一个层面，是从使用者的角度。比如：</p>
<ul>
<li>string</li>
<li>list</li>
<li>hash</li>
<li>set</li>
<li>sorted set</li>
</ul>
<p>这一层面也是Redis暴露给外部的调用接口。</p>
<p>第二个层面，是从内部实现的角度，属于更底层的实现。比如：</p>
<ul>
<li>dict</li>
<li>sds</li>
<li>ziplist</li>
<li>quicklist</li>
<li>skiplist</li>
</ul>
<p>第一个层面的“数据结构”，Redis的官方文档(<a href="http://redis.io/topics/data-types-intro" target="_blank" rel="noopener noreferrer">http://redis.io/topics/data-types-intro</a>)有详细的介绍。本文的重点在于讨论第二个层面，Redis数据结构的内部实现，以及这两个层面的数据结构之间的关系：Redis如何通过组合第二个层面的各种基础数据结构来实现第一个层面的更高层的数据结构。</p>
<p>在讨论任何一个系统的内部实现的时候，我们都要先明确它的设计原则，这样我们才能更深刻地理解它为什么会进行如此设计的真正意图。在本文接下来的讨论中，我们主要关注以下几点：</p>
<ul>
<li>存储效率（memory efficiency）。Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。这意味着Redis一定是非常精细地考虑了压缩数据、减少内存碎片等问题。</li>
<li>快速响应时间（fast response time）。与快速响应时间相对的，是高吞吐量（high throughput）。Redis是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，快速响应时间是比高吞吐量更重要的目标。有时候，这两个目标是矛盾的。</li>
<li>单线程（single-threaded）。Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。相反，Redis通过异步IO和pipelining等机制来实现高速的并发访问。显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。</li>
</ul>
<p>本文是《Redis内部数据结构详解》系列的第一篇，讲述Redis一个重要的基础数据结构：dict。</p>
<p>dict是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。Redis的一个database中所有key到value的映射，就是使用一个dict来维护的。不过，这只是它在Redis中的一个用途而已，它在Redis中被使用的地方还有很多。比如，一个Redis hash结构，当它的field较多时，便会采用dict来存储。再比如，Redis配合使用dict和skiplist来共同维护一个sorted set。这些细节我们后面再讨论，在本文中，我们集中精力讨论dict本身的实现。</p>
<p>dict本质上是为了解决算法中的查找问题（Searching），一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。我们平常使用的各种Map或dictionary，大都是基于哈希表实现的。在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，基于哈希表的查找性能能做到非常高效，接近O(1)，而且实现简单。</p>
<p>在Redis中，dict也是一个基于哈希表的算法。和传统的哈希算法类似，它采用某个哈希函数从key计算得到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发重哈希（rehashing）。Redis的dict实现最显著的一个特点，就在于它的重哈希。它采用了一种称为增量式重哈希（incremental rehashing）的方法，在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。</p>
<p>下面进行详细介绍。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="dict的数据结构定义">dict的数据结构定义<a href="#dict的数据结构定义" class="hash-link" aria-label="Direct link to dict的数据结构定义" title="Direct link to dict的数据结构定义">​</a></h2>
<p>为了实现增量式重哈希（incremental rehashing），dict的数据结构里包含两个哈希表。在重哈希期间，数据从第一个哈希表向第二个哈希表迁移。</p>
<p>dict的C代码定义如下（出自Redis源码dict.h）：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    typedef struct dictEntry {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            void *val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            uint64_t u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int64_t s64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            double d;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct dictEntry *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } dictEntry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    typedef struct dictType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int (*hashFunction)(const void *key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *(*keyDup)(void *privdata, const void *key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *(*valDup)(void *privdata, const void *obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void (*keyDestructor)(void *privdata, void *key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void (*valDestructor)(void *privdata, void *obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } dictType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* This is our hash table structure. Every dictionary has two of this as we</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * implement incremental rehashing, for the old to the new table. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    typedef struct dictht {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictEntry **table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned long size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned long sizemask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned long used;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } dictht;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    typedef struct dict {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictType *type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *privdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictht ht[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int iterators; /* number of iterators currently running */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } dict;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>为了能更清楚地展示dict的数据结构定义，我们用一张结构图来表示它。如下。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230406203512.png" alt="" class="img_kGBN"></p>
<p>结合上面的代码和结构图，可以很清楚地看出dict的结构。一个dict由如下若干项组成：</p>
<ul>
<li>一个指向dictType结构的指针（type）。它通过自定义的方式使得dict的key和value能够存储任何类型的数据。</li>
<li>一个私有数据指针（privdata）。由调用者在创建dict的时候传进来。</li>
<li>两个哈希表（ht[2]）。只有在重哈希的过程中，ht[0]和ht[1]才都有效。而在平常情况下，只有ht[0]有效，ht[1]里面没有任何数据。上图表示的就是重 哈希进行到中间某一步时的情况。</li>
<li>当前重哈希索引（rehashidx）。如果rehashidx = -1，表示当前没有在重哈希过程中；否则，表示当前正在进行重哈希，且它的值记录了当前重哈希进行到哪一步了。</li>
<li>当前正在进行遍历的iterator的个数。这不是我们现在讨论的重点，暂时忽略。</li>
</ul>
<p>dictType结构包含若干函数指针，用于dict的调用者对涉及key和value的各种操作进行自定义。这些操作包含：</p>
<ul>
<li>hashFunction，对key进行哈希值计算的哈希算法。</li>
<li>keyDup和valDup，分别定义key和value的拷贝函数，用于在需要的时候对key和value进行深拷贝，而不仅仅是传递对象指针。</li>
<li>keyCompare，定义两个key的比较操作，在根据key进行查找时会用到。</li>
<li>keyDestructor和valDestructor，分别定义对key和value的析构函数。</li>
</ul>
<p>私有数据指针（privdata）就是在dictType的某些操作被调用时会传回给调用者。</p>
<p>需要详细察看的是dictht结构。它定义一个哈希表的结构，由如下若干项组成：</p>
<ul>
<li>一个dictEntry指针数组（table）。key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。</li>
<li>size：标识dictEntry指针数组的长度。它总是2的指数。</li>
<li>sizemask：用于将哈希值映射到table的位置索引。它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。</li>
<li>used：记录dict中现有的数据个数。它与size的比值就是装载因子（load factor）。这个比值越大，哈希值冲突概率越高。</li>
</ul>
<p>dictEntry结构中包含k, v 和指向链表下一项的next指针。k是void指针，这意味着它可以指向任何类型。v是个union，当它的值是uint64_t、int64_t或double类型时，就不再需要额外的存储，这有利于减少内存碎片。当然，v也可以是void指针，以便能存储任何类型的数据。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="dict的创建dictcreate">dict的创建（dictCreate）<a href="#dict的创建dictcreate" class="hash-link" aria-label="Direct link to dict的创建（dictCreate）" title="Direct link to dict的创建（dictCreate）">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    dict *dictCreate(dictType *type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            void *privDataPtr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dict *d = zmalloc(sizeof(*d));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _dictInit(d,type,privDataPtr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return d;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int _dictInit(dict *d, dictType *type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            void *privDataPtr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _dictReset(&amp;d-&gt;ht[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _dictReset(&amp;d-&gt;ht[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d-&gt;type = type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d-&gt;privdata = privDataPtr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d-&gt;rehashidx = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d-&gt;iterators = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DICT_OK;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static void _dictReset(dictht *ht)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht-&gt;table = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht-&gt;size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht-&gt;sizemask = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht-&gt;used = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>dictCreate为dict的数据结构分配空间并为各个变量赋初值。其中两个哈希表ht[0]和ht[1]起始都没有分配空间，table指针都赋为NULL。这意味着要等第一个数据插入时才会真正分配空间。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="dict的查找dictfind">dict的查找（dictFind）<a href="#dict的查找dictfind" class="hash-link" aria-label="Direct link to dict的查找（dictFind）" title="Direct link to dict的查找（dictFind）">​</a></h2>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    //define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dictEntry *dictFind(dict *d, const void *key)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictEntry *he;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int h, idx, table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (d-&gt;ht[0].used + d-&gt;ht[1].used == 0) return NULL; /* dict is empty */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dictIsRehashing(d)) _dictRehashStep(d);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        h = dictHashKey(d, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (table = 0; table &lt;= 1; table++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx = h &amp; d-&gt;ht[table].sizemask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            he = d-&gt;ht[table].table[idx];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(he) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return he;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                he = he-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!dictIsRehashing(d)) return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述dictFind的源码，根据dict当前是否正在重哈希，依次做了这么几件事：</p>
<ul>
<li>如果当前正在进行重哈希，那么将重哈希过程向前推进一步（即调用_dictRehashStep）。实际上，除了查找，插入和删除也都会触发这一动作。这就将重哈希过程分散到各个查找、插入和删除操作中去了，而不是集中在某一个操作中一次性做完。</li>
<li>计算key的哈希值（调用dictHashKey，里面的实现会调用前面提到的hashFunction）。</li>
<li>先在第一个哈希表ht[0]上进行查找。在table数组上定位到哈希值对应的位置（如前所述，通过哈希值与sizemask进行按位与），然后在对应的dictEntry链表上进行查找。查找的时候需要对key进行比较，这时候调用dictCompareKeys，它里面的实现会调用到前面提到的keyCompare。如果找到就返回该项。否则，进行下一步。</li>
<li>判断当前是否在重哈希，如果没有，那么在ht[0]上的查找结果就是最终结果（没找到，返回NULL）。否则，在ht[1]上进行查找（过程与上一步相同）。</li>
</ul>
<p>下面我们有必要看一下  增量式重哈希的_dictRehashStep的实现。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    static void _dictRehashStep(dict *d) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (d-&gt;iterators == 0) dictRehash(d,1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int dictRehash(dict *d, int n) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int empty_visits = n*10; /* Max number of empty buckets to visit. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!dictIsRehashing(d)) return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(n-- &amp;&amp; d-&gt;ht[0].used != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dictEntry *de, *nextde;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * elements because ht[0].used != 0 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                d-&gt;rehashidx++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (--empty_visits == 0) return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            de = d-&gt;ht[0].table[d-&gt;rehashidx];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* Move all the keys in this bucket from the old to the new hash HT */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(de) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unsigned int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nextde = de-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* Get the index in the new hash table */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                de-&gt;next = d-&gt;ht[1].table[h];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                d-&gt;ht[1].table[h] = de;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                d-&gt;ht[0].used--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                d-&gt;ht[1].used++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                de = nextde;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            d-&gt;rehashidx++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Check if we already rehashed the whole table... */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (d-&gt;ht[0].used == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            zfree(d-&gt;ht[0].table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            d-&gt;ht[0] = d-&gt;ht[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _dictReset(&amp;d-&gt;ht[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            d-&gt;rehashidx = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* More to rehash... */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>dictRehash每次将重哈希至少向前推进n步（除非不到n步整个重哈希就结束了），每一步都将ht[0]上某一个bucket（即一个dictEntry链表）上的每一个dictEntry移动到ht[1]上，它在ht[1]上的新位置根据ht[1]的sizemask进行重新计算。rehashidx记录了当前尚未迁移（有待迁移）的ht[0]的bucket位置。</p>
<p>如果dictRehash被调用的时候，rehashidx指向的bucket里一个dictEntry也没有，那么它就没有可迁移的数据。这时它尝试在ht[0].table数组中不断向后遍历，直到找到下一个存有数据的bucket位置。如果一直找不到，则最多走n*10步，本次重哈希暂告结束。</p>
<p>最后，如果ht[0]上的数据都迁移到ht[1]上了（即d-&gt;ht[0].used == 0），那么整个重哈希结束，ht[0]变成ht[1]的内容，而ht[1]重置为空。</p>
<p>根据以上对于重哈希过程的分析，我们容易看出，本文前面的dict结构图中所展示的正是rehashidx=2时的情况，前面两个bucket（ht[0].table[0]和ht[0].table[1]）都已经迁移到ht[1]上 去了。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="dict的插入dictadd和dictreplace">dict的插入（dictAdd和dictReplace）<a href="#dict的插入dictadd和dictreplace" class="hash-link" aria-label="Direct link to dict的插入（dictAdd和dictReplace）" title="Direct link to dict的插入（dictAdd和dictReplace）">​</a></h2>
<p>dictAdd插入新的一对key和value，如果key已经存在，则插入失败。</p>
<p>dictReplace也是插入一对key和value，不过在key存在的时候，它会更新value。</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    int dictAdd(dict *d, void *key, void *val)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictEntry *entry = dictAddRaw(d,key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!entry) return DICT_ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictSetVal(d, entry, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DICT_OK;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dictEntry *dictAddRaw(dict *d, void *key)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictEntry *entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictht *ht;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dictIsRehashing(d)) _dictRehashStep(d);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Get the index of the new element, or -1 if</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * the element already exists. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((index = _dictKeyIndex(d, key)) == -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Allocate the memory and store the new entry.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Insert the element in top, with the assumption that in a database</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * system it is more likely that recently added entries are accessed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * more frequently. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        entry = zmalloc(sizeof(*entry));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        entry-&gt;next = ht-&gt;table[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht-&gt;table[index] = entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ht-&gt;used++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Set the hash entry fields. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictSetKey(d, entry, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int _dictKeyIndex(dict *d, const void *key)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int h, idx, table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictEntry *he;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Expand the hash table if needed */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (_dictExpandIfNeeded(d) == DICT_ERR)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Compute the key hash value */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        h = dictHashKey(d, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (table = 0; table &lt;= 1; table++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx = h &amp; d-&gt;ht[table].sizemask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* Search if this slot does not already contain the given key */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            he = d-&gt;ht[table].table[idx];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while(he) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                he = he-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!dictIsRehashing(d)) break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>以上是dictAdd的关键实现代码。我们主要需要注意以下几点：</p>
<ul>
<li>它也会触发推进一步重哈希（_dictRehashStep）。</li>
<li>如果正在重哈希中，它会把数据插入到ht[1]；否则插入到ht[0]。</li>
<li>在对应的bucket中插入数据的时候，总是插入到dictEntry的头部。因为新数据接下来被访问的概率可能比较高，这样再次查找它时就比较次数较少。</li>
<li>_dictKeyIndex在dict中寻找插入位置。如果不在重哈希过程中，它只查找ht[0]；否则查找ht[0]和ht[1]。</li>
<li>_dictKeyIndex可能触发dict内存扩展（_dictExpandIfNeeded，它将哈希表长度扩展为原来两倍，具体请参考dict.c中源码）。</li>
</ul>
<p>dictReplace在dictAdd基础上实现，如下：</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    int dictReplace(dict *d, void *key, void *val)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictEntry *entry, auxentry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Try to add the element. If the key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * does not exists dictAdd will suceed. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dictAdd(d, key, val) == DICT_OK)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* It already exists, get the entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        entry = dictFind(d, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Set the new value and free the old one. Note that it is important</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * to do that in this order, as the value may just be exactly the same</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * as the previous one. In this context, think to reference counting,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * you want to increment (set), and then decrement (free), and not the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * reverse. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        auxentry = *entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictSetVal(d, entry, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dictFreeVal(d, &amp;auxentry);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在key已经存在的情况下，dictReplace会同时调用dictAdd和dictFind，这其实相当于两次查找过程。这里Redis的代码不够优化。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="dict的删除dictdelete">dict的删除（dictDelete）<a href="#dict的删除dictdelete" class="hash-link" aria-label="Direct link to dict的删除（dictDelete）" title="Direct link to dict的删除（dictDelete）">​</a></h2>
<p>dictDelete的源码这里忽略，具体请参考dict.c。需要稍加注意的是：</p>
<ul>
<li>dictDelete也会触发推进一步重哈希（_dictRehashStep）</li>
<li>如果当前不在重哈希过程中，它只在ht[0]中查找要删除的key；否则ht[0]和ht[1]它都要查找。</li>
<li>删除成功后会调用key和value的析构函数（keyDestructor和valDestructor）。</li>
</ul>
<hr>
<p>dict的实现相对来说比较简单，本文就介绍到这。在下一篇中我们将会介绍Redis中动态字符串的实现——sds，敬请期待。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——intset"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">探索Redis设计与实现：Redis内部数据结构详解——intset</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#dict的数据结构定义" class="table-of-contents__link toc-highlight">dict的数据结构定义</a></li><li><a href="#dict的创建dictcreate" class="table-of-contents__link toc-highlight">dict的创建（dictCreate）</a></li><li><a href="#dict的查找dictfind" class="table-of-contents__link toc-highlight">dict的查找（dictFind）</a></li><li><a href="#dict的插入dictadd和dictreplace" class="table-of-contents__link toc-highlight">dict的插入（dictAdd和dictReplace）</a></li><li><a href="#dict的删除dictdelete" class="table-of-contents__link toc-highlight">dict的删除（dictDelete）</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>
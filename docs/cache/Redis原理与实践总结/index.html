<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-cache/Redis原理与实践总结" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Redis原理与实践总结 | Tommy</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aiden-coding.github.io/code-note-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aiden-coding.github.io/code-note-blog/docs/cache/Redis原理与实践总结"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Redis原理与实践总结 | Tommy"><meta data-rh="true" name="description" content="本文主要对Redis的设计和实现原理做了一个介绍很总结，有些东西我也介绍的不是很详细准确，尽量在自己的理解范围内把一些知识点和关键性技术做一个描述。如有错误，还望见谅，欢迎指出。"><meta data-rh="true" property="og:description" content="本文主要对Redis的设计和实现原理做了一个介绍很总结，有些东西我也介绍的不是很详细准确，尽量在自己的理解范围内把一些知识点和关键性技术做一个描述。如有错误，还望见谅，欢迎指出。"><link data-rh="true" rel="icon" href="/code-note-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aiden-coding.github.io/code-note-blog/docs/cache/Redis原理与实践总结"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/cache/Redis原理与实践总结" hreflang="en"><link data-rh="true" rel="alternate" href="https://aiden-coding.github.io/code-note-blog/docs/cache/Redis原理与实践总结" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/code-note-blog/blog/rss.xml" title="Tommy RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/code-note-blog/blog/atom.xml" title="Tommy Atom Feed"><link rel="stylesheet" href="/code-note-blog/assets/css/styles.dd5372db.css">
<script src="/code-note-blog/assets/js/runtime~main.f999fb27.js" defer="defer"></script>
<script src="/code-note-blog/assets/js/main.a0bfbaed.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XYiV" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/code-note-blog/"><b class="navbar__title text--truncate">Tommy</b></a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Java/basic/抽象类和接口">java</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/JavaWeb/走进JavaWeb技术世界：JavaWeb的由来和基础知识">javaweb</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">cache</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/backend/后端技术杂谈：白话虚拟化技术">backend</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/cs/algorithms/剑指offer">cs</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/database/重新学习MySQL数据库：『浅入浅出』MySQL和InnoDB">database</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/distributed/basic/分布式系统理论基础 ：CAP">distributed</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/interview/BATJ-Experience/面阿里,终获offer">interview</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mq/kafka/消息队列kafka详解：如何实现死信队列">mq</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/Spring全家桶/Spring/第一个Spring应用">spring</a><a class="navbar__item navbar__link" href="/code-note-blog/docs/mianshi/collection">面试</a><a href="https://aiden-coding.github.io/code-note-blog/SpringCloud%E7%AC%AC3%E5%AD%A32024.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_XbAW colorModeToggle_r5NY"><button class="clean-btn toggleButton_Jx0n toggleButtonDisabled_zYO7" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_FjAw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_qmEt"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_wJfS"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_LABv"><div class="docsWrapper_pdvB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_Jioa" type="button"></button><div class="docRoot_qx_v"><aside class="theme-doc-sidebar-container docSidebarContainer_NHKT"><div class="sidebarViewport_uyYB"><div class="sidebar_SZG4"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_VP_k"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：连接底层与表面的数据结构robj">探索Redis设计与实现：连接底层与表面的数据结构robj</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：浅析Redis主从复制">探索Redis设计与实现：浅析Redis主从复制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：使用快照和AOF将Redis数据持久化到硬盘中">探索Redis设计与实现：使用快照和AOF将Redis数据持久化到硬盘中</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：数据库redisDb与键过期删除策略">探索Redis设计与实现：数据库redisDb与键过期删除策略</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis 的基础数据结构概览">探索Redis设计与实现：Redis 的基础数据结构概览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis的事件驱动模型与命令执行过程">探索Redis设计与实现：Redis的事件驱动模型与命令执行过程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis分布式锁进化史">探索Redis设计与实现：Redis分布式锁进化史</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例">探索Redis设计与实现：Redis集群机制及一个Redis架构演进实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——dict">探索Redis设计与实现：Redis内部数据结构详解——dict</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——intset">探索Redis设计与实现：Redis内部数据结构详解——intset</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——quicklist">探索Redis设计与实现：Redis内部数据结构详解——quicklist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——sds">探索Redis设计与实现：Redis内部数据结构详解——sds</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——skiplist">探索Redis设计与实现：Redis内部数据结构详解——skiplist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis内部数据结构详解——ziplist">探索Redis设计与实现：Redis内部数据结构详解——ziplist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现：Redis事务浅析与ACID特性介绍">探索Redis设计与实现：Redis事务浅析与ACID特性介绍</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/code-note-blog/docs/cache/探索Redis设计与实现开篇：什么是Redis">探索Redis设计与实现开篇：什么是Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/code-note-blog/docs/cache/Redis原理与实践总结">Redis原理与实践总结</a></li></ul></nav></div></div></aside><main class="docMainContainer_SejT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_j3Yw"><div class="docItemContainer_XOSC"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_F6gm" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/code-note-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YCxa"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Redis原理与实践总结</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ToOY theme-doc-toc-mobile tocMobile_suYB"><button type="button" class="clean-btn tocCollapsibleButton_VzP_">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Redis原理与实践总结</h1></header><p>本文主要对Redis的设计和实现原理做了一个介绍很总结，有些东西我也介绍的不是很详细准确，尽量在自己的理解范围内把一些知识点和关键性技术做一个描述。如有错误，还望见谅，欢迎指出。
这篇文章主要还是参考我之前的技术专栏总结而来的。欢迎查看：</p>
<p>重新学习Redis</p>
<p><a href="https://blog.csdn.net/column/details/21877.html" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/column/details/21877.html</a></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="使用和基础数据结构外观">使用和基础数据结构（外观）<a href="#使用和基础数据结构外观" class="hash-link" aria-label="Direct link to 使用和基础数据结构（外观）" title="Direct link to   使用和基础数据结构（外观）">​</a></h2>
<p>redis的基本使用方式是建立在redis提供的数据结构上的。</p>
<p>字符串
REDIS_STRING (字符串)是 Redis 使用得最为广泛的数据类型,它除了是 SET 、GET 等命令 的操作对象之外,数据库中的所有键,以及执行命令时提供给 Redis 的参数,都是用这种类型 保存的。</p>
<p>字符串类型分别使用 REDIS_ENCODING_INT 和 REDIS_ENCODING_RAW 两种编码</p>
<p>只有能表示为 long 类型的值,才会以整数的形式保存,其他类型 的整数、小数和字符串,都是用 sdshdr 结构来保存</p>
<p>哈希表
REDIS_HASH (哈希表)是HSET 、HLEN 等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_HT 两种编码方式</p>
<p>Redis 中每个hash可以存储232-1键值对（40多亿）</p>
<p>列表
REDIS_LIST(列表)是LPUSH 、LRANGE等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_LINKEDLIST 这两种方式编码</p>
<p>一个列表最多可以包含232-1 个元素(4294967295, 每个列表超过40亿个元素)。</p>
<p>集合
REDIS_SET (集合) 是 SADD 、 SRANDMEMBER 等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_INTSET 和 REDIS_ENCODING_HT 两种方式编码</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p>
<p>有序集
REDIS_ZSET (有序集)是ZADD 、ZCOUNT 等命令的操作对象</p>
<p>它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_SKIPLIST 两种方式编码</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可 存储40多亿个成员)</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="底层数据结构">底层数据结构<a href="#底层数据结构" class="hash-link" aria-label="Direct link to 底层数据结构" title="Direct link to 底层数据结构">​</a></h2>
<p>下面讨论redis底层数据结构</p>
<p>1 SDS动态字符串</p>
<p>sds字符串是字符串的实现</p>
<p>动态字符串是一个结构体，内部有一个buf数组，以及字符串长度，剩余长度等字段，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。</p>
<p>并且sds支持写入二进制数据，而不一定是字符。</p>
<p>2 dict字典</p>
<p>dict字典是哈希表的实现。</p>
<p>dict字典与Java中的哈希表实现简直如出一辙，首先都是数组+链表组成的结构，通过dictentry保存节点。</p>
<p>其中dict同时保存两个entry数组，当需要扩容时，把节点转移到第二个数组即可，平时只使用一个数组。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/redis_dict_structure.png" alt="image" class="img_kGBN"></p>
<p>3 压缩链表ziplist</p>
<p>3.1 ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</p>
<p>3.2 实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。</p>
<p>3.3 而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是  一个链表（linked list）。</p>
<p>3.4 另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。</p>
<p>实际上。redis的字典一开始的数据比较少时，会使用ziplist的方式来存储，也就是key1，value1，key2，value2这样的顺序存储，对于小数据量来说，这样存储既省空间，查询的效率也不低。</p>
<p>当数据量超过阈值时，哈希表自动膨胀为之前我们讨论的dict。</p>
<p>4 quicklist</p>
<p>quicklist是结合ziplist存储优势和链表灵活性与一身的双端链表。</p>
<p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p>
<p>4.1 双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。</p>
<p>首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p>
<p>4.2 ziplist由于是一整块连续内存，所以存储效率很高。</p>
<p>但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/redis_quicklist_structure.png" alt="image" class="img_kGBN"></p>
<p>5 zset
zset其实是两种结构的合并。也就是dict和skiplist结合而成的。dict负责保存数据对分数的映射，而skiplist用于根据分数进行数据的查询（相辅相成）</p>
<p>6 skiplist</p>
<p>sortset数据结构使用了ziplist+zset两种数据结构。</p>
<p>Redis里面使用skiplist是为了实现sorted set这种对外的数据结构。sorted set提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。</p>
<p>sortedset是由skiplist，dict和ziplist组成的。</p>
<p>当数据较少时，sorted set是由一个ziplist来实现的。
当数据多的时候，sorted</p>
<p>set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</p>
<p>在本系列前面关于ziplist的文章里，我们介绍过，ziplist就是由很多数据项组成的一大块连续内存。由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/redis_skiplist_example.png" alt="image" class="img_kGBN"></p>
<p>skiplist的节点中存着节点值和分数。并且跳表是根据节点的分数进行排序的，所以可以根据节点分数进行范围查找。</p>
<p>7inset</p>
<p>inset是一个数字结合，他使用灵活的数据类型来保持数字。</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230406202310.png" alt="" class="img_kGBN"></p>
<p>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。
添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。
当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。</p>
<p>8总结</p>
<p>sds是一个灵活的字符串数组，并且支持直接存储二进制数据，同时提供长度和剩余空间的字段来保证伸缩性和防止溢出。</p>
<p>dict是一 个字典结构，实现方式就是Java中的hashmap实现，同时持有两个节点数组，但只使用其中一个，扩容时换成另外一个。</p>
<p>ziplist是一个压缩链表，他放弃内存不连续的连接方式，而是直接分配连续内存进行存储，减少内存碎片。提高利用率，并且也支持存储二进制数据。</p>
<p>quicklist是ziplist和传统链表的中和形成的链表结果，每个链表节点都是一个ziplist。</p>
<p>skiplist一般有ziplist和zset两种实现方法，根据数据量来决定。zset本身是由skiplist和dict实现的。</p>
<p>inset是一个数字集合，他根据插入元素的数据类型来决定数组元素的长度。并自动进行扩容。</p>
<p>9 他们实现了哪些结构</p>
<p>字符串由sds实现</p>
<p>list由ziplist和quicklist实现</p>
<p>sortset由ziplist和zset实现</p>
<p>hash表由dict实现</p>
<p>集合由inset实现。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="redis-server结构和数据库redisdb">redis server结构和数据库redisDb<a href="#redis-server结构和数据库redisdb" class="hash-link" aria-label="Direct link to redis server结构和数据库redisDb" title="Direct link to redis server结构和数据库redisDb">​</a></h2>
<p>1 redis服务器中维护着一个数据库名为redisdb，实际上他是一个dict结构。</p>
<p>Redis的数据库使用字典作为底层实现，数据库的增、删、查、改都是构建在字典的操作之上的。</p>
<p>2 redis服务器将所有数据库都保存在服务器状态结构redisServer(redis.h/redisServer)的db数组（应该是一个链表）里：</p>
<p>同理也有一个redis client结构，通过指针可以选择redis client访问的server是哪一个。</p>
<p>3 redisdb的键空间</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    typedef struct redisDb {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据库键空间，保存着数据库中的所有键值对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dict *dict;                 /* The keyspace for this DB */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dict *expires;              /* Timeout of keys with a timeout set */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据库号码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int id;                     /* Database ID */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据库的键的平均 TTL ，统计信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long long avg_ttl;          /* Average TTL, just for stats */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //..</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } redisDb</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这部分的代码说明了，redisdb除了维护一个dict组以外，还需要对应地维护一个expire的字典数组。</p>
<p>大的dict数组中有多个小的dict字典，他们共同负责存储redisdb的所有键值对。</p>
<p>同时，对应的expire字典则负责存储这些键的过期时间
<img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230406201529.png" alt="" class="img_kGBN"></p>
<p>4 过期键的删除策略</p>
<p>2、过期键删除策略
通过前面的介绍，大家应该都知道数据库键的过期时间都保存在过期字典里，那假如一个键过期了，那么这个过期键是什么时候被删除的呢？现在来看看redis的过期键的删除策略：</p>
<p>a、定时删除：在设置键的过期时间的同时，创建一个定时器，在定时结束的时候，将该键删除；</p>
<p>b、惰性删除：放任键过期不管，在访问该键的时候，判断该键的过期时间是否已经到了，如果过期时间已经到了，就执行删除操作；</p>
<p>c、定期删除：每隔一段时间，对数据库中的键进行一次遍历，删除过期的键。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="redis的事件模型">redis的事件模型<a href="#redis的事件模型" class="hash-link" aria-label="Direct link to redis的事件模型" title="Direct link to redis的事件模型">​</a></h2>
<p>redis处理请求的方式基于reactor线程模型，即一个线程处理连接，并且注册事件到IO多路复用器，复用器触发事件以后根据不同的处理器去执行不同的操作。总结以下客户端到服务端的请求过程</p>
<p>总结</p>
<p>远程客户端连接到 redis 后，redis服务端会为远程客户端创建一个 redisClient 作为代理。</p>
<p>redis 会读取嵌套字中的数据  ，写入 querybuf 中。</p>
<p>解析 querybuf 中的命令，记录到 argc 和 argv 中。</p>
<p>根据 argv[0] 查找对应的 recommand。</p>
<p>执行 recommend 对应的执行函数。</p>
<p>执行以后将结果存入 buf &amp; bufpos &amp; reply 中。</p>
<p>返回给调用方。返回数据的时候，会控制写入数据量的大小，如果过大会分成若干次。保证 redis 的相应时间。</p>
<p>Redis 作为单线程应用，一直贯彻的思想就是，每个步骤的执行都有一个上限（包括执行时间的上限或者文件尺寸的上限）一旦达到上限，就会记录下当前的执行进度，下次再执行。保证了 Redis 能够及时响应不发生阻塞。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="备份方式">备份方式<a href="#备份方式" class="hash-link" aria-label="Direct link to 备份方式" title="Direct link to 备份方式">​</a></h2>
<p>快照（RDB）：就是我们俗称的备份，他可以在定期内对数据进行备份，将Redis服务器中的数据持久化到硬盘中；</p>
<p>只追加文件（AOF）：他会在执行写命令的时候，将执行的写命令复制到硬盘里面，后期恢复的时候，只需要重新执行一下这个写命令就可以了。类似于我们的MySQL数据库在进行主从复制的时候，使用的是binlog二进制文件，同样的是执行一遍写命令；</p>
<p>appendfsync同步频率的区别如下图：</p>
<p><img loading="lazy" src="https://java-tutorial.oss-cn-shanghai.aliyuncs.com/20230406201549.png" alt="" class="img_kGBN"></p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="redis主从复制">redis主从复制<a href="#redis主从复制" class="hash-link" aria-label="Direct link to redis主从复制" title="Direct link to redis主从复制">​</a></h2>
<p>Redis复制工作过程：</p>
<p>slave向master发送sync命令。</p>
<p>master开启子进程来讲dataset写入rdb文件，同时将子进程完成之前接收到的写命令缓存起来。</p>
<p>子进程写完，父进程得知，开始将RDB文件发送给slave。</p>
<p>master发送完RDB文件，将缓存的命令也发给slave。</p>
<p>master增量的把写命令发给slave。</p>
<p>注意有两步操作，一个是写入rdb的时候要缓存写命令，防止数据不一致。发完rdb后还要发写命令给salve，以后增量发命令就可以了</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="分布式锁实现">分布式锁实现<a href="#分布式锁实现" class="hash-link" aria-label="Direct link to 分布式锁实现" title="Direct link to 分布式锁实现">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用setnx加expire实现加锁和时限">使用setnx加expire实现加锁和时限<a href="#使用setnx加expire实现加锁和时限" class="hash-link" aria-label="Direct link to 使用setnx加expire实现加锁和时限" title="Direct link to 使用setnx加expire实现加锁和时限">​</a></h3>
<p>加锁时使用setnx设置key为1并设置超时时间，解锁时删除键</p>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    tryLock(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SETNX Key 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPIRE Key Seconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    release(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      DELETE Key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方案的一个问题在于每次提交一个Redis请求，如果执行完第一条命令后应用异常或者重启，锁将无法过期，一种改善方案就是使用Lua脚本（包含SETNX和EXPIRE两条命令），但是如果Redis仅执行了一条命令后crash或者发生主从切换，依然会出现锁没有过期时间，最终导致无法释放。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用getset加锁和获取过期时间">使用getset加锁和获取过期时间<a href="#使用getset加锁和获取过期时间" class="hash-link" aria-label="Direct link to 使用getset加锁和获取过期时间" title="Direct link to 使用getset加锁和获取过期时间">​</a></h3>
<p>针对锁无法释放问题的一个解决方案基于GETSET命令来实现</p>
<p>思路：</p>
<p>SETNX(Key,ExpireTime)获取锁</p>
<p>如果获取锁失败，通过GET(Key)返回的时间戳检查锁是否已经过期</p>
<p>GETSET(Key,ExpireTime)修改Value为NewExpireTime</p>
<p>检查GETSET返回的旧值，如果等于GET返回的值，则认为获取锁成功</p>
<p>注意：这个版本去掉了EXPIRE命令，改为通过Value时间戳值来判断过期</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="20的setnx可以配置过期时间">2.0的setnx可以配置过期时间。<a href="#20的setnx可以配置过期时间" class="hash-link" aria-label="Direct link to 2.0的setnx可以配置过期时间。" title="Direct link to 2.0的setnx可以配置过期时间。">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    V2.0 基于SETNX</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tryLock(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SETNX Key 1 Seconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    release(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      DELETE Key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Redis 2.6.12版本后SETNX增加过期时间参数，这样就解决了两条命令无法保证原子性的问题。但是设想下面一个场景：</p>
<ol>
<li>C1成功获取到了锁，之后C1因为GC进入等待或者未知原因导致任务执行过长，最后在锁失效前C1没有主动释放锁 2. C2在C1的锁超时后获取到锁，并且开始执行，这个时候C1和C2都同时在执行，会因重复执行造成数据不一致等未知情况 3. C1如果先执行完毕，则会释放C2的锁，此时可能导致另外一个C3进程获取到了锁</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="使用sentx将值设为时间戳通过lua脚本进行cas比较和删除操作">使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作<a href="#使用sentx将值设为时间戳通过lua脚本进行cas比较和删除操作" class="hash-link" aria-label="Direct link to 使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作" title="Direct link to 使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作">​</a></h3>
<div class="codeBlockContainer_Ty55 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_zoWS"><pre tabindex="0" class="prism-code language-text codeBlock_Po6r thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_Llrq"><span class="token-line" style="color:#393A34"><span class="token plain">    V3.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tryLock(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SETNX Key UnixTimestamp Seconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    release(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EVAL(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //LuaScript</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              return redis.call(&quot;del&quot;,KEYS[1])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup_EjFN"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_RXpO" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sabX"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_WdXf"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这个方案通过指定Value为时间戳，并在释放锁的时候检查锁的Value是否为获取锁的Value，避免了V2.0版本中提到的C1释放了C2持有的锁的问题；另外在释放锁的时候因为涉及到多个Redis操作，并且考虑到Check And Set 模型的并发问题，所以使用Lua脚本来避免并发问题。</p>
<p>如果在并发极高的场景下，比如抢红包场景，可能存在UnixTimestamp重复问题，另外由于不能保证分布式环境下的物理时钟一致性，也可能存在UnixTimestamp重复问题，只不过极少情况下会遇到。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="分布式redis锁redlock">分布式Redis锁：Redlock<a href="#分布式redis锁redlock" class="hash-link" aria-label="Direct link to 分布式Redis锁：Redlock" title="Direct link to 分布式Redis锁：Redlock">​</a></h3>
<p>redlock的思想就是要求一个节点获取集群中N/2 + 1个节点
上的锁才算加锁成功。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h3>
<p>不论是基于SETNX版本的Redis单实例分布式锁，还是Redlock分布式锁，都是为了保证下特性</p>
<ol>
<li>安全性：在同一时间不允许多个Client同时持有锁</li>
<li>活性</li>
</ol>
<p>死锁：锁最终应该能够被释放，即使Client端crash或者出现网络分区（通常基于超时机制）
容错性：只要超过半数Redis节点可用，锁都能被正确获取和释放</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="分布式方案">分布式方案<a href="#分布式方案" class="hash-link" aria-label="Direct link to 分布式方案" title="Direct link to 分布式方案">​</a></h2>
<p>1 主从复制，优点是备份简易使用。缺点是不能故障切换，并且不易扩展。</p>
<p>2 使用sentinel哨兵工具监控和实现自动切换。</p>
<p>3 codis集群方案</p>
<p>首先codis使用代理的方式隐藏底层redis，这样可以完美融合以前的代码，不需要更改redis访问操作。</p>
<p>然后codis使用了zookeeper进行监控和自动切换。同时使用了redis-group的概念，保证一个group里是一主多从的主从模型，基于此来进行切换。</p>
<p>4 redis cluster集群</p>
<p>该集群是一个p2p方式部署的集群</p>
<p>Redis cluster是一个去中心化、多实例Redis间进行数据共享的集群。</p>
<p>每个节点上都保存着其他节点的信息，通过任一节点可以访问正常工作的节点数据，因为每台机器上的保留着完整的分  片信息，某些机器不正常工作不影响整体集群的工作。并且每一台redis主机都会配备slave，通过sentinel自动切换。</p>
<h2 class="anchor anchorWithStickyNavbar_HWLp" id="redis事务">redis事务<a href="#redis事务" class="hash-link" aria-label="Direct link to redis事务" title="Direct link to redis事务">​</a></h2>
<p>事务
MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>redis事务有一个特点，那就是在2.6以前，事务的一系列操作，如果有的成功有的失败，仍然会提交成功的那部分，后来改为全部不提交了。</p>
<p>但是Redis事务不支持回滚，提交以后不能执行回滚操作。</p>
<p>为什么 Redis 不支持回滚（roll back）
如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<p>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。
因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</p>
<h3 class="anchor anchorWithStickyNavbar_HWLp" id="redis脚本事务">redis脚本事务<a href="#redis脚本事务" class="hash-link" aria-label="Direct link to redis脚本事务" title="Direct link to redis脚本事务">​</a></h3>
<p>Redis 脚本和事务
从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p>
<p>redis事务的ACID特性
在传统的关系型数据库中,尝尝用ACID特质来检测事务功能的可靠性和安全性。
在redis中事务总是具有原子性(Atomicity),一致性(Consistency)和隔离性(Isolation),并且当redis运行在某种特定的持久化
模式下,事务也具有耐久性(Durability).</p>
<p>①原子性</p>
<p>事务具有原子性指的是,数据库将事务中的多个操作当作一个整体来执行,服务器要么就执行事务中的所有操作,要么就一个操作也不执行。
但是对于redis的事务功能来说,事务队列中的命令要么就全部执行,要么就一个都不执行,因此redis的事务是具有原子性的。</p>
<p>②一致性</p>
<p>事务具有一致性指的是,如果数据库在执行事务之前是一致的,那么在事务执行之后,无论事务是否执行成功,数据库也应该仍然一致的。
”一致“指的是数据符合数据库本身的定义和要求,没有包含非法或者无效的错误数据。redis通过谨慎的错误检测和简单的设计来保证事务一致性。</p>
<p>③隔离性</p>
<p>事务的隔离性指的是,即使数据库中有多个事务并发在执行,各个事务之间也不会互相影响,并且在并发状态下执行的事务和串行执行的事务产生的结果完全
相同。
因为redis使用单线程的方式来执行事务(以及事务队列中的命令),并且服务器保证,在执行事务期间不会对事物进行中断,因此,redis的事务总是以串行
的方式运行的,并且事务也总是具有隔离性的</p>
<p>④持久性</p>
<p>事务的耐久性指的是,当一个事务执行完毕时,执行这个事务所得的结果已经被保持到永久存储介质里面。
因为redis事务不过是简单的用队列包裹起来一组redis命令,redis并没有为事务提供任何额外的持久化功能,所以redis事务的耐久性由redis使用的模式
决定</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cache/Redis原理与实践总结.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_EYjg" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_eevz"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/code-note-blog/docs/cache/探索Redis设计与实现开篇：什么是Redis"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">探索Redis设计与实现开篇：什么是Redis</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_lc2k thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#使用和基础数据结构外观" class="table-of-contents__link toc-highlight">使用和基础数据结构（外观）</a></li><li><a href="#底层数据结构" class="table-of-contents__link toc-highlight">底层数据结构</a></li><li><a href="#redis-server结构和数据库redisdb" class="table-of-contents__link toc-highlight">redis server结构和数据库redisDb</a></li><li><a href="#redis的事件模型" class="table-of-contents__link toc-highlight">redis的事件模型</a></li><li><a href="#备份方式" class="table-of-contents__link toc-highlight">备份方式</a></li><li><a href="#redis主从复制" class="table-of-contents__link toc-highlight">redis主从复制</a></li><li><a href="#分布式锁实现" class="table-of-contents__link toc-highlight">分布式锁实现</a><ul><li><a href="#使用setnx加expire实现加锁和时限" class="table-of-contents__link toc-highlight">使用setnx加expire实现加锁和时限</a></li><li><a href="#使用getset加锁和获取过期时间" class="table-of-contents__link toc-highlight">使用getset加锁和获取过期时间</a></li><li><a href="#20的setnx可以配置过期时间" class="table-of-contents__link toc-highlight">2.0的setnx可以配置过期时间。</a></li><li><a href="#使用sentx将值设为时间戳通过lua脚本进行cas比较和删除操作" class="table-of-contents__link toc-highlight">使用sentx将值设为时间戳，通过lua脚本进行cas比较和删除操作</a></li><li><a href="#分布式redis锁redlock" class="table-of-contents__link toc-highlight">分布式Redis锁：Redlock</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></li><li><a href="#分布式方案" class="table-of-contents__link toc-highlight">分布式方案</a></li><li><a href="#redis事务" class="table-of-contents__link toc-highlight">redis事务</a><ul><li><a href="#redis脚本事务" class="table-of-contents__link toc-highlight">redis脚本事务</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/code-note-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_B3Gq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>